# file opened: main.asm
   1  0000                  DEFINE TCP_BUF_SIZE 1024
   2  0000              ; Generate version string
   3  0000                  LUA ALLPASS
   4  0000 ~                v = tostring(sj.get_define("V"))
   5  0000 ~                maj = string.sub(v, 1,1)
   6  0000 ~                min = string.sub(v, 2,2)
   7  0000 ~                sj.insert_define("VERSION_STRING", "\"" .. maj .. "." .. min .. "\"")
   8  0000 ~
   9  0000 ~                b = tostring(sj.get_define("BLD"))
  10  0000 ~                sj.insert_define("BUILD_STRING", "\"" .. b .. "\"")
  11  0000                  ENDLUA
  12  0000
  13  0000                  IFDEF MSX
  14  0000 ~                    include "main-msx.asm"
  15  0000                  ELSE
  16  0000                      include "main-all.asm"
# file opened: main-all.asm
   1+ 0000                  device	zxspectrum128
   2+ 0000                  IFDEF NEDOOS
   3+ 0000 ~            	DEFINE CRLF "\r\n"
   4+ 0000 ~                    MODULE nos
   5+ 0000 ~                        include "../_sdk/sysdefs.asm"
   6+ 0000 ~                    ENDMODULE
   7+ 0000 ~                    org nos.PROGSTART
   8+ 0000                      ELSE
   9+ 0000              	DEFINE CRLF "\r"
  10+ 0000                      org 24576
  11+ 6000                  ENDIF
  12+ 6000              asmOrg:
  13+ 6000                  align 256
  14+ 6000 C3 FF 94         jp start
  15+ 6003                  include "vdp/index.asm"
# file opened: vdp/index.asm
   1++6003                  IFDEF TIMEX
   2++6003 ~                include "timex.asm"
   3++6003                  ENDIF
   4++6003
   5++6003                  IFDEF TIMEX80
   6++6003                  include "timex80.asm"
# file opened: vdp/timex80.asm
   1++6003              COLOR=0
   2++6003                  module TextMode
   3++6003              PORT_SELECT = #7c3b
   4++6003              init:
   5++6003 21 C8 61 06      ld hl, font_file, b, Dos.FMODE_READ
   5++6007 01
   6++6008 CD EF 69         call Dos.fopen
   7++600B F5               push af
   8++600C 01 00 08 21      ld bc, 2048, hl, font
   8++6010 00 40
   9++6012 CD DC 6A         call Dos.fread
  10++6015 F1               pop af
  11++6016 CD C8 6A         call Dos.fclose
  12++6019
  13++6019                  IFDEF UNO
  14++6019 ~                ;; Force turbo mode
  15++6019 ~                ld bc, 64571
  15++6019 ~              ld a, #0b
  15++6019 ~              out (c), a
  16++6019 ~                ld bc, 64827
  16++6019 ~              in a, (c)
  16++6019 ~              or #c0
  16++6019 ~              out (c),a
  17++6019                  ENDIF
  18++6019              cls:
  19++6019 3E 07            ld a, 7
  19++601B CD 79 88       call Memory.setPage
  20++601E
  21++601E                  IFDEF UNO
  22++601E ~                ld a, #3E
  22++601E ~              out (#ff), a
  23++601E                  ELSE
  24++601E 01 F7 EF         ld	bc, #EFF7   ;   Scorpio
  25++6021 3E 02            ld a,2
  26++6023 ED 79            out (C), a
  27++6025                  ENDIF
  28++6025
  29++6025 F3               di
  30++6026 21 00 00 54      ld	hl,0, d,h, e,h, b,h, c,b
  30++602A 5C 44 48
  31++602D 39               add	hl,sp
  32++602E 31 00 D8         ld	sp,#c000 + 6144
  33++6031              .loop
  34++6031                  dup 12
  35++6031 D5          >	push	de
  35++6032 D5          >	push	de
  35++6033 D5          >	push	de
  35++6034 D5          >	push	de
  35++6035 D5          >	push	de
  35++6036 D5          >	push	de
  35++6037 D5          >	push	de
  35++6038 D5          >	push	de
  35++6039 D5          >	push	de
  35++603A D5          >	push	de
  35++603B D5          >	push	de
  35++603C D5          >	push	de
  36++603D                  edup
  37++603D
  38++603D 10 F2            djnz	.loop
  39++603F
  40++603F 41               ld	b,c
  41++6040 31 00 F8         ld	sp,#e000 + 6144
  42++6043              .loop2:
  43++6043                  dup 12
  44++6043 D5          >	push	de
  44++6044 D5          >	push	de
  44++6045 D5          >	push	de
  44++6046 D5          >	push	de
  44++6047 D5          >	push	de
  44++6048 D5          >	push	de
  44++6049 D5          >	push	de
  44++604A D5          >	push	de
  44++604B D5          >	push	de
  44++604C D5          >	push	de
  44++604D D5          >	push	de
  44++604E D5          >	push	de
  45++604F                  edup
  46++604F
  47++604F 10 F2            djnz .loop2
  48++6051 F9               ld	sp,hl
  49++6052 21 00 00         ld hl ,0
  49++6055 22 C6 61       ld (coords), hl
  50++6058 AF               xor a
  50++6059 CD 79 88       call Memory.setPage
  51++605C
  52++605C FB               ei
  53++605D C9               ret
  54++605E
  55++605E              ; A - line
  56++605E              usualLine:
  57++605E 57              ld d, a
  58++605F 18 01           jr fill
  59++6061              ; A - line
  60++6061              highlightLine:
  61++6061 57               ld d, a
  62++6062              fill:
  63++6062 1E 00 06 40      ld e, 0, b, 64
  64++6066              .lloop
  65++6066 C5           	push bc
  66++6067 D5           	push de
  67++6068 CD 8D 61     	call findAddr
  68++606B 3E 07            ld a, 7
  68++606D CD 79 88       call Memory.setPage
  69++6070
  70++6070 06 08        	ld b, 8
  71++6072              .cloop
  72++6072 1A           	ld a, (de)
  72++6073 EE FF          xor #ff
  72++6075 12             ld (de), a
  73++6076 14           	inc d
  74++6077 10 F9        	djnz .cloop
  75++6079 D1           	pop de
  76++607A 1C           	inc e
  77++607B C1           	pop bc
  78++607C 10 E8        	djnz .lloop
  79++607E
  80++607E AF               xor a
  80++607F CD 79 88       call Memory.setPage
  81++6082 C9               ret
  82++6083
  83++6083              printZ:
  84++6083 7E               ld a, (hl)
  84++6084 A7             and a
  84++6085 C8             ret z
  85++6086 E5               push hl
  86++6087 CD 8E 60         call putC
  87++608A E1               pop hl
  88++608B 23               inc hl
  89++608C 18 F5            jr printZ
  90++608E
  91++608E
  92++608E              ; A - char
  93++608E              putC:
  94++608E 32 39 61         ld (drawC.char_tmp), a
  95++6091
  96++6091 FE 0D        	cp 13
  97++6093 CA B0 60     	jp z, .cr
  98++6096
  99++6096 ED 5B C6 61      ld de, (coords)
 100++609A 7B               ld a, e
 101++609B FE 55            cp 85
 102++609D D0               ret nc
 103++609E
 104++609E
 105++609E 3E 07            ld a, 7
 106++60A0 CD 79 88         call Memory.setPage
 107++60A3 FD E5            push iy
 108++60A5 CD C7 60         call drawC
 109++60A8 FD E1            pop iy
 110++60AA
 111++60AA 21 C6 61         ld hl, coords
 112++60AD 34               inc (hl)
 113++60AE
 114++60AE 18 12            jr .exit
 115++60B0              .cr
 116++60B0 2A C6 61     	ld hl, (coords)
 117++60B3 24           	inc h
 118++60B4 2E 00 22 C6  	ld l, 0, (coords), hl
 118++60B8 61
 119++60B9 FE 18        	cp 24
 120++60BB D8           	ret c
 121++60BC 21 00 00 22  	ld hl, 0, (coords), hl
 121++60C0 C6 61
 122++60C2              .exit
 123++60C2 AF               xor a
 123++60C3 CD 79 88       call Memory.setPage
 124++60C6 C9           	ret
 125++60C7
 126++60C7              drawC:
 127++60C7 2A C6 61         ld hl, (coords)
 128++60CA 45               ld b, l
 129++60CB CD F6 60         call .calc
 130++60CE 54               ld d, h
 131++60CF 5D               ld e, l
 132++60D0 32 3A 61         ld (.rot_tmp), a
 133++60D3 CD 8D 61         call findAddr
 134++60D6 D5               push de
 135++60D7 CD 2A 61         call .get_char
 136++60DA
 137++60DA E1               pop hl
 138++60DB              .print0
 139++60DB E5 DD E1         ld ix, hl
 140++60DE 7C               ld a, h
 141++60DF CB 6F            bit 5, a
 142++60E1 28 01            jr z, .ok
 143++60E3 2C               inc l
 144++60E4              .ok
 145++60E4 EE 20            xor #20
 145++60E6 67             ld h, a
 146++60E7 E5 FD E1         ld iy, hl
 147++60EA 3A 3A 61         ld a, (.rot_tmp)
 148++60ED CD 19 61         call .rotate_mask
 149++60F0 3A 3A 61         ld a, (.rot_tmp)
 150++60F3 C3 3B 61         jp basic_draw
 151++60F6              .calc
 152++60F6 2E 00              ld l,0
 153++60F8 78                 ld a, b
 153++60F9 A7             and a
 153++60FA C8             ret z
 154++60FB DD 21 00 00        ld ix, 0
 155++60FF 11 06 00           ld de,6
 156++6102 DD 19        1     add ix, de
 157++6104 10 FC              djnz 1b
 158++6106 11 F8 FF           ld de, -8
 159++6109 DD 7C        2     ld a, ixh
 160++610B A7                 and a
 161++610C 20 05              jr nz, 3f
 162++610E DD 7D              ld a, ixl
 163++6110 FE 08              cp 8
 164++6112 D8                 ret c
 165++6113              3
 166++6113 DD 19              add ix, de
 167++6115 2C                 inc l
 168++6116 18 F1              jr 2b
 169++6118 C9                 ret
 170++6119
 171++6119              .rotate_mask
 172++6119 21 FF 03         ld hl, #03ff
 173++611C A7               and a
 173++611D C8             ret z
 174++611E              .rot_loop
 175++611E 08               ex af, af
 176++611F 7D               ld a,l
 177++6120 0F               rrca
 178++6121 CB 1C            rr h
 179++6123 CB 1D            rr l
 180++6125 08               ex af, af
 181++6126 3D               dec a
 182++6127 20 F5            jr nz, .rot_loop
 183++6129 C9               ret
 184++612A              .get_char:
 185++612A 3A 39 61         ld a, (.char_tmp)
 186++612D 6F               ld l, a
 187++612E 26 00            ld h, 0
 188++6130 29               add hl, hl
 189++6131 29               add hl, hl
 190++6132 29               add hl, hl
 191++6133 01 00 40         ld bc, font
 192++6136 09               add hl, bc
 193++6137 EB               ex hl, de
 194++6138 C9               ret
 195++6139 00           .char_tmp db 0
 196++613A 00           .rot_tmp  db 0
 197++613B              ; A - rotation counter
 198++613B              ; DE - font PTR
 199++613B              ; HL - mask
 200++613B              ; IX - left half on screen
 201++613B              ; IY - right half on screen
 202++613B              basic_draw:
 203++613B 32 4D 61         ld (.rot_cnt),a
 204++613E
 205++613E 7D               ld a, l
 206++613F 32 60 61         ld (.mask1), a
 207++6142 7C               ld a, h
 208++6143 32 69 61         ld (.mask2), a
 209++6146 06 08            ld b, 8
 210++6148              .printIt
 211++6148 1A               ld a, (de)
 212++6149 67               ld h, a
 213++614A 2E 00            ld l, 0
 214++614C 3E 00            ld a, 0
 215++614E              .rot_cnt = $ - 1
 216++614E A7               and a
 216++614F 28 0B          jr z, .skiprot
 217++6151              .rot
 218++6151 08               ex af, af
 219++6152 7D               ld a,l
 220++6153 0F               rrca
 221++6154 CB 1C            rr h
 222++6156 CB 1D            rr l
 223++6158 08               ex af, af
 224++6159 3D               dec a
 225++615A 20 F5            jr nz, .rot
 226++615C              .skiprot
 227++615C FD 7E 00         ld a, (iy)
 228++615F E6 0F            and #0f
 229++6161              .mask1 = $ - 1
 230++6161 B5               or l
 231++6162 FD 77 00         ld (iy), a
 232++6165 DD 7E 00         ld a, (ix)
 233++6168 E6 FC            and #fc
 234++616A              .mask2 = $ -1
 235++616A B4               or h
 236++616B DD 77 00         ld (ix), a
 237++616E DD 24            inc ixh
 238++6170 FD 24            inc iyh
 239++6172 13               inc de
 240++6173 10 D3            djnz .printIt
 241++6175 C9               ret
 242++6176
 243++6176
 244++6176              ; H - line
 245++6176              ; A - char
 246++6176              fillLine:
 247++6176 54 1E 00         ld d, h, e, 0
 247++6179 CD 88 61       call gotoXY
 248++617C 06 55            ld b, 85
 249++617E              .loop
 250++617E F5 C5            push af, bc
 251++6180 CD 8E 60         call putC
 252++6183 C1 F1            pop bc, af
 253++6185 10 F7            djnz .loop
 254++6187 C9               ret
 255++6188
 256++6188
 257++6188              gotoXY:
 258++6188 ED 53 C6 61      ld (coords), de
 259++618C C9               ret
 260++618D
 261++618D              ; D - Y
 262++618D              ; E - X
 263++618D              ; OUT: de - coords
 264++618D              findAddr:
 265++618D 7B               ld a, e
 266++618E CB 3F            srl a
 267++6190 5F               ld e,a
 268++6191 06 E0            ld b, #E0
 269++6193 38 02            jr c, .proc
 270++6195 06 C0            ld b, #C0
 271++6197              .proc
 272++6197 7A               LD A,D
 273++6198 E6 07            AND 7
 274++619A 0F               RRCA
 275++619B 0F               RRCA
 276++619C 0F               RRCA
 277++619D B3               OR E
 278++619E 5F               LD E,A
 279++619F 7A               LD A,D
 280++61A0 E6 18            AND 24
 281++61A2 B0               OR b
 282++61A3 57               LD D,A
 283++61A4 C9               ret
 284++61A5
 285++61A5              toggleColor:
 286++61A5 3A BD 61         ld a,(curState)
 287++61A8 FE 07            cp 7
 288++61AA CA B5 61         jp z, sevenEleven
 289++61AD              ;zerroTolerance
 290++61AD 3E 07            ld a,7
 291++61AF 32 BD 61         ld (curState),a
 292++61B2 D3 FE            out (#fe),a
 293++61B4 C9               ret
 294++61B5              sevenEleven:
 295++61B5 3E 00            ld a,0
 296++61B7 32 BD 61         ld (curState),a
 297++61BA D3 FE            out (#fe),a
 298++61BC C9               ret
 299++61BD              curState:
 300++61BD 00               db 0
 301++61BE              disable:
 302++61BE                  IFDEF UNO
 303++61BE ~                xor a
 303++61BE ~              out (#fe), a
 303++61BE ~              out (#ff), a
 304++61BE                  ELSE
 305++61BE 01 F7 EF         ld	bc, #EFF7   ;   Scorpio
 306++61C1 3E 00            ld a,0
 307++61C3 ED 79            out (C), a
 308++61C5                  ENDIF
 309++61C5 C9               ret
 310++61C6
 311++61C6 00 00        coords dw 0
 312++61C8              font equ #4000 ; Using ZX-Spectrum screen as font buffer
 313++61C8 66 6F 6E 74  font_file db "font80.bin", 0
 313++61CC 38 30 2E 62
 313++61D0 69 6E 00
 314++61D3                  endmodule
 315++61D3
 316++61D3              exit:
 317++61D3 01 3B 7C 3E      ld bc, TextMode.PORT_SELECT, a, 1
 317++61D7 01
 318++61D8 ED 79            out (c), a
 319++61DA 04               inc b
 319++61DB AF             xor a
 320++61DC ED 79            out (c), a
 321++61DE C7               rst 0
# file closed: vdp/timex80.asm
   7++61DF                  ENDIF
   8++61DF
   9++61DF                  IFDEF ZXSCR
  10++61DF ~                include "zx.asm"
  11++61DF                  ENDIF
  12++61DF
  13++61DF              	IFDEF NEDOOS
  14++61DF ~                include "nedotext.asm"
  15++61DF                  ENDIF
# file closed: vdp/index.asm
  16+ 61DF                  include "utils/index.asm"
# file opened: utils/index.asm
   1++61DF                  include "atoi.asm"
# file opened: utils/atoi.asm
   1++61DF              ; DE - buffer
   2++61DF              ; HL - output
   3++61DF              atohl:
   4++61DF 21 00 00         ld hl, 0
   5++61E2              .loop
   6++61E2 1A               ld a, (de)
   7++61E3 13               inc de
   8++61E4                  ; Sepparators
   9++61E4 C5 E5            push bc, hl
  10++61E6 01 05 00             ld bc, sepparators_len
  11++61E9 21 01 62             ld hl, sepparators
  12++61EC ED B1                cpir
  13++61EE E1 C1            pop hl, bc
  14++61F0 C8               ret z
  15++61F1
  16++61F1 D6 30            sub '0'
  17++61F3
  18++61F3 C5               push bc
  19++61F4 4D                   ld c, l
  20++61F5 44                   ld b, h
  21++61F6
  22++61F6 29                   add hl, hl
  23++61F7 29                   add hl, hl
  24++61F8 09                   add hl, bc
  25++61F9 29                   add hl, hl
  26++61FA 4F                   ld c, a
  27++61FB 06 00                ld b, 0
  28++61FD 09                   add hl, bc
  29++61FE C1               pop bc
  30++61FF 18 E1            jr .loop
  31++6201
# file closed: utils/atoi.asm
   2++6201                  include "constants.asm"
# file opened: utils/constants.asm
   1++6201              TAB = 9
   2++6201              CR = 13
   3++6201              LF = 10
   4++6201              NULL = 0
   5++6201              SPACE = ' '
   6++6201              ESC = 27
   7++6201              BACKSPACE = 8
   8++6201
   9++6201                  IFDEF TIMEX80
  10++6201              MIME_DOWNLOAD 	= #19
  11++6201              MIME_LINK 		= #1A
  12++6201              MIME_TEXT 		= #10
  13++6201              MIME_IMAGE 		= #01
  14++6201              MIME_MUSIC 		= #0e
  15++6201              MIME_INPUT 		= #b3
  16++6201              MIME_MOD 		= #0d
  17++6201
  18++6201              BORDER_TOP = #b2
  19++6201              BORDER_BOTTOM = #b1
  20++6201                  ELSE
  21++6201 ~            	IFDEF MSX
  22++6201 ~            MIME_DOWNLOAD 	= 1
  23++6201 ~            MIME_LINK		= 2
  24++6201 ~            MIME_TEXT 		= 3
  25++6201 ~            MIME_IMAGE 		= 4
  26++6201 ~            MIME_MUSIC 		= 5
  27++6201 ~            MIME_INPUT 		= 6
  28++6201 ~            MIME_MOD      	= 7
  29++6201 ~            BORDER_TOP    = 7
  30++6201 ~            BORDER_BOTTOM = 8
  31++6201 ~            	ELSE
  32++6201 ~            MIME_DOWNLOAD = 1
  33++6201 ~            MIME_LINK     = 2
  34++6201 ~            MIME_TEXT     = 3
  35++6201 ~            MIME_IMAGE    = 6
  36++6201 ~            MIME_MUSIC    = 5
  37++6201 ~            MIME_INPUT    = 4
  38++6201 ~            MIME_MOD      = 7
  39++6201 ~
  40++6201 ~            BORDER_TOP    = 9
  41++6201 ~            BORDER_BOTTOM = 8
  42++6201 ~            	ENDIF
  43++6201 ~
  44++6201 ~
  45++6201 ~
  46++6201 ~
  47++6201              	ENDIF
  48++6201
  49++6201 0D 0A 09 00  sepparators db CR, LF, TAB, NULL, SPACE
  49++6205 20
  50++6206              sepparators_len = $ - sepparators
# file closed: utils/constants.asm
   3++6206                  include "strutils.asm"
# file opened: utils/strutils.asm
   1++6206              ; de - pointer
   2++6206              ; hl - count
   3++6206              strlen:
   4++6206 21 00 00         ld hl, 0
   5++6209              .loop
   6++6209 1A               ld a, (de)
   7++620A A7               and a
   7++620B 28 04          jr z, .exit
   8++620D 23               inc hl
   9++620E 13               inc de
  10++620F 18 F8            jr .loop
  11++6211              .exit
  12++6211 C9               ret
  13++6212
  14++6212                  module CompareBuff
  15++6212
  16++6212              ; Pushes A to buffer
  17++6212              push
  18++6212 F5               push af
  19++6213 06 20            ld b, 32
  19++6215 21 5E 62       ld hl, buffer + 1
  19++6218 11 5D 62       ld de, buffer
  20++621B              .loop
  21++621B 7E               ld a, (hl)
  21++621C 12             ld (de), a
  21++621D 23             inc hl
  21++621E 13             inc de
  21++621F 10 FA          djnz .loop
  22++6221 F1               pop af
  23++6222 21 7C 62         ld hl, buffer + 31
  23++6225 77             ld (hl), a
  24++6226 C9               ret
  25++6227
  26++6227              ; HL - Compare string(null terminated)
  27++6227              ; A - 0 NOT Found
  28++6227              ;     1 Found
  29++6227              search:
  30++6227 06 00            ld b, 0
  30++6229 E5             push hl
  31++622A              .loop:
  32++622A 7E               ld a, (hl)
  32++622B 23             inc hl
  32++622C 04             inc b
  32++622D A7             and a
  32++622E C2 2A 62       jp nz, .loop
  33++6231 05               dec b
  33++6232 E1             pop hl
  33++6233 C5             push bc
  33++6234 E5             push hl
  34++6235 E1               pop hl
  35++6236 11 7D 62         ld de, buffer + 32
  36++6239              .sourceLoop
  37++6239 1B               dec de
  37++623A 10 FD          djnz .sourceLoop
  38++623C C1               pop bc
  39++623D              .compare
  40++623D C5               push bc
  40++623E F5             push af
  41++623F 1A               ld a, (de)
  41++6240 47             ld b, a
  42++6241 F1               pop af
  42++6242 7E             ld a, (hl)
  42++6243 B8             cp b
  42++6244 C1             pop bc
  42++6245 3E 00          ld a, 0
  42++6247 C0             ret nz
  43++6248 13               inc de
  43++6249 23             inc hl
  44++624A 10 F1            djnz .compare
  45++624C 3E 01            ld a, 1
  46++624E C9               ret
  47++624F
  48++624F              clear:
  49++624F AF               xor a
  49++6250 21 5D 62       ld hl, buffer
  49++6253 11 5E 62       ld de, buffer + 1
  49++6256 01 20 00       ld bc, 32
  49++6259 77             ld (hl), a
  49++625A ED B0          ldir
  50++625C C9               ret
  51++625D
  52++625D 00 00 00...  buffer ds 32
  53++627D
  54++627D                  endmodule
# file closed: utils/strutils.asm
   4++627D                  IFDEF MSX
   5++627D ~            	    include "bios.asm"
   6++627D                  ENDIF
   7++627D                  include "screen.asm"
# file opened: utils/screen.asm
   1++627D              LINE_LIMIT = 63
   2++627D
   3++627D                  IFDEF NEDOOS
   4++627D ~            LINE_LIMIT = 79
   5++627D                  ENDIF
   6++627D
   7++627D                  IFDEF TIMEX80
   8++627D              LINE_LIMIT = 84
   9++627D                  ENDIF
  10++627D
  11++627D                  IFDEF MSX
  12++627D ~            LINE_LIMIT = 79
  13++627D                  ENDIF
  14++627D              ; HL - string pointer
  15++627D              print70Text:
  16++627D 06 54            ld b, LINE_LIMIT
  17++627F              .loop
  18++627F 7E               ld a, (hl)
  19++6280 A7               and a
  19++6281 C8             ret z
  20++6282 FE 0D            cp 13
  20++6284 C8             ret z
  21++6285 FE 0A            cp 10
  21++6287 C8             ret z
  22++6288 C5               push bc
  23++6289 E5               push hl
  24++628A CD 8E 60         call TextMode.putC
  25++628D E1               pop hl
  26++628E 23               inc hl
  27++628F C1               pop bc
  28++6290 05               dec b
  29++6291 78               ld a, b
  29++6292 A7             and a
  29++6293 C8             ret z
  30++6294 C3 7F 62         jp .loop
  31++6297
  32++6297              ; HL - string pointer
  33++6297              print70Goph:
  34++6297 06 54            ld b, LINE_LIMIT
  35++6299              .loop
  36++6299 7E               ld a, (hl)
  36++629A FE 09          cp 09
  36++629C C8             ret z
  37++629D A7               and a
  37++629E C8             ret z
  38++629F C5               push bc
  39++62A0 E5               push hl
  40++62A1 CD 8E 60         call TextMode.putC
  41++62A4 E1               pop hl
  42++62A5 23               inc hl
  43++62A6 C1               pop bc
  44++62A7 05               dec b
  45++62A8 78               ld a, b
  45++62A9 A7             and a
  45++62AA C8             ret z
  46++62AB C3 99 62         jp .loop
# file closed: utils/screen.asm
# file closed: utils/index.asm
  17+ 62AE                  include "gopher/render/index.asm"
# file opened: gopher/render/index.asm
   1++62AE                  MODULE Render
   2++62AE              PER_PAGE = 22
   3++62AE              CURSOR_OFFSET = 2
   4++62AE                  include "row.asm"
# file opened: gopher/render/row.asm
   1++62AE              ; A - row number
   2++62AE              ; HL - pointer to row
   3++62AE              renderRow:
   4++62AE C6 02            add CURSOR_OFFSET
   5++62B0 57               ld d,a
   6++62B1 1E 00            ld e,0
   7++62B3 CD 88 61         call TextMode.gotoXY
   8++62B6 7E               ld a,(hl)
   9++62B7 E5               push hl
  10++62B8 CD C3 62         call getIcon
  11++62BB CD 8E 60         call TextMode.putC
  12++62BE E1               pop hl
  13++62BF 23               inc hl
  14++62C0 C3 97 62         jp print70Goph
  15++62C3
  16++62C3              ; A - gopher id char
  17++62C3              getIcon:
  18++62C3 FE 69            cp 'i'
  18++62C5 CA DF 62       jp z, .info
  19++62C8 FE 39            cp '9'
  19++62CA CA E2 62       jp z, .down
  20++62CD FE 31            cp '1'
  20++62CF CA 48 63       jp z, .page
  21++62D2 FE 30            cp '0'
  21++62D4 CA 4B 63       jp z, .text
  22++62D7 FE 37            cp '7'
  22++62D9 CA 4E 63       jp z, .input
  23++62DC 3E 20            ld a, ' '
  24++62DE C9               ret
  25++62DF              .info
  26++62DF 3E 20            ld a, SPACE
  26++62E1 C9             ret
  27++62E2              .down
  28++62E2 54 5D            ld de, hl
  29++62E4 01 FF 00 3E      ld bc, #ff, a, TAB
  29++62E8 09
  29++62E9 ED B1          cpir
  30++62EB 78               ld a, b
  30++62EC B1             or c
  30++62ED 28 56          jr z, .downExit
  31++62EF D5               push de
  32++62F0              .nameLoop
  33++62F0 7E               ld a, (hl)
  33++62F1 A7             and a
  33++62F2 28 10          jr z, .check
  34++62F4 FE 09            cp TAB
  34++62F6 28 0C          jr z, .check
  35++62F8 FE 0D            cp CR
  35++62FA 28 08          jr z, .check
  36++62FC E5               push hl
  37++62FD CD 12 62         call CompareBuff.push
  38++6300 E1               pop hl
  39++6301 23               inc hl
  40++6302 18 EC            jr .nameLoop
  41++6304              .check
  42++6304 21 5D 63         ld hl, scrExt1
  42++6307 CD 27 62       call CompareBuff.search
  42++630A A7             and a
  42++630B 20 44          jr nz, .image
  43++630D 21 62 63         ld hl, scrExt2
  43++6310 CD 27 62       call CompareBuff.search
  43++6313 A7             and a
  43++6314 20 3B          jr nz, .image
  44++6316 3E 03            ld a, 3
  44++6318 32 EE 88       ld (VTPL.SETUP), a ; 0 bit - looping, 1 bit - pt2 file
  45++631B 21 71 63         ld hl, pt2Ext1
  45++631E CD 27 62       call CompareBuff.search
  45++6321 A7             and a
  45++6322 20 31          jr nz, .music
  46++6324 21 76 63         ld hl, pt2Ext2
  46++6327 CD 27 62       call CompareBuff.search
  46++632A A7             and a
  46++632B 20 28          jr nz, .music
  47++632D 3E 01            ld a, 1
  47++632F 32 EE 88       ld (VTPL.SETUP), a
  48++6332 21 67 63         ld hl, pt3Ext1
  48++6335 CD 27 62       call CompareBuff.search
  48++6338 A7             and a
  48++6339 20 1A          jr nz, .music
  49++633B 21 6C 63         ld hl, pt3Ext2
  49++633E CD 27 62       call CompareBuff.search
  49++6341 A7             and a
  49++6342 20 11          jr nz, .music
  50++6344
  51++6344                  ; General Sound support
  52++6344                  ifdef GS
  53++6344 ~                ld hl, modExt1
  53++6344 ~              call CompareBuff.search
  53++6344 ~              and a
  53++6344 ~              jr nz, .mod
  54++6344 ~                ld hl, modExt2
  54++6344 ~              call CompareBuff.search
  54++6344 ~              and a
  54++6344 ~              jr nz, .mod
  55++6344                  endif
  56++6344
  57++6344              .checkExit
  58++6344 E1               pop hl
  59++6345              .downExit
  60++6345 3E 19            ld a, MIME_DOWNLOAD
  60++6347 C9             ret
  61++6348              .page
  62++6348 3E 1A            ld a, MIME_LINK
  62++634A C9             ret
  63++634B              .text
  64++634B 3E 10            ld a, MIME_TEXT
  64++634D C9             ret
  65++634E              .input
  66++634E 3E B3            ld a, MIME_INPUT
  66++6350 C9             ret
  67++6351              .image
  68++6351 E1               pop hl
  68++6352 3E 01          ld a, MIME_IMAGE
  68++6354 C9             ret
  69++6355              .music
  70++6355 E1               pop hl
  70++6356 3E 0E          ld a, MIME_MUSIC
  70++6358 C9             ret
  71++6359              .mod
  72++6359 E1               pop hl
  72++635A 3E 0D          ld a, MIME_MOD
  72++635C C9             ret
  73++635D
  74++635D 2E 73 63 72  scrExt1 db ".scr", 0
  74++6361 00
  75++6362 2E 53 43 52  scrExt2 db ".SCR", 0
  75++6366 00
  76++6367
  77++6367 2E 70 74 33  pt3Ext1 db ".pt3", 0
  77++636B 00
  78++636C 2E 50 54 33  pt3Ext2 db ".PT3", 0
  78++6370 00
  79++6371 2E 70 74 32  pt2Ext1 db ".pt2", 0
  79++6375 00
  80++6376 2E 50 54 32  pt2Ext2 db ".PT2", 0
  80++637A 00
  81++637B 2E 6D 6F 64  modExt1 db ".mod", 0
  81++637F 00
  82++6380 2E 4D 4F 44  modExt2 db ".MOD", 0
  82++6384 00
# file closed: gopher/render/row.asm
   5++6385                  include "buffer.asm"
# file opened: gopher/render/buffer.asm
   1++6385              ; BC - line count
   2++6385              findLine
   3++6385 21 FF 94         ld hl, outputBuffer
   4++6388              findLine2
   5++6388 78               ld a,b
   6++6389 B1               or c
   7++638A CA B7 63         jp z, .checkEmpty
   8++638D              .loop
   9++638D 7E               ld a, (hl)
  10++638E A7               and a
  11++638F CA BA 63         jp z, .nope
  12++6392 23               inc hl
  13++6393 FE 0D            cp 13
  14++6395 CA AD 63         jp z, .checkLF  ;13
  15++6398 FE 0A            cp 10
  15++639A CA A0 63       jp z, .nextCheck     ;10
  16++639D C3 8D 63         jp .loop
  17++63A0              .nextCheck
  18++63A0 A7               and a
  19++63A1 CA BA 63         jp z, .nope
  20++63A4 0B               dec bc
  21++63A5 57               ld d,a
  22++63A6 78               ld a,b
  23++63A7 B1               or c
  24++63A8 7A               ld a,d
  25++63A9 C2 8D 63         jp nz, .loop
  26++63AC C9               ret
  27++63AD              .checkLF
  28++63AD 7E               ld a, (hl)
  29++63AE FE 0A            cp 10
  30++63B0 C2 A0 63         jp nz, .nextCheck    ;10
  31++63B3 23               inc hl
  32++63B4 C3 A0 63         jp  .nextCheck
  33++63B7              .checkEmpty
  34++63B7 7E               ld a, (hl)
  34++63B8 A7             and a
  34++63B9 C0             ret nz
  35++63BA              .nope
  36++63BA 21 00 00         ld hl, 0
  36++63BD C9             ret
  37++63BE
# file closed: gopher/render/buffer.asm
   6++63BE                  include "ui.asm"
# file opened: gopher/render/ui.asm
   1++63BE                  IFDEF ZXSCR
   2++63BE ~                DEFINE LEFT_TAB "[D]omain:                                  "
   3++63BE                  ENDIF
   4++63BE
   5++63BE                  IFDEF TIMEX     ;UNKNOWM fallback to 64
   6++63BE ~                DEFINE LEFT_TAB "[D]omain:                                  "
   7++63BE                  ENDIF
   8++63BE
   9++63BE                  IFDEF TIMEX80
  10++63BE                  DEFINE LEFT_TAB "[D]omain:                                                      "
  11++63BE                  ENDIF
  12++63BE
  13++63BE                  IFDEF NEDOOS
  14++63BE ~                DEFINE LEFT_TAB "[D]omain:                                                  "
  15++63BE                  ENDIF
  16++63BE
  17++63BE                  IFDEF MSX
  18++63BE ~                DEFINE LEFT_TAB "[D]omain:                                              "
  19++63BE                  ENDIF
  20++63BE              prepareScreen:
  21++63BE CD 19 60         call TextMode.cls
  22++63C1 21 91 64         ld hl, header
  22++63C4 CD 83 60       call TextMode.printZ
  23++63C7 11 0A 00         ld de, #000A
  23++63CA CD 88 61       call TextMode.gotoXY
  24++63CD 21 A0 80         ld hl, hostName
  24++63D0 CD 83 60       call TextMode.printZ
  25++63D3 AF               xor a
  25++63D4 CD 61 60       call TextMode.highlightLine
  26++63D7 C9               ret
  27++63D8
  28++63D8              inputHost:
  29++63D8 CD 48 68         	call Console.waitForKeyUp
  30++63DB              .loop
  31++63DB 11 0A 00         ld de, #000A
  31++63DE CD 88 61       call TextMode.gotoXY
  31++63E1 21 A0 80       ld hl, hostName
  31++63E4 CD 83 60       call TextMode.printZ
  32++63E7 3E B3            ld a, MIME_INPUT
  32++63E9 CD 8E 60       call TextMode.putC
  33++63EC 3E 20            ld a, ' '
  33++63EE CD 8E 60       call TextMode.putC
  34++63F1              .wait
  35++63F1 CD 55 68         call Console.getC
  36++63F4 5F               ld e, a
  37++63F5 FE 0C            cp Console.BACKSPACE
  37++63F7 28 17          jr z, .removeChar
  38++63F9 FE 0D            cp CR
  38++63FB CA 1E 64       jp z, inputNavigate
  39++63FE FE 20            cp 32
  39++6400 38 EF          jr c, .wait
  40++6402              .putC
  41++6402 AF               xor a
  41++6403 21 A0 80 01    ld hl, hostName, bc, 48
  41++6407 30 00
  41++6409 ED B1          cpir
  42++640B 77               ld (hl), a
  42++640C 2B             dec hl
  42++640D 73             ld (hl), e
  43++640E 18 CB            jr .loop
  44++6410              .removeChar
  45++6410 AF               xor a
  46++6411 21 A0 80 01      ld hl, hostName, bc, 48
  46++6415 30 00
  46++6417 ED B1          cpir
  47++6419 2B               dec hl
  47++641A 2B             dec hl
  47++641B 77             ld (hl), a
  48++641C 18 BD            jr .loop
  49++641E
  50++641E              inputNavigate:
  51++641E 21 A0 80 11      ld hl, hostName, de, domain
  51++6422 51 64
  52++6424 7E               ld a,(hl)
  53++6425 A7               and a
  54++6426 CA 17 70         jp z, History.load
  55++6429              .loop
  56++6429 7E               ld a, (hl)
  56++642A A7             and a
  56++642B 28 05          jr z, .complete
  57++642D 12               ld (de), a
  57++642E 23 13          inc hl, de
  58++6430 18 F7            jr .loop
  59++6432              .complete
  60++6432 3E 09            ld a, TAB
  60++6434 12             ld (de), a
  60++6435 13             inc de
  61++6436 3E 37            ld a, '7'
  61++6438 12             ld (de), a
  61++6439 13             inc de
  62++643A 3E 30            ld a, '0'
  62++643C 12             ld (de), a
  62++643D 13             inc de
  63++643E 3E 0D            ld a, CR
  63++6440 12             ld (de), a
  63++6441 13             inc de
  64++6442 3E 0A            ld a, LF
  64++6444 12             ld (de), a
  64++6445 13             inc de
  65++6446 21 4C 64         ld hl, navRow
  65++6449 C3 70 70       jp History.navigate
  66++644C
  67++644C 31 20 09 2F  navRow db "1 ", TAB, "/", TAB
  67++6450 09
  68++6451 6E 69 68 69  domain db "nihirash.net"
  68++6455 72 61 73 68
  68++6459 2E 6E 65 74
  69++645D 00 00 00...      ds 64 - ($ - domain)
  70++6491
  71++6491 5B 44 5D 6F  header db "[D]omain:                                                      ", "MRF "
  71++6495 6D 61 69 6E
  71++6499 3A 20 20 20
  71++649D 20 20 20 20
  71++64A1 20 20 20 20
  71++64A5 20 20 20 20
  71++64A9 20 20 20 20
  71++64AD 20 20 20 20
  71++64B1 20 20 20 20
  71++64B5 20 20 20 20
  71++64B9 20 20 20 20
  71++64BD 20 20 20 20
  71++64C1 20 20 20 20
  71++64C5 20 20 20 20
  71++64C9 20 20 20 20
  71++64CD 20 20 20 4D
  71++64D1 52 46 20
  72++64D4 31 2E 37            db "1.7"
  73++64D7 2E                  db "."
  74++64D8 31 32               db "12"
  75++64DA              	IFDEF MSX
  76++64DA ~                   db " [MSX UNAPI]",13, 0
  77++64DA              	ENDIF
  78++64DA
  79++64DA                  IFDEF MB03
  80++64DA ~                   db " [MB03+]",13, 0
  81++64DA                     ENDIF
  82++64DA
  83++64DA                  IFDEF UNO
  84++64DA ~                   db " [UNO UART]",13, 0
  85++64DA                  ENDIF
  86++64DA
  87++64DA                  IFDEF AY
  88++64DA ~                   db " [AYWIFI]",13, 0
  89++64DA              	ENDIF
  90++64DA
  91++64DA                  IFDEF ZW
  92++64DA 20 5B 5A 58         db " [ZXWiFi]",13, 0
  92++64DE 57 69 46 69
  92++64E2 5D 0D 00
  93++64E5                  ENDIF
  94++64E5
  95++64E5                   IFDEF NEDOOSATM
  96++64E5 ~                   db " [ATM UART]",13, 0
  97++64E5                  ENDIF
  98++64E5
  99++64E5                  IFDEF NEDOOSEVO
 100++64E5 ~                   db " [EVO UART]",13, 0
 101++64E5                  ENDIF
 102++64E5
 103++64E5                  IFDEF UNOUART
 104++64E5 ~                   db " [UNO UART]",13, 0
 105++64E5                  ENDIF
 106++64E5
 107++64E5                  IFDEF NEDOOS
 108++64E5 ~            	IFNDEF NEDOOSATM
 109++64E5 ~            	IFNDEF NEDOOSEVO
 110++64E5 ~                   db "  [nedoNET]",13, 0
 111++64E5 ~
 112++64E5 ~                ENDIF
 113++64E5 ~            	ENDIF
 114++64E5              	ENDIF
 115++64E5
# file closed: gopher/render/ui.asm
   7++64E5                  include "gopher-page.asm"
# file opened: gopher/render/gopher-page.asm
   1++64E5              renderGopherScreen:
   2++64E5 3E FF            ld a, 255
   3++64E7 32 8B 88         ld (oldminutes), a
   4++64EA CD BE 63         call Render.prepareScreen
   5++64ED
   6++64ED 2A 8E 73         ld hl, (page_offset)        ; HL - offset to 0 Row on screen
   7++64F0 44 4D            ld bc,hl                    ; BC - offset to C Row on screen
   8++64F2 CD 85 63         call Render.findLine        ;BC - Search this line  HL - Return pointer to page with offset
   9++64F5 7C               ld a, h
  10++64F6 B5               or l
  11++64F7 28 21            jr z, .exit2
  12++64F9 7B               ld a, e
  13++64FA AF               xor a
  14++64FB E5               push hl
  15++64FC CD AE 62         call renderRow
  16++64FF E1               pop hl
  17++6500
  18++6500 06 15            ld b, PER_PAGE-1
  19++6502
  20++6502              .loop
  21++6502 C5               push bc
  22++6503 3E 16            ld a, PER_PAGE
  23++6505 90               sub b
  24++6506 5F               ld e,a
  25++6507
  26++6507 01 01 00         ld bc, 1
  27++650A
  28++650A CD 88 63         call Render.findLine2   ;BC - Search this line  HL - Return pointer to page with offset
  29++650D
  30++650D 7C               ld a, h
  31++650E B5               or l
  32++650F 28 06            jr z, .exit
  33++6511 7B               ld a, e
  34++6512 E5               push hl
  35++6513 CD AE 62         call renderRow
  36++6516 E1               pop hl
  37++6517              .exit
  38++6517 C1               pop bc
  39++6518 10 E8            djnz .loop
  40++651A              .exit2
  41++651A CD 1A 66         call showCursor
  42++651D C9               ret
  43++651E
  44++651E              checkBorder:
  45++651E 3A 8C 73         ld a, (cursor_position)
  45++6521 FE FF          cp #ff
  45++6523 CA 3E 66       jp z, pageUp
  46++6526 3A 8C 73         ld a, (cursor_position)
  46++6529 FE 16          cp PER_PAGE
  46++652B CA 71 66       jp z, pageDn
  47++652E CD 1A 66         call showCursor
  48++6531 C3 34 65         jp workLoop
  49++6534
  50++6534              workLoop:
  51++6534 3A 64 67         ld a, (play_next)
  51++6537 A7             and a
  51++6538 C2 CF 65       jp nz, navigate
  52++653B
  53++653B                  dup 4
  54++653B 76          >    halt
  54++653C 76          >    halt
  54++653D 76          >    halt
  54++653E 76          >    halt
  55++653F                  edup
  56++653F              .nothing
  57++653F
  58++653F 76               halt
  59++6540 CD 84 88         call printRTC
  60++6543
  61++6543 CD 66 68         call Console.peekC
  62++6546 A7               and a
  62++6547 CA 3F 65       jp z, .nothing
  63++654A
  64++654A FE 31            cp '1'
  64++654C CA 00 70       jp z, History.back
  65++654F FE 32            cp '2'
  65++6551 CA CF 65       jp z, navigate
  66++6554 FE 33            cp '3'
  66++6556 CA 2A 66       jp z, cursorDown
  67++6559 FE 34            cp '4'
  67++655B CA 34 66       jp z, cursorUp
  68++655E FE 35            cp '5'
  68++6560 CA 3E 66       jp z, pageUp
  69++6563 FE 38            cp '8'
  69++6565 CA 71 66       jp z, pageDn
  70++6568 FE 36            cp '6'
  70++656A CA 2A 66       jp z, cursorDown
  71++656D FE 37            cp '7'
  71++656F CA 34 66       jp z, cursorUp
  72++6572
  73++6572 FE 0A            cp Console.KEY_DN
  73++6574 CA 2A 66       jp z, cursorDown
  74++6577 FE 61            cp 'a'
  74++6579 CA 2A 66       jp z, cursorDown
  75++657C FE 0B            cp Console.KEY_UP
  75++657E CA 34 66       jp z, cursorUp
  76++6581 FE 71            cp 'q'
  76++6583 CA 34 66       jp z, cursorUp
  77++6586 FE 08            cp Console.KEY_LT
  77++6588 CA 3E 66       jp z, pageUp
  78++658B FE 6F            cp 'o'
  78++658D CA 3E 66       jp z, pageUp
  79++6590 FE 09            cp Console.KEY_RT
  79++6592 CA 71 66       jp z, pageDn
  80++6595 FE 70            cp 'p'
  80++6597 CA 71 66       jp z, pageDn
  81++659A
  82++659A FE 68            cp 'h'
  82++659C CA 6D 70       jp z, History.home
  83++659F FE 48            cp 'H'
  83++65A1 CA 6D 70       jp z, History.home
  84++65A4
  85++65A4 FE 62            cp 'b'
  85++65A6 CA 00 70       jp z, History.back
  86++65A9 FE 42            cp 'B'
  86++65AB CA 00 70       jp z, History.back
  87++65AE FE 0C            cp Console.BACKSPACE
  87++65B0 CA 00 70       jp z, History.back
  88++65B3
  89++65B3 FE 64            cp 'd'
  89++65B5 CA D8 63       jp z, inputHost
  90++65B8 FE 44            cp 'D'
  90++65BA CA D8 63       jp z, inputHost
  91++65BD
  92++65BD FE 0D            cp CR
  92++65BF CA CF 65       jp z, navigate
  93++65C2
  94++65C2                  IFDEF MSX
  95++65C2 ~                	cp ESC
  95++65C2 ~              jp z, exit
  96++65C2                  ENDIF
  97++65C2
  98++65C2                  IFDEF GS
  99++65C2 ~                cp 'M'
  99++65C2 ~              call z, GeneralSound.toggleModule
 100++65C2 ~                cp 'm'
 100++65C2 ~              call z, GeneralSound.toggleModule
 101++65C2 ~                cp 'g'
 101++65C2 ~              call z, GeneralSound.toggleDownload
 102++65C2 ~                cp 'G'
 102++65C2 ~              call z, GeneralSound.toggleDownload
 103++65C2                  ENDIF
 104++65C2
 105++65C2                  IFDEF TIMEX80
 106++65C2 FE 54            cp 'T'
 106++65C4 CC A5 61       call z, TextMode.toggleColor
 107++65C7 FE 74            cp 't'
 107++65C9 CC A5 61       call z, TextMode.toggleColor
 108++65CC                  ENDIF
 109++65CC
 110++65CC C3 34 65         jp workLoop
 111++65CF
 112++65CF              navigate:
 113++65CF CD 48 68         call Console.waitForKeyUp
 114++65D2 AF               xor a
 114++65D3 32 64 67       ld (play_next), a
 115++65D6 CD 22 66         call hideCursor
 116++65D9 ED 4B 8E 73      ld bc, (page_offset)
 117++65DD 2A 8C 73         ld hl, (cursor_position)
 118++65E0 09               add hl,bc
 119++65E1 44               ld b, h ;HHHHH
 120++65E2 4D               ld c, l ;LLLLL
 121++65E3 D5               push de
 122++65E4 CD 85 63         call Render.findLine
 123++65E7 D1               pop de
 124++65E8 7E               ld a, (hl)
 125++65E9 FE 31            cp '1'
 125++65EB CA 03 66       jp z, .load
 126++65EE FE 30            cp '0'
 126++65F0 CA 03 66       jp z, .load
 127++65F3 FE 39            cp '9'
 127++65F5 CA 03 66       jp z, .load
 128++65F8 FE 37            cp '7'
 128++65FA CA 0B 66       jp z, .input
 129++65FD CD 1A 66         call showCursor
 130++6600 C3 34 65         jp workLoop
 131++6603              .load
 132++6603 E5               push hl
 133++6604 CD C3 62         call getIcon
 134++6607 E1               pop hl
 135++6608 C3 70 70         jp History.navigate
 136++660B              .input
 137++660B E5               push hl
 138++660C CD 65 67         call DialogBox.inputBox
 139++660F E1               pop hl
 140++6610 3A C0 67         ld a, (DialogBox.inputBuffer)
 140++6613 A7             and a
 140++6614 CA 17 70       jp z, History.load
 141++6617 C3 03 66         jp .load
 142++661A
 143++661A              showCursor:
 144++661A 3A 8C 73         ld a, (cursor_position)
 144++661D C6 02          add CURSOR_OFFSET
 145++661F C3 61 60         jp TextMode.highlightLine
 146++6622
 147++6622              hideCursor:
 148++6622 3A 8C 73         ld a, (cursor_position)
 148++6625 C6 02          add CURSOR_OFFSET
 149++6627 C3 5E 60         jp TextMode.usualLine
 150++662A
 151++662A              cursorDown:
 152++662A CD 22 66         call hideCursor
 153++662D 21 8C 73         ld hl, cursor_position
 154++6630 34               inc (hl)
 155++6631 C3 1E 65         jp checkBorder
 156++6634
 157++6634              cursorUp:
 158++6634 CD 22 66         call hideCursor
 159++6637 21 8C 73         ld hl, cursor_position
 160++663A 35               dec (hl)
 161++663B C3 1E 65         jp checkBorder
 162++663E
 163++663E              pageUp:
 164++663E 3A 8E 73         ld a, (page_offset)
 164++6641 FE 00          cp 0
 164++6643 C2 51 66       jp nz, .pageUp2
 165++6646 3A 8F 73         ld a, (page_offset + 1)
 165++6649 FE 00          cp 0
 165++664B C2 51 66       jp nz, .pageUp2
 166++664E C3 67 66         jp .skip
 167++6651              .pageUp2:
 168++6651 3E 15            ld a, PER_PAGE - 1
 168++6653 32 8C 73       ld (cursor_position), a
 169++6656 2A 8E 73         ld hl, (page_offset)
 170++6659 11 16 00         ld de,PER_PAGE
 171++665C ED 52            sbc hl,de
 172++665E 22 8E 73         ld (page_offset), hl
 173++6661              .exit
 174++6661 CD E5 64         call renderGopherScreen
 175++6664 C3 34 65         jp workLoop
 176++6667              .skip
 177++6667 AF               xor a
 177++6668 32 8C 73       ld (cursor_position), a
 177++666B CD E5 64       call renderGopherScreen
 177++666E C3 34 65       jp workLoop
 178++6671
 179++6671              pageDn:
 180++6671 AF                xor a
 180++6672 32 8C 73       ld (cursor_position), a
 181++6675 2A 8E 73         ld hl,(page_offset)
 182++6678 11 16 00         ld de,PER_PAGE
 183++667B 19               add hl,de
 184++667C 22 8E 73         ld (page_offset), hl
 185++667F C3 61 66         jp pageUp.exit
 186++6682
# file closed: gopher/render/gopher-page.asm
   8++6682                  include "plaintext.asm"
# file opened: gopher/render/plaintext.asm
   1++6682              renderPlainTextScreen:
   2++6682 3E FF            ld a, 255
   3++6684 32 8B 88         ld (oldminutes), a
   4++6687 CD BE 63         call prepareScreen
   5++668A
   6++668A 2A 8E 73         ld hl, (page_offset)        ; HL - offset to 0 Row on screen
   7++668D 44 4D            ld bc,hl                    ; BC - offset to C Row on screen
   8++668F CD 85 63         call Render.findLine        ;BC - Search this line  HL - Return pointer to page with offset
   9++6692 7C               ld a, h
  10++6693 B5               or l
  11++6694 28 30            jr z, .exit2
  12++6696 AF               xor a
  13++6697 C6 02            add CURSOR_OFFSET
  13++6699 57 1E 01       ld d, a, e, 1
  13++669C CD 88 61       call TextMode.gotoXY
  14++669F CD 7D 62         call print70Text
  15++66A2 06 15            ld b, PER_PAGE -1
  16++66A4              .loop
  17++66A4 C5               push bc
  18++66A5 3E 16            ld a, PER_PAGE
  19++66A7 90               sub b
  20++66A8 5F               ld e,a
  21++66A9 01 01 00         ld bc, 1
  22++66AC CD 88 63         call Render.findLine2   ;BC - Search this line  HL - Return pointer to page with offset
  23++66AF 7C               ld a, h
  24++66B0 B5               or l
  25++66B1 28 10            jr z, .exit
  26++66B3 7B               ld a, e
  27++66B4 C6 02            add CURSOR_OFFSET
  27++66B6 57 1E 01       ld d, a, e, 1
  27++66B9 CD 88 61       call TextMode.gotoXY
  28++66BC CD 7D 62         call print70Text
  29++66BF C1               pop bc
  30++66C0 10 E2            djnz .loop
  31++66C2 C9               ret
  32++66C3              .exit
  33++66C3 C1               pop bc
  34++66C4 10 DE            djnz .loop
  35++66C6              .exit2
  36++66C6 CD 1A 66         call showCursor
  37++66C9 C9               ret
  38++66CA              plainTextLoop:
  39++66CA CD 84 88         call printRTC
  40++66CD CD 55 68         call Console.getC
  41++66D0
  42++66D0 FE 31            cp '1'
  42++66D2 CA 00 70       jp z, History.back
  43++66D5 FE 32            cp '2'
  43++66D7 CA CF 65       jp z, navigate
  44++66DA FE 35            cp '5'
  44++66DC CA 42 67       jp z, textUp
  45++66DF FE 38            cp '8'
  45++66E1 CA 32 67       jp z, textDown
  46++66E4 FE 08            cp Console.KEY_LT
  46++66E6 CA 42 67       jp z, textUp
  47++66E9 FE 09            cp Console.KEY_RT
  47++66EB CA 32 67       jp z, textDown
  48++66EE
  49++66EE FE 0A            cp Console.KEY_DN
  49++66F0 CA 32 67       jp z, textDown
  50++66F3 FE 61            cp 'a'
  50++66F5 CA 32 67       jp z, textDown
  51++66F8
  52++66F8 FE 0B            cp Console.KEY_UP
  52++66FA CA 42 67       jp z, textUp
  53++66FD FE 71            cp 'q'
  53++66FF CA 42 67       jp z, textUp
  54++6702
  55++6702 FE 68            cp 'h'
  55++6704 CA 6D 70       jp z, History.home
  56++6707 FE 48            cp 'H'
  56++6709 CA 6D 70       jp z, History.home
  57++670C
  58++670C FE 62            cp 'b'
  58++670E CA 00 70       jp z, History.back
  59++6711 FE 42            cp 'B'
  59++6713 CA 00 70       jp z, History.back
  60++6716
  61++6716 FE 64            cp 'd'
  61++6718 CA D8 63       jp z, inputHost
  62++671B FE 44            cp 'D'
  62++671D CA D8 63       jp z, inputHost
  63++6720
  64++6720 FE 0C            cp Console.BACKSPACE
  64++6722 CA 00 70       jp z, History.back
  65++6725
  66++6725                  IFDEF MSX
  67++6725 ~                	cp ESC
  67++6725 ~              jp z, exit
  68++6725                  ENDIF
  69++6725
  70++6725                  IFDEF GS
  71++6725 ~                cp 'M'
  71++6725 ~              call z, GeneralSound.toggleModule
  72++6725 ~                cp 'm'
  72++6725 ~              call z, GeneralSound.toggleModule
  73++6725                  ENDIF
  74++6725
  75++6725                  IFDEF TIMEX80
  76++6725 FE 54            cp 'T'
  76++6727 CC A5 61       call z, TextMode.toggleColor
  77++672A FE 74            cp 't'
  77++672C CC A5 61       call z, TextMode.toggleColor
  78++672F                  ENDIF
  79++672F
  80++672F C3 CA 66         jp plainTextLoop
  81++6732
  82++6732
  83++6732              textDown:
  84++6732 2A 8E 73         ld hl,(page_offset)
  85++6735 11 16 00         ld de,PER_PAGE
  86++6738 19               add hl,de
  87++6739 22 8E 73         ld (page_offset), hl
  88++673C CD 82 66         call renderPlainTextScreen
  89++673F C3 CA 66         jp plainTextLoop
  90++6742
  91++6742              textUp:
  92++6742 3A 8E 73         ld a, (page_offset)
  92++6745 FE 00          cp 0
  92++6747 20 0A          jr nz, .textUp2
  93++6749 3A 8F 73         ld a, (page_offset + 1)
  93++674C FE 00          cp 0
  93++674E 20 03          jr nz, .textUp2
  94++6750 C3 CA 66         jp plainTextLoop
  95++6753
  96++6753              .textUp2:
  97++6753 2A 8E 73         ld hl,(page_offset)
  98++6756 11 16 00         ld de,PER_PAGE
  99++6759 ED 52            sbc hl,de
 100++675B 22 8E 73         ld (page_offset), hl
 101++675E CD 82 66         call renderPlainTextScreen
 102++6761 C3 CA 66         jp plainTextLoop
 103++6764
# file closed: gopher/render/plaintext.asm
   9++6764
  10++6764 00           play_next       db  0
  11++6765              position        EQU historyBlock.position
  12++6765              cursor_position EQU position + 2
  13++6765              page_offset     EQU position + 4
  14++6765
  15++6765                  ENDMODULE
  16++6765
  17++6765                  include "dialogbox.asm"
# file opened: gopher/render/dialogbox.asm
   1++6765                  module DialogBox
   2++6765
   3++6765              inputBox:
   4++6765 AF               xor a
   4++6766 32 C0 67       ld (inputBuffer), a
   5++6769              .noclear
   6++6769 CD 21 68         call drawBox
   7++676C              .loop
   8++676C 11 05 0B         ld de, #0B05
   8++676F CD 88 61       call TextMode.gotoXY
   9++6772 21 C0 67         ld hl, inputBuffer
   9++6775 CD 83 60       call TextMode.printZ
  10++6778 3E B3            ld a, MIME_INPUT
  10++677A CD 8E 60       call TextMode.putC
  10++677D 3E 20          ld a, ' '
  10++677F CD 8E 60       call TextMode.putC
  11++6782              .checkkey
  12++6782 CD 55 68         call Console.getC
  13++6785 FE 0C            cp Console.BACKSPACE
  13++6787 28 16          jr z, .removeChar
  14++6789 FE 0D        	cp CR
  14++678B C8             ret z
  15++678C FE 20            cp SPACE
  15++678E 38 F2          jr c, .checkkey
  16++6790              .putC
  17++6790 5F               ld e, a
  18++6791 AF               xor a
  18++6792 21 C0 67 01    ld hl, inputBuffer, bc, #ff
  18++6796 FF 00
  18++6798 ED B1          cpir
  19++679A 77               ld (hl), a
  19++679B 2B             dec hl
  19++679C 73             ld (hl), e
  20++679D 18 CD            jr .loop
  21++679F              .removeChar
  22++679F AF               xor a
  23++67A0 21 C0 67 01      ld hl, inputBuffer, bc, #ff
  23++67A4 FF 00
  23++67A6 ED B1          cpir
  24++67A8 E5               push hl
  25++67A9 11 C1 67             ld de, inputBuffer + 1
  26++67AC B7                   or a
  26++67AD ED 52          sbc hl, de
  27++67AF 7C                   ld a, h
  27++67B0 B5             or l
  28++67B1 E1               pop hl
  29++67B2 28 B8            jr z, .loop
  30++67B4 AF               xor a
  31++67B5 2B               dec hl
  31++67B6 2B             dec hl
  31++67B7 77             ld (hl), a
  32++67B8 18 B2            jr .loop
  33++67BA
  34++67BA              	IFNDEF MSX
  35++67BA              delayinput:
  36++67BA 06 32           ld b, 50
  37++67BC              .loop2
  38++67BC 76               halt
  39++67BD 10 FD            djnz .loop2
  40++67BF C9               ret
  41++67C0              namedownload
  42++67C0                  IFDEF NEDOOS
  43++67C0 ~            		db "..",92,"downloads",92
  44++67C0                  ENDIF
  45++67C0                  ENDIF
  46++67C0 00 00 00...  inputBuffer ds 80
  47++6810
  48++6810              msgBox:
  49++6810 CD 19 68         call msgNoWait
  50++6813 06 96            ld b, 150
  51++6815              .loop
  52++6815 76               halt
  53++6816 10 FD            djnz .loop
  54++6818 C9               ret
  55++6819
  56++6819              msgNoWait:
  57++6819 E5               push hl
  58++681A CD 21 68         call drawBox
  59++681D E1               pop hl
  60++681E C3 83 60         jp TextMode.printZ
  61++6821
  62++6821              drawBox:
  63++6821 26 0A 3E B2      ld h, #0a, a, BORDER_TOP
  64++6825 CD 76 61         call TextMode.fillLine
  65++6828 26 0B 3E 20      ld h, #0b, a, ' '
  66++682C CD 76 61         call TextMode.fillLine
  67++682F 26 0C 3E B1      ld h, #0c, a, BORDER_BOTTOM
  68++6833 CD 76 61         call TextMode.fillLine
  69++6836 3E 0A            ld a, #0a
  70++6838 CD 61 60         call TextMode.highlightLine
  71++683B 3E 0C            ld a, #0c
  72++683D CD 61 60         call TextMode.highlightLine
  73++6840 11 03 0B         ld de,#0B03
  74++6843 CD 88 61         call TextMode.gotoXY
  75++6846 C9               ret
  76++6847                  endmodule
  77++6847
# file closed: gopher/render/dialogbox.asm
# file closed: gopher/render/index.asm
  18+ 6847                  include "dos/index.asm"
# file opened: dos/index.asm
   1++6847              	IFDEF NEDOOS
   2++6847 ~            	    include "nedoconsole.asm"
   3++6847 ~            		include "nedoos.asm"
   4++6847              	ENDIF
   5++6847
   6++6847              	IFDEF TRDOS
   7++6847                  	include "console.asm"
# file opened: dos/console.asm
   1++6847                  module Console
   2++6847              KEY_UP = 11
   3++6847              KEY_DN = 10
   4++6847              KEY_LT = 8
   5++6847              KEY_RT = 9
   6++6847              BACKSPACE = 12
   7++6847 00           keyCode db 0
   8++6848
   9++6848              BASIC_KEY = #5C08
  10++6848
  11++6848              waitForKeyUp:
  12++6848 76           	halt
  13++6849 AF              xor a
  13++684A DB FE          in a, (#fe)
  13++684C 2F             cpl
  13++684D E6 1F          and 31
  13++684F 20 F7          jr nz, waitForKeyUp
  14++6851 32 08 5C        ld (BASIC_KEY), a
  15++6854 C9              ret
  16++6855
  17++6855              getC:
  18++6855 AF              xor a
  19++6856 32 08 5C        ld (BASIC_KEY),a
  20++6859              getC2:
  21++6859 3A 08 5C        ld a,(BASIC_KEY)
  22++685C A7              and a
  22++685D 28 FA          jr z, getC2
  23++685F 47              ld b,a
  24++6860 AF              xor a
  24++6861 32 08 5C       ld (BASIC_KEY), a
  25++6864 78              ld a, b
  26++6865 C9              ret
  27++6866
  28++6866              peekC:
  29++6866 AF               xor a
  29++6867 32 08 5C       ld (BASIC_KEY),a
  30++686A CD 6E 68         call inkey
  31++686D C9               ret
  32++686E
  33++686E              inkey:
  34++686E 11 00 00        ld de,0
  35++6871 01 FE FE        ld bc,$fefe
  36++6874 ED 78           in a,(c)
  37++6876 F6 E1           or $e1
  38++6878 FE FF           cp $ff
  39++687A 20 57           jr nz, .keyhitA
  40++687C
  41++687C 1E 05           ld e,5
  42++687E 06 FD           ld b,$fd
  43++6880 ED 78           in a,(c)
  44++6882 F6 E0           or $e0
  45++6884 FE FF           cp $ff
  46++6886 20 4B           jr nz, .keyhitA
  47++6888
  48++6888 1E 0A           ld e,10
  49++688A 06 FB           ld b,$fb
  50++688C ED 78           in a,(c)
  51++688E F6 E0           or $e0
  52++6890 FE FF           cp $ff
  53++6892 20 3F           jr nz, .keyhitA
  54++6894
  55++6894 1E 0F           ld e,15
  56++6896 06 F7           ld b,$f7
  57++6898 ED 78           in a,(c)
  58++689A F6 E0           or $e0
  59++689C FE FF           cp $ff
  60++689E 20 33           jr nz, .keyhitA
  61++68A0
  62++68A0 1E 14           ld e,20
  63++68A2 06 EF           ld b,$ef
  64++68A4 ED 78           in a,(c)
  65++68A6 F6 E0           or $e0
  66++68A8 FE FF           cp $ff
  67++68AA 20 27           jr nz, .keyhitA
  68++68AC
  69++68AC 1E 19           ld e,25
  70++68AE 06 DF           ld b,$df
  71++68B0 ED 78           in a,(c)
  72++68B2 F6 E0           or $e0
  73++68B4 FE FF           cp $ff
  74++68B6 20 1B           jr nz, .keyhitA
  75++68B8
  76++68B8 1E 1E           ld e,30
  77++68BA 06 BF           ld b,$bf
  78++68BC ED 78           in a,(c)
  79++68BE F6 E0           or $e0
  80++68C0 FE FF           cp $ff
  81++68C2 20 0F           jr nz, .keyhitA
  82++68C4
  83++68C4 1E 23           ld e,35
  84++68C6 06 7F           ld b,$7f
  85++68C8 ED 78           in a,(c)
  86++68CA F6 E2           or $e2
  87++68CC FE FF           cp $ff
  88++68CE 4F              ld c,a
  89++68CF 20 19           jr nz, .keyhitB
  90++68D1
  91++68D1              .nokey
  92++68D1 AF              xor a
  93++68D2 C9              ret
  94++68D3
  95++68D3              .keyhitA
  96++68D3
  97++68D3 4F              ld c,a
  98++68D4
  99++68D4 78              ld a,b
 100++68D5 2F              cpl
 101++68D6 F6 81           or $81
 102++68D8 DB FE           in a,($fe)
 103++68DA F6 E0           or $e0
 104++68DC FE FF           cp $ff
 105++68DE 20 F1           jr nz, .nokey
 106++68E0
 107++68E0 3E 7F           ld a,$7f
 108++68E2 DB FE           in a,($fe)
 109++68E4 F6 E2           or $e2
 110++68E6 FE FF           cp $ff
 111++68E8 20 E7           jr nz, .nokey
 112++68EA
 113++68EA              .keyhitB
 114++68EA
 115++68EA 06 00           ld b,0
 116++68EC 21 33 68        ld hl,.rowtbl-$e0
 117++68EF 09              add hl,bc
 118++68F0 7E              ld a,(hl)
 119++68F1 FE 05           cp 5
 120++68F3 30 DC           jr nc, .nokey
 121++68F5 83              add a,e
 122++68F6 5F              ld e,a
 123++68F7
 124++68F7 21 33 69        ld hl,.table
 125++68FA 19              add hl,de
 126++68FB
 127++68FB 3E FE           ld a,$fe
 128++68FD DB FE           in a,($fe)
 129++68FF E6 01           and $01
 130++6901 20 03           jr nz, .nocaps
 131++6903 1E 28           ld e,40
 132++6905 19              add hl,de
 133++6906
 134++6906              .nocaps
 135++6906
 136++6906 3E 7F           ld a,$7f
 137++6908 DB FE           in a,($fe)
 138++690A E6 02           and $02
 139++690C 20 03           jr nz, .nosym
 140++690E 1E 50           ld e,80
 141++6910 19              add hl,de
 142++6911
 143++6911              .nosym
 144++6911
 145++6911 7E              ld a,(hl)
 146++6912 C9              ret
 147++6913
 148++6913              .rowtbl
 149++6913 FF FF FF FF     defb 255,255,255,255,255,255,255
 149++6917 FF FF FF
 150++691A FF FF FF FF     defb 255,255,255,255,255,255,255,255
 150++691E FF FF FF FF
 151++6922 04 FF FF FF     defb 4,255,255,255,255,255,255
 151++6926 FF FF FF
 152++6929 FF 03 FF FF     defb 255,3,255,255,255,2,255,1
 152++692D FF 02 FF 01
 153++6931 00 FF           defb 0,255
 154++6933
 155++6933              .table
 156++6933 00 7A 78 63     db 0,'z','x','c','v'      ; CAPS SHIFT, Z, X, C, V
 156++6937 76
 157++6938 61 73 64 66     db 'a','s','d','f','g'      ; A, S, D, F, G
 157++693C 67
 158++693D 71 77 65 72     db 'q','w','e','r','t'      ; Q, W, E, R, T
 158++6941 74
 159++6942 31 32 33 34     db '1','2','3','4','5'      ; 1, 2, 3, 4, 5
 159++6946 35
 160++6947 30 39 38 37     db '0','9','8','7','6'      ; 0, 9, 8, 7, 6
 160++694B 36
 161++694C 70 6F 69 75     db 'p','o','i','u','y'      ; P, O, I, U, Y
 161++6950 79
 162++6951 0D 6C 6B 6A     db 13,'l','k','j','h'       ; ENTER, L, K, J, H
 162++6955 68
 163++6956 20 00 6D 6E     db ' ',0,'m','n','b'      ; SPACE, SYM SHIFT, M, N, B
 163++695A 62
 164++695B
 165++695B                 ; the following are CAPS SHIFTed
 166++695B
 167++695B 00 5A 58 43     db 0,'Z','X','C','V'      ; CAPS SHIFT, Z, X, C, V
 167++695F 56
 168++6960 41 53 44 46     db 'A','S','D','F','G'      ; A, S, D, F, G
 168++6964 47
 169++6965 51 57 45 52     db 'Q','W','E','R','T'      ; Q, W, E, R, T
 169++6969 54
 170++696A 07 06 80 81     db 7,6,128,129,8            ; 1, 2, 3, 4, 5
 170++696E 08
 171++696F 0C 00 09 0B     db 12,0,9,11,10             ; 0, 9, 8, 7, 6
 171++6973 0A
 172++6974 50 4F 49 55     db 'P','O','I','U','Y'      ; P, O, I, U, Y
 172++6978 59
 173++6979 0D 4C 4B 4A     db 13,'L','K','J','H'       ; ENTER, L, K, J, H
 173++697D 48
 174++697E 20 00 4D 4E     db ' ',0,'M','N','B'      ; SPACE, SYM SHIFT, M, N, B
 174++6982 42
 175++6983
 176++6983                 ; the following are SYM SHIFTed
 177++6983
 178++6983 00 3A 60 3F     db 0,':',96,'?','/'       ; CAPS SHIFT, Z, X, C, V
 178++6987 2F
 179++6988 7E 7C 5C 7B     db '~','|',92,'{','}'       ; A, S, D, F, G
 179++698C 7D
 180++698D 83 84 85 3C     db 131,132,133,'<','>'      ; Q, W, E, R, T
 180++6991 3E
 181++6992 21 40 23 24     db '!','@','#','$','%'      ; 1, 2, 3, 4, 5
 181++6996 25
 182++6997 5F 29 28 27     db '_',')','(',39,'&'       ; 0, 9, 8, 7, 6
 182++699B 26
 183++699C 22 3B 82 5D     db 34,';',130,']','['       ; P, O, I, U, Y
 183++69A0 5B
 184++69A1 0D 3D 2B 2D     db 13,'=','+','-','^'       ; ENTER, L, K, J, H
 184++69A5 5E
 185++69A6 20 00 2E 2C     db ' ',0,'.',',','*'      ; SPACE, SYM SHIFT, M, N, B
 185++69AA 2A
 186++69AB
 187++69AB                 ; the following are CAPS SHIFTed and SYM SHIFTed ("CTRL" key)
 188++69AB
 189++69AB 00 1A 18 03     db 0,26,24,3,22           ; CAPS SHIFT, Z, X, C, V
 189++69AF 16
 190++69B0 01 13 04 06     db 1,19,4,6,7               ; A, S, D, F, G
 190++69B4 07
 191++69B5 11 17 05 12     db 17,23,5,18,20            ; Q, W, E, R, T
 191++69B9 14
 192++69BA 1B 1C 1D 1E     db 27,28,29,30,31           ; 1, 2, 3, 4, 5
 192++69BE 1F
 193++69BF 7F 00 86 60     db 127,0,134,'`',135      ; 0, 9, 8, 7, 6
 193++69C3 87
 194++69C4 10 0F 09 15     db 16,15,9,21,25            ; P, O, I, U, Y
 194++69C8 19
 195++69C9 0D 0C 0B 0A     db 13,12,11,10,8            ; ENTER, L, K, J, H
 195++69CD 08
 196++69CE 20 00 0D 0E     db ' ',0,13,14,2          ; SPACE, SYM SHIFT, M, N, B
 196++69D2 02
 197++69D3
 198++69D3                  endmodule
# file closed: dos/console.asm
   8++69D3              		include "trdos.asm"
# file opened: dos/trdos.asm
   1++69D3              ;trdos driver (izzx)
   2++69D3                  MODULE Dos
   3++69D3              ; API methods
   4++69D3              ESX_GETSETDRV = #89
   5++69D3              ESX_FOPEN = #9A
   6++69D3              ESX_FCLOSE = #9B
   7++69D3              ESX_FSYNC = #9C
   8++69D3              ESX_FREAD = #9D
   9++69D3              ESX_FWRITE = #9E
  10++69D3
  11++69D3              ; File modes
  12++69D3              FMODE_READ = #01
  13++69D3              FMODE_WRITE = #06
  14++69D3              FMODE_CREATE = #0E
  15++69D3
  16++69D3                  ; MACRO esxCall func
  17++69D3                  ; rst #8 : db func
  18++69D3                  ; ENDM
  19++69D3
  20++69D3              ;id = 0 файл не открыт
  21++69D3              ;id = 1 файл для чтения
  22++69D3              ;id = 2 файл для записи
  23++69D3              ;id = 3 файл для записи тип TRD
  24++69D3              ;id = 4 файл для записи тип SCL
  25++69D3
  26++69D3              ; HL - filename in ASCIIZ
  27++69D3              loadBuffer:
  28++69D3 06 01            ld b, Dos.FMODE_READ
  28++69D5 CD EF 69       call Dos.fopen
  29++69D8 F5               push af
  30++69D9 21 FF 94 01          ld hl, outputBuffer, bc, #ffff - outputBuffer
  30++69DD 00 6B
  30++69DF CD DC 6A       call Dos.fread
  31++69E2 21 FF 94             ld hl, outputBuffer
  31++69E5 09             add hl, bc
  31++69E6 AF             xor a
  31++69E7 77             ld (hl), a
  31++69E8 23             inc hl
  31++69E9 77             ld (hl), a
  32++69EA F1               pop af
  33++69EB CD C8 6A         call Dos.fclose
  34++69EE C9               ret
  35++69EF
  36++69EF
  37++69EF              ; Returns:
  38++69EF              ;  A - current drive
  39++69EF              ; getDefaultDrive: ;нигде не используется
  40++69EF                  ; ld a, 0 : esxCall ESX_GETSETDRV
  41++69EF                  ; ret
  42++69EF
  43++69EF
  44++69EF
  45++69EF              ; Opens file on default drive
  46++69EF              ; B - File mode
  47++69EF              ; HL - File name
  48++69EF              ; Returns:
  49++69EF              ;  A - file stream id
  50++69EF              fopen:
  51++69EF                  ; push bc : push hl
  52++69EF                  ; call getDefaultDrive
  53++69EF                  ; pop ix : pop bc
  54++69EF                  ; esxCall ESX_FOPEN
  55++69EF                  ; ret
  56++69EF 78           	ld a,b
  57++69F0 FE 01        	cp FMODE_READ ;если режим открытие файла
  58++69F2 28 06        	jr z,fopen_r
  59++69F4 FE 0E        	cp FMODE_CREATE
  60++69F6 28 39        	jr z,fopen_c ;если режим создание файла
  61++69F8 18 34        	jr fopen_err ;иначе выход
  62++69FA
  63++69FA              fopen_r	;открытие существующего файла на чтение (id=1)
  64++69FA CD 5F 6E     			call format_name ;
  65++69FD 0E 13        			ld      c,#13 ;move file info to syst var
  66++69FF CD 13 3D                 call    #3d13
  67++6A02 0E 0A                    ld      c,#0a ;find file
  68++6A04 CD 13 3D                 call    #3d13
  69++6A07 79                       ld      a,c
  70++6A08 FE FF        			cp 		#ff
  71++6A0A 28 22        			jr 		z,fopen_err ;если не нашли файла
  72++6A0C 0E 08                    ld      c,#08 ;read file title
  73++6A0E CD 13 3D                 call    #3d13
  74++6A11                          ;ld      hl,loadadr ;куда
  75++6A11 ED 5B EB 5C              ld      de,(#5ceb) ;начало файла сектор дорожка
  76++6A15 ED 53 0B 6F              ld      (f_r_cur_trk),de
  77++6A19
  78++6A19 3A EA 5C                 ld      a,(#5cea)
  79++6A1C 32 0D 6F                 ld      (f_r_len_sec),a ;длина в секторах
  80++6A1F                          ;or      a
  81++6A1F                          ;ret     z    ;выход если пустой
  82++6A1F
  83++6A1F ED 5B E8 5C  			ld de,(#5CE8) ; длина файла или программной части для BASIC
  84++6A23 ED 53 0E 6F  			ld      (f_r_len),de
  85++6A27
  86++6A27                          ; ld      de,(fcurtrk) ;текущие сектор дорожка
  87++6A27                          ; ld      (#5cf4),de ;восстановим
  88++6A27 AF           			xor a
  89++6A28 3E 01        			ld 		a,1
  90++6A2A 32 10 6F     			ld (f_r_flag),a ;флаг что файл для чтения открыт
  91++6A2D              			;id канала будет 1
  92++6A2D C9           	ret
  93++6A2E
  94++6A2E              fopen_err
  95++6A2E AF           	xor a ;если никакой файл не открыли, то id = 0
  96++6A2F 37           	scf ;флаг ошибки
  97++6A30 C9           	ret
  98++6A31
  99++6A31
 100++6A31              fopen_c	;создание нового файла (id=2-4)
 101++6A31 CD 5F 6E     	call format_name ;
 102++6A34              	;выясним, не образ ли это для разворачивания
 103++6A34 21 EE 6E         ld hl, trdExt1
 103++6A37 CD 27 62       call CompareBuff.search
 103++6A3A A7             and a
 103++6A3B 20 1D          jr nz, fopen_c_trd
 104++6A3D 21 F3 6E         ld hl, trdExt2
 104++6A40 CD 27 62       call CompareBuff.search
 104++6A43 A7             and a
 104++6A44 20 14          jr nz, fopen_c_trd
 105++6A46 21 F8 6E     	ld hl, sclExt1
 105++6A49 CD 27 62       call CompareBuff.search
 105++6A4C A7             and a
 105++6A4D 20 3A          jr nz, fopen_c_scl
 106++6A4F 21 FD 6E         ld hl, sclExt2
 106++6A52 CD 27 62       call CompareBuff.search
 106++6A55 A7             and a
 106++6A56 20 31          jr nz, fopen_c_scl
 107++6A58
 108++6A58
 109++6A58              fopen_c_2	;создание произвольного файла
 110++6A58 18 D4        	jr 		fopen_err ;пока отключено
 111++6A5A
 112++6A5A              	; ld      c,#13 ;move file info to syst var
 113++6A5A                  ; call    #3d13
 114++6A5A              	; ld de,256 ;запишем пока 1 сектор
 115++6A5A              	; ld hl,#4000 ;возьмём случайные данные из экрана
 116++6A5A                  ; ld      c,#0b ;запись файла CODE
 117++6A5A                  ; call    #3d13
 118++6A5A                  ; ld      a,c
 119++6A5A              	; cp 		#ff
 120++6A5A              	; jr 		z,fopen_err ;если ошибка
 121++6A5A
 122++6A5A                  ; ld      de,(#5ceb) ;начало файла сектор дорожка
 123++6A5A                  ; ld      (f_w_cur_trk),de
 124++6A5A                  ; ld      a,(#5cea)
 125++6A5A                  ; ld      (f_w_len_sec),a ;длина в секторах
 126++6A5A              	; xor a ;id канала будет 2
 127++6A5A              	; ld a,2
 128++6A5A              	; ld (f_w_flag),a ;флаг что файл для записи открыт
 129++6A5A              	; ret
 130++6A5A
 131++6A5A
 132++6A5A
 133++6A5A
 134++6A5A
 135++6A5A              fopen_c_trd	;открытие файла для разворачивания образа trd (id=3)
 136++6A5A 3A 19 5D     	ld a,(#5D19) ;номер дисковода по умолчанию
 137++6A5D C6 41        	add a,"A"
 138++6A5F 32 D4 6E     	ld (write_ima_d),a ;подставим букву в запросе
 139++6A62 21 BF 6E         ld hl, write_ima
 140++6A65 CD 10 68         call DialogBox.msgBox ;предуреждение
 141++6A68              WAITKEY_trd
 142++6A68 3A 04 5C     	ld 		a,(23556)
 143++6A6B FE FF        	cp 255
 144++6A6D 28 F9        	JR Z,WAITKEY_trd	;ждём любую клавишу
 145++6A6F
 146++6A6F 11 00 00     	ld      de,0 ;начало сектор дорожка
 147++6A72 ED 53 F4 5C      ld      (#5cf4),de
 148++6A76 AF           	xor a
 149++6A77 32 20 6F     	ld (sec_shift),a ;переменная
 150++6A7A 21 00 00     	ld hl,0
 151++6A7D 22 15 6F     	ld (f_w_len+0),hl
 152++6A80 22 17 6F     	ld (f_w_len+2),hl
 153++6A83 3E 03        	ld a,3 ;id канала
 154++6A85 32 14 6F     	ld (f_w_flag),a ;флаг что trd для записи открыт
 155++6A88 C9           	ret
 156++6A89
 157++6A89
 158++6A89
 159++6A89
 160++6A89              fopen_c_scl	;открытие файла для разворачивания образа scl (id=4)
 161++6A89 3A 19 5D     	ld a,(#5D19) ;номер дисковода по умолчанию
 162++6A8C C6 41        	add a,"A"
 163++6A8E 32 D4 6E     	ld (write_ima_d),a ;подставим букву в запросе
 164++6A91 21 BF 6E         ld hl, write_ima
 165++6A94 CD 10 68         call DialogBox.msgBox ;предуреждение
 166++6A97              WAITKEY_scl
 167++6A97 3A 04 5C     	ld 		a,(23556)
 168++6A9A FE FF        	cp 255
 169++6A9C 28 F9        	JR Z,WAITKEY_scl	;ждём любую клавишу
 170++6A9E
 171++6A9E 11 00 00     	ld      de,0 ;начало сектор дорожка
 172++6AA1 ED 53 F4 5C      ld      (#5cf4),de
 173++6AA5
 174++6AA5 21 00 48     	ld hl,cat_buf ;очистить место для каталога дискеты
 175++6AA8 11 01 48     	ld de,cat_buf+1
 176++6AAB 36 00        	ld (hl),0
 177++6AAD 01 FF 08     	ld bc,9*256-1
 178++6AB0 ED B0        	ldir
 179++6AB2
 180++6AB2 CD D4 6C     	call scl_parse ;запуск цикла сборки образа
 181++6AB5
 182++6AB5 AF           	xor a
 183++6AB6 32 20 6F     	ld (sec_shift),a ;переменная
 184++6AB9              	;ld (scl_que),a
 185++6AB9 21 00 00     	ld hl,0
 186++6ABC 22 15 6F     	ld (f_w_len+0),hl
 187++6ABF 22 17 6F     	ld (f_w_len+2),hl
 188++6AC2 3E 04        	ld a,4 ;id канала
 189++6AC4 32 14 6F     	ld (f_w_flag),a ;флаг что scl для записи открыт
 190++6AC7 C9           	ret
 191++6AC8
 192++6AC8
 193++6AC8
 194++6AC8              ; A - file stream id
 195++6AC8              fclose:
 196++6AC8                  ;esxCall ESX_FCLOSE
 197++6AC8              	; push af
 198++6AC8              ; WAITKEY2	XOR A:IN A,(#FE):CPL:AND #1F:JR Z,WAITKEY2
 199++6AC8              	; pop af
 200++6AC8 FE 04        	cp 4 ;если scl
 201++6ACA 20 08        	jr nz,fclose2
 202++6ACC 21 00 51     	ld hl,sec_buf ;
 203++6ACF 06 01        	ld b,1
 204++6AD1 CD B3 6C     	call scl_write_buf ;допишем остаток scl, если есть
 205++6AD4
 206++6AD4              fclose2
 207++6AD4 AF           	xor a ;как бы закрываем все файлы
 208++6AD5 32 10 6F     	ld (f_r_flag),a
 209++6AD8 32 14 6F     	ld (f_w_flag),a
 210++6ADB C9               ret
 211++6ADC
 212++6ADC
 213++6ADC
 214++6ADC
 215++6ADC              ; A - file stream id
 216++6ADC              ; BC - length
 217++6ADC              ; HL - buffer
 218++6ADC              ; Returns
 219++6ADC              ;  BC - length(how much was actually read)
 220++6ADC              fread: ;(id=1)
 221++6ADC                  ; push hl : pop ix
 222++6ADC                  ; esxCall ESX_FREAD
 223++6ADC              	; push af
 224++6ADC              	; ld a,4
 225++6ADC              	; out (254),a
 226++6ADC              ; WAITKEY	XOR A:IN A,(#FE):CPL:AND #1F:JR Z,WAITKEY
 227++6ADC              	; xor a
 228++6ADC              	; out (254),a
 229++6ADC              	; pop af
 230++6ADC
 231++6ADC FE 01        	cp 1 ;id = 1?
 232++6ADE 20 06        	jr nz,fread_no_chek ;выход если номер потока не = 1
 233++6AE0 3A 10 6F     	ld a,(f_r_flag)
 234++6AE3 B7           	or a
 235++6AE4 20 06        	jr nz,fread_chek ;файл уже открыт?
 236++6AE6              fread_no_chek ;выход с ошибкой
 237++6AE6 AF           	xor a
 238++6AE7 37           	scf ;флаг ошибки
 239++6AE8 01 00 00     	ld bc,0 ;ничего мы не считали
 240++6AEB C9           	ret
 241++6AEC
 242++6AEC              fread_chek
 243++6AEC ED 4B 0C 6F  	ld bc,(f_r_len_sec-1) ;загружаем файл целиком, не смотря на то, сколько байт было запрошено
 244++6AF0 0E 05            ld      c,5 ;read читаем целыми секторами
 245++6AF2 ED 5B 0B 6F  	ld de,(f_r_cur_trk)
 246++6AF6 CD 13 3D         call    #3d13
 247++6AF9 ED 4B 0E 6F  	ld bc,(f_r_len) ;возвратим сколько считали байт (длину файла)
 248++6AFD AF           	xor a ;флаги сбросим
 249++6AFE C9               ret
 250++6AFF
 251++6AFF              ; A - file stream id
 252++6AFF              ; BC - length
 253++6AFF              ; HL - buffer
 254++6AFF              ; Returns:
 255++6AFF              ;   BC - actually written bytes
 256++6AFF              fwrite: ;
 257++6AFF                  ; push hl : pop ix
 258++6AFF                  ; esxCall ESX_FWRITE
 259++6AFF
 260++6AFF              	; push af
 261++6AFF              	; ld a,2
 262++6AFF              	; out (254),a
 263++6AFF              ; WAITKEY1	XOR A:IN A,(#FE):CPL:AND #1F:JR Z,WAITKEY1
 264++6AFF              	; xor a
 265++6AFF              	; out (254),a
 266++6AFF              	; pop af
 267++6AFF
 268++6AFF FE 02        	cp 2 ;id = 2?
 269++6B01 28 0F        	jr z,fwrite_chek ;проверка id потока
 270++6B03 FE 03        	cp 3 ;id = 3?
 271++6B05 28 0D        	jr z,fwrite_chek_trd ;проверка id потока
 272++6B07 FE 04        	cp 4 ;id = 4?
 273++6B09 CA EE 6B     	jp z,fwrite_chek_scl ;проверка id потока
 274++6B0C
 275++6B0C
 276++6B0C              fwrite_no_chek ;выход с ошибкой
 277++6B0C AF           	xor a
 278++6B0D 37           	scf ;флаг ошибки
 279++6B0E 01 00 00     	ld bc,0 ;ничего мы не записали
 280++6B11 C9           	ret
 281++6B12
 282++6B12              fwrite_chek ;запись произвольного типа файла
 283++6B12 18 F8        	jr fwrite_no_chek ;пока отключено
 284++6B14              	; ld a,(f_w_flag)
 285++6B14              	; or a
 286++6B14              	; jr z,fwrite_no_chek ;файл уже открыт?
 287++6B14              	; ld (temp_bc),bc
 288++6B14              	; ;ld bc,(f_r_len_sec-1) ;
 289++6B14                  ; ld      c,6 ;пишем целыми секторами
 290++6B14              	; ld de,(f_w_cur_trk)
 291++6B14                  ; call    #3d13
 292++6B14              	; ld bc,(temp_bc) ;возвратим, что сколько запрашивали, столько и считали байт
 293++6B14              	; xor a ;флаги сбросим
 294++6B14                  ; ret
 295++6B14
 296++6B14
 297++6B14
 298++6B14
 299++6B14
 300++6B14              fwrite_chek_trd ;запись trd файла (разворачивание образа)
 301++6B14              	; ld a,2
 302++6B14              	; out (254),a
 303++6B14              ; WAITKEY_t	XOR A:IN A,(#FE):CPL:AND #1F:JR Z,WAITKEY_t
 304++6B14              	; xor a
 305++6B14              	; out (254),a
 306++6B14 3A 14 6F     	ld a,(f_w_flag)
 307++6B17 B7           	or a
 308++6B18 28 F2        	jr z,fwrite_no_chek ;файл уже открыт?
 309++6B1A ED 43 1A 6F  	ld (temp_bc),bc ;длина
 310++6B1E 22 1C 6F     	ld (temp_hl),hl ;адрес данных
 311++6B21 78           	ld a,b
 312++6B22 B1           	or c
 313++6B23 28 E7        	jr z,fwrite_no_chek ; если длина 0, то выход
 314++6B25
 315++6B25              	; ld a,b
 316++6B25              	; or a
 317++6B25              	; jr nz,testt1
 318++6B25              	; nop
 319++6B25
 320++6B25              ; testt1
 321++6B25
 322++6B25 AF           	xor a
 323++6B26 32 22 6F     	ld (sec_part),a ;обнулить переменные
 324++6B29 32 21 6F     	ld (sec_shift2),a
 325++6B2C 32 22 6F     	ld (sec_shift2+1),a
 326++6B2F 32 23 6F     	ld (sec_shift_flag),a
 327++6B32 32 19 6F     	ld (write_end_flag),a ;
 328++6B35
 329++6B35
 330++6B35 3A 20 6F     	ld a,(sec_shift)
 331++6B38 B7           	or a
 332++6B39 28 43        	jr z,fwrite_trd3 ;если смещения нет, то первую часть пропустим
 333++6B3B
 334++6B3B
 335++6B3B 4F           	ld c,a
 336++6B3C 06 00        	ld b,0
 337++6B3E 2A 1A 6F     	ld hl,(temp_bc) ;проверка заполнится ли целый сектор
 338++6B41 09           	add hl,bc
 339++6B42
 340++6B42 3E 01        	ld a,1
 341++6B44 32 19 6F     	ld (write_end_flag),a ;флаг что не нужно дописывать остаток
 342++6B47
 343++6B47 7C           	ld a,h
 344++6B48 B7           	or a
 345++6B49 20 05        	jr nz,fwrite_trd4
 346++6B4B 3E 01        	ld a,1
 347++6B4D 32 23 6F     	ld (sec_shift_flag),a ;флаг что не заполнен сектор
 348++6B50
 349++6B50              fwrite_trd4
 350++6B50 21 00 51     	ld hl,sec_buf ;буфер последнего сектора
 351++6B53 09           	add hl,bc ;на этой точке остановились
 352++6B54 EB           	ex de,hl
 353++6B55 2A 1C 6F     	ld hl,(temp_hl) ;присоединим начало данных в конец предыдущих
 354++6B58              	; ld a,c
 355++6B58              	; or a
 356++6B58              	; jr nz,fwrite_trd2
 357++6B58              	; inc b ;коррекция
 358++6B58              ; fwrite_trd2
 359++6B58              	; ld c,a
 360++6B58 AF           	xor a
 361++6B59 91           	sub c
 362++6B5A 4F           	ld c,a ;сколько осталось перенести до заполнения сектора
 363++6B5B ED 43 21 6F  	ld (sec_shift2),bc ;сохраним сколько добавили байт
 364++6B5F ED B0        	ldir
 365++6B61
 366++6B61 3A 23 6F     	ld a,(sec_shift_flag)
 367++6B64 B7           	or a
 368++6B65 20 17        	jr nz,fwrite_trd3 ;если сектор ещё не заполнен писать не будем
 369++6B67
 370++6B67 21 00 51     	ld hl,sec_buf
 371++6B6A ED 5B F4 5C  	ld de,(#5cf4)
 372++6B6E              	;ld (f_w_cur_trk),de	;запомним позицию
 373++6B6E 01 06 01         ld      bc,#0106 ;пишем 1 сектор из буфера
 374++6B71 CD 13 3D         call    #3d13
 375++6B74 79           	ld a,c
 376++6B75 FE FF        	cp 255
 377++6B77 CA 0C 6B     	jp z,fwrite_no_chek ;выход если ошибка
 378++6B7A
 379++6B7A AF           	xor a
 380++6B7B 32 19 6F     	ld (write_end_flag),a ;флаг что нужно дописывать остаток
 381++6B7E              	; ld de,(f_w_cur_trk) ;если сектор ещё не заполнен, останемся на старой позиции
 382++6B7E              	; ld (#5cf4),de
 383++6B7E              	; ld b,1 ;на сектор вперёд
 384++6B7E              	; ld de,(f_w_cur_trk)
 385++6B7E              	; call calc_next_pos
 386++6B7E              	; ld (f_w_cur_trk),de
 387++6B7E
 388++6B7E              fwrite_trd3
 389++6B7E 2A 1C 6F     	ld hl,(temp_hl) ;запишем остаток данных
 390++6B81              	;ld a,(sec_shift)
 391++6B81              	;ld c,a
 392++6B81              	;ld b,0
 393++6B81 ED 4B 21 6F  	ld bc,(sec_shift2)
 394++6B85 09           	add hl,bc ;с этой точки пишем
 395++6B86 22 1E 6F     	ld (temp_hl2),hl ;сохраним начало записи второго сектора
 396++6B89
 397++6B89 2A 1A 6F     	ld hl,(temp_bc) ;вычисление на чём остановимся в этот раз
 398++6B8C A7           	and a
 399++6B8D ED 42        	sbc hl,bc ;вычтем то, что добавили к первому сектору
 400++6B8F 4D           	ld c,l
 401++6B90 44           	ld b,h
 402++6B91 30 02        	jr nc,fwrite_trd5
 403++6B93 06 00        	ld b,0 ;коррекция если вышел минус
 404++6B95              fwrite_trd5
 405++6B95 2A 1C 6F     	ld hl,(temp_hl)
 406++6B98 09           	add hl,bc
 407++6B99
 408++6B99 11 FF 94     	ld de,outputBuffer
 409++6B9C A7           	and a
 410++6B9D ED 52        	sbc hl,de
 411++6B9F
 412++6B9F 7D           	ld a,l
 413++6BA0 32 20 6F     	ld (sec_shift),a ;смещение на следующий раз
 414++6BA3              	;ld hl,(temp_hl)
 415++6BA3
 416++6BA3
 417++6BA3              	; or a
 418++6BA3              	; jr z,fwrite_trd1
 419++6BA3              	; inc b  ;коррекция количества секторов
 420++6BA3
 421++6BA3 78           	ld a,b ;нужна проверка на количество секторов!!!
 422++6BA4 32 22 6F     	ld (sec_part),a ;запомним сколько секторов во второй части
 423++6BA7
 424++6BA7              	;ld a,b
 425++6BA7 B7           	or a
 426++6BA8 28 16        	jr z,fwrite_trd1 ;если размер данных меньше сектора, то пропустим запись
 427++6BAA
 428++6BAA 2A 1E 6F     	ld hl,(temp_hl2)
 429++6BAD              	;push bc
 430++6BAD ED 5B F4 5C  	ld de,(#5cf4)
 431++6BB1 0E 06            ld      c,6 ;пишем целыми секторами
 432++6BB3 CD 13 3D         call    #3d13
 433++6BB6 79           	ld a,c
 434++6BB7              	;pop bc
 435++6BB7 FE FF        	cp 255
 436++6BB9 CA 0C 6B     	jp z,fwrite_no_chek ;выход если ошибка
 437++6BBC              	; ld de,(f_w_cur_trk)
 438++6BBC              	; call calc_next_pos
 439++6BBC              	; ld (f_w_cur_trk),de
 440++6BBC
 441++6BBC AF           	xor a
 442++6BBD 32 19 6F     	ld (write_end_flag),a ;флаг что нужно дописывать остаток
 443++6BC0
 444++6BC0              fwrite_trd1
 445++6BC0 3A 19 6F     	ld a,(write_end_flag) ;нужно записывать остаток?
 446++6BC3 B7           	or a
 447++6BC4 20 12        	jr nz,fwrite_trd_ex ;не нужно
 448++6BC6
 449++6BC6 2A 1E 6F     	ld hl,(temp_hl2) ;сохраним незаписанный остаток
 450++6BC9 3A 22 6F     	ld a,(sec_part)
 451++6BCC 47           	ld b,a
 452++6BCD 0E 00        	ld c,0
 453++6BCF 09           	add hl,bc
 454++6BD0 11 00 51     	ld de,sec_buf
 455++6BD3 01 00 01     	ld bc,256
 456++6BD6 ED B0        	ldir
 457++6BD8              ;fwrite_trd2
 458++6BD8
 459++6BD8
 460++6BD8              fwrite_trd_ex
 461++6BD8 ED 4B 1A 6F  	ld bc,(temp_bc) ;возвратим, что сколько запрашивали, столько и записали байт
 462++6BDC              	;посчитаем общую длину записанного
 463++6BDC 2A 15 6F     	ld hl,(f_w_len)
 464++6BDF 09           	add hl,bc
 465++6BE0 22 15 6F     	ld (f_w_len),hl
 466++6BE3 30 07        	jr nc,fwrite_trd_ex1
 467++6BE5 2A 17 6F     	ld hl,(f_w_len+2)
 468++6BE8 23           	inc hl
 469++6BE9 22 17 6F     	ld (f_w_len+2),hl
 470++6BEC
 471++6BEC              fwrite_trd_ex1
 472++6BEC AF           	xor a ;флаги сбросим
 473++6BED C9               ret
 474++6BEE
 475++6BEE
 476++6BEE
 477++6BEE
 478++6BEE
 479++6BEE              ;------------------scl----------------------
 480++6BEE              fwrite_chek_scl ;запись scl файла (разворачивание образа)
 481++6BEE              	; ld a,2
 482++6BEE              	; out (254),a
 483++6BEE              ; WAITKEY_t	XOR A:IN A,(#FE):CPL:AND #1F:JR Z,WAITKEY_t
 484++6BEE              	; xor a
 485++6BEE              	; out (254),a
 486++6BEE 3A 14 6F     	ld a,(f_w_flag)
 487++6BF1 B7           	or a
 488++6BF2 CA 0C 6B     	jp z,fwrite_no_chek ;файл уже открыт?
 489++6BF5 ED 43 1A 6F  	ld (temp_bc),bc ;длина
 490++6BF9 22 1C 6F     	ld (temp_hl),hl ;адрес данных
 491++6BFC 78           	ld a,b
 492++6BFD B1           	or c
 493++6BFE CA 0C 6B     	jp z,fwrite_no_chek ; если длина 0, то выход
 494++6C01
 495++6C01              	; ld a,b
 496++6C01              	; or a
 497++6C01              	; jr nz,testt1
 498++6C01              	; nop
 499++6C01
 500++6C01              ; testt1
 501++6C01
 502++6C01 AF           	xor a
 503++6C02 32 22 6F     	ld (sec_part),a ;обнулить переменные
 504++6C05 32 21 6F     	ld (sec_shift2),a
 505++6C08 32 22 6F     	ld (sec_shift2+1),a
 506++6C0B 32 23 6F     	ld (sec_shift_flag),a
 507++6C0E 32 19 6F     	ld (write_end_flag),a ;
 508++6C11
 509++6C11
 510++6C11 3A 20 6F     	ld a,(sec_shift)
 511++6C14 B7           	or a
 512++6C15 28 38        	jr z,fwrite_scl3 ;если смещения нет, то первую часть пропустим
 513++6C17
 514++6C17
 515++6C17 4F           	ld c,a
 516++6C18 06 00        	ld b,0
 517++6C1A 2A 1A 6F     	ld hl,(temp_bc) ;проверка заполнится ли целый сектор
 518++6C1D 09           	add hl,bc
 519++6C1E
 520++6C1E 3E 01        	ld a,1
 521++6C20 32 19 6F     	ld (write_end_flag),a ;флаг что не нужно дописывать остаток
 522++6C23
 523++6C23 7C           	ld a,h
 524++6C24 B7           	or a
 525++6C25 20 05        	jr nz,fwrite_scl4
 526++6C27 3E 01        	ld a,1
 527++6C29 32 23 6F     	ld (sec_shift_flag),a ;флаг что не заполнен сектор
 528++6C2C
 529++6C2C              fwrite_scl4
 530++6C2C 21 00 51     	ld hl,sec_buf ;буфер последнего сектора
 531++6C2F 09           	add hl,bc ;на этой точке остановились
 532++6C30 EB           	ex de,hl
 533++6C31 2A 1C 6F     	ld hl,(temp_hl) ;присоединим начало данных в конец предыдущих
 534++6C34              	; ld a,c
 535++6C34              	; or a
 536++6C34              	; jr nz,fwrite_scl2
 537++6C34              	; inc b ;коррекция
 538++6C34              ; fwrite_scl2
 539++6C34              	; ld c,a
 540++6C34 AF           	xor a
 541++6C35 91           	sub c
 542++6C36 4F           	ld c,a ;сколько осталось перенести до заполнения сектора
 543++6C37 ED 43 21 6F  	ld (sec_shift2),bc ;сохраним сколько добавили байт
 544++6C3B ED B0        	ldir
 545++6C3D
 546++6C3D 3A 23 6F     	ld a,(sec_shift_flag)
 547++6C40 B7           	or a
 548++6C41 20 0C        	jr nz,fwrite_scl3 ;если сектор ещё не заполнен писать не будем
 549++6C43
 550++6C43 21 00 51     	ld hl,sec_buf
 551++6C46              	;ld de,(#5cf4)
 552++6C46              	;ld (f_w_cur_trk),de	;запомним позицию
 553++6C46 06 01            ld      b,#01 ;пишем 1 сектор из буфера
 554++6C48 CD B3 6C         call    scl_write_buf
 555++6C4B              	; ld a,c
 556++6C4B              	; cp 255
 557++6C4B              	; jp z,fwrite_no_chek ;выход если ошибка
 558++6C4B
 559++6C4B AF           	xor a
 560++6C4C 32 19 6F     	ld (write_end_flag),a ;флаг что нужно дописывать остаток
 561++6C4F              	; ld de,(f_w_cur_trk) ;если сектор ещё не заполнен, останемся на старой позиции
 562++6C4F              	; ld (#5cf4),de
 563++6C4F              	; ld b,1 ;на сектор вперёд
 564++6C4F              	; ld de,(f_w_cur_trk)
 565++6C4F              	; call calc_next_pos
 566++6C4F              	; ld (f_w_cur_trk),de
 567++6C4F
 568++6C4F              fwrite_scl3
 569++6C4F 2A 1C 6F     	ld hl,(temp_hl) ;запишем остаток данных
 570++6C52              	;ld a,(sec_shift)
 571++6C52              	;ld c,a
 572++6C52              	;ld b,0
 573++6C52 ED 4B 21 6F  	ld bc,(sec_shift2)
 574++6C56 09           	add hl,bc ;с этой точки пишем
 575++6C57 22 1E 6F     	ld (temp_hl2),hl ;сохраним начало записи второго сектора
 576++6C5A
 577++6C5A 2A 1A 6F     	ld hl,(temp_bc) ;вычисление на чём остановимся в этот раз
 578++6C5D A7           	and a
 579++6C5E ED 42        	sbc hl,bc ;вычтем то, что добавили к первому сектору
 580++6C60 4D           	ld c,l
 581++6C61 44           	ld b,h
 582++6C62 30 02        	jr nc,fwrite_scl5
 583++6C64 06 00        	ld b,0 ;коррекция если вышел минус
 584++6C66              fwrite_scl5
 585++6C66 2A 1C 6F     	ld hl,(temp_hl)
 586++6C69 09           	add hl,bc
 587++6C6A
 588++6C6A 11 FF 94     	ld de,outputBuffer
 589++6C6D A7           	and a
 590++6C6E ED 52        	sbc hl,de
 591++6C70
 592++6C70 7D           	ld a,l
 593++6C71 32 20 6F     	ld (sec_shift),a ;смещение на следующий раз
 594++6C74              	;ld hl,(temp_hl)
 595++6C74
 596++6C74
 597++6C74              	; or a
 598++6C74              	; jr z,fwrite_scl1
 599++6C74              	; inc b  ;коррекция количества секторов
 600++6C74
 601++6C74 78           	ld a,b ;нужна проверка на количество секторов!!!
 602++6C75 32 22 6F     	ld (sec_part),a ;запомним сколько секторов во второй части
 603++6C78
 604++6C78              	;ld a,b
 605++6C78 B7           	or a
 606++6C79 28 0A        	jr z,fwrite_scl1 ;если размер данных меньше сектора, то пропустим запись
 607++6C7B
 608++6C7B 2A 1E 6F     	ld hl,(temp_hl2)
 609++6C7E              	;push bc
 610++6C7E              	;ld de,(#5cf4)
 611++6C7E                  ;ld      c,6 ;пишем целыми секторами
 612++6C7E CD B3 6C         call    scl_write_buf
 613++6C81              	;ld a,c
 614++6C81              	;pop bc
 615++6C81              	; cp 255
 616++6C81              	; jp z,fwrite_no_chek ;выход если ошибка
 617++6C81              	; ld de,(f_w_cur_trk)
 618++6C81              	; call calc_next_pos
 619++6C81              	; ld (f_w_cur_trk),de
 620++6C81
 621++6C81 AF           	xor a
 622++6C82 32 19 6F     	ld (write_end_flag),a ;флаг что нужно дописывать остаток
 623++6C85
 624++6C85              fwrite_scl1
 625++6C85 3A 19 6F     	ld a,(write_end_flag) ;нужно записывать остаток?
 626++6C88 B7           	or a
 627++6C89 20 12        	jr nz,fwrite_scl_ex ;не нужно
 628++6C8B
 629++6C8B 2A 1E 6F     	ld hl,(temp_hl2) ;сохраним незаписанный остаток
 630++6C8E 3A 22 6F     	ld a,(sec_part)
 631++6C91 47           	ld b,a
 632++6C92 0E 00        	ld c,0
 633++6C94 09           	add hl,bc
 634++6C95 11 00 51     	ld de,sec_buf
 635++6C98 01 00 01     	ld bc,256
 636++6C9B ED B0        	ldir
 637++6C9D              ;fwrite_scl2
 638++6C9D
 639++6C9D
 640++6C9D              fwrite_scl_ex
 641++6C9D ED 4B 1A 6F  	ld bc,(temp_bc) ;возвратим, что сколько запрашивали, столько и записали байт
 642++6CA1              	;посчитаем общую длину записанного
 643++6CA1 2A 15 6F     	ld hl,(f_w_len)
 644++6CA4 09           	add hl,bc
 645++6CA5 22 15 6F     	ld (f_w_len),hl
 646++6CA8 30 07        	jr nc,fwrite_scl_ex1
 647++6CAA 2A 17 6F     	ld hl,(f_w_len+2)
 648++6CAD 23           	inc hl
 649++6CAE 22 17 6F     	ld (f_w_len+2),hl
 650++6CB1
 651++6CB1              fwrite_scl_ex1
 652++6CB1 AF           	xor a ;флаги сбросим
 653++6CB2 C9               ret
 654++6CB3
 655++6CB3
 656++6CB3
 657++6CB3
 658++6CB3
 659++6CB3
 660++6CB3              scl_write_buf ;заполнение промежуточного буфера
 661++6CB3 C5           	push bc ;сколько пакетов указано в b
 662++6CB4 11 00 53     	ld de,scl_buf ;перенесём сектор во временный буфер
 663++6CB7 01 00 01     	ld bc,256
 664++6CBA ED B0        	ldir
 665++6CBC 22 44 6F     	ld (scl_temp_hl2),hl ;сохраним адрес данных
 666++6CBF 3A 2C 6F     	ld a,(scl_que) ;проверим флаг что нужны данные
 667++6CC2 B7           	or a
 668++6CC3 28 08        	jr z,scl_write_buf_ret ;не будем вызывать парсер если не нужны
 669++6CC5 21 CD 6C     	ld hl,scl_write_buf_ret ;адрес возврата
 670++6CC8 E5           	push hl
 671++6CC9 2A 3E 6F     	ld hl,(scl_parse_ret_adr) ;адрес для продолжения основного цикла сборки
 672++6CCC E9           	jp (hl) ;отдадим пакет 256 байт парсеру
 673++6CCD              scl_write_buf_ret
 674++6CCD 2A 44 6F     	ld hl,(scl_temp_hl2)
 675++6CD0 C1           	pop bc
 676++6CD1 10 E0        	djnz scl_write_buf
 677++6CD3
 678++6CD3 C9           	ret
 679++6CD4
 680++6CD4
 681++6CD4
 682++6CD4              scl_parse ;разбор образа scl в trd, основной цикл
 683++6CD4              	;получить первый сектор
 684++6CD4              ;запрос порции данных по 256 байт
 685++6CD4 22 42 6F     	ld (scl_temp_hl),hl
 686++6CD7 ED 53 46 6F  	ld (scl_temp_de),de
 687++6CDB ED 43 48 6F  	ld (scl_temp_bc),bc
 688++6CDF 3E 01        	ld a,1
 689++6CE1 32 2C 6F     	ld (scl_que),a ;включим флаг что нужны данные
 690++6CE4 21 EB 6C     	ld hl,scl_parse_ret ;сохраним адрес возврата
 691++6CE7 22 3E 6F     	ld (scl_parse_ret_adr),hl
 692++6CEA C9           	ret ;вернёмся для ожидания данных
 693++6CEB              scl_parse_ret
 694++6CEB AF           	xor a
 695++6CEC 32 2C 6F     	ld (scl_que),a
 696++6CEF 2A 42 6F     	ld hl,(scl_temp_hl)
 697++6CF2 ED 5B 46 6F  	ld de,(scl_temp_de)
 698++6CF6 ED 4B 48 6F  	ld bc,(scl_temp_bc)
 699++6CFA
 700++6CFA 11 00 53     	ld de,scl_buf ;проверка метки образа
 701++6CFD 21 24 6F     	ld hl,scl_sign
 702++6D00 06 08        	ld b,8
 703++6D02              scl_parse_chk
 704++6D02 1A           	ld a,(de)
 705++6D03 BE           	cp (hl)
 706++6D04 20 06        	jr nz,scl_parse_chk_no
 707++6D06 23           	inc hl
 708++6D07 13           	inc de
 709++6D08 10 F8        	djnz scl_parse_chk
 710++6D0A 18 10        	jr scl_parse_chk_ok
 711++6D0C              scl_parse_chk_no ;если не совпало, значит плохой образ
 712++6D0C 21 2D 6F         ld hl, scl_err
 713++6D0F CD 10 68         call DialogBox.msgBox ;предуреждение
 714++6D12 AF           	xor a
 715++6D13 32 2C 6F     	ld (scl_que),a ;выключим флаг что нужны данные
 716++6D16 3E 04        	ld a,4 ;закроем файл
 717++6D18 CD C8 6A     	call fclose
 718++6D1B C9           	ret
 719++6D1C              scl_parse_chk_ok ;сигнатура правильная
 720++6D1C
 721++6D1C              ;формирование каталога
 722++6D1C 3A 08 53     	ld a,(scl_buf+8)
 723++6D1F 32 41 6F     	ld (scl_files),a ;всего файлов
 724++6D22 32 40 6F     	ld (scl_cat_cycl),a ;цикл
 725++6D25 21 09 53     	ld hl,scl_buf+9 ;адрес первого заголовка
 726++6D28 11 00 48     	ld de,cat_buf ;адрес формируемого каталога trd
 727++6D2B              scl_parse_cat2
 728++6D2B 06 0E        	ld b,14 ;14 байт одна запись
 729++6D2D              scl_parse_cat
 730++6D2D 7E           	ld a,(hl)
 731++6D2E 12           	ld (de),a
 732++6D2F 13           	inc de
 733++6D30 2C           	inc l ;адрес увеличиваем только в пределах младшего регистра
 734++6D31 20 26        	jr nz,scl_parse_cat1
 735++6D33              	;тут пора запросить следующий сектор
 736++6D33              ;запрос порции данных по 256 байт
 737++6D33 22 42 6F     	ld (scl_temp_hl),hl
 738++6D36 ED 53 46 6F  	ld (scl_temp_de),de
 739++6D3A ED 43 48 6F  	ld (scl_temp_bc),bc
 740++6D3E 3E 01        	ld a,1
 741++6D40 32 2C 6F     	ld (scl_que),a ;включим флаг что нужны данные
 742++6D43 21 4A 6D     	ld hl,scl_parse_ret1 ;сохраним адрес возврата
 743++6D46 22 3E 6F     	ld (scl_parse_ret_adr),hl
 744++6D49 C9           	ret ;вернёмся для ожидания данных
 745++6D4A              scl_parse_ret1
 746++6D4A AF           	xor a
 747++6D4B 32 2C 6F     	ld (scl_que),a
 748++6D4E 2A 42 6F     	ld hl,(scl_temp_hl)
 749++6D51 ED 5B 46 6F  	ld de,(scl_temp_de)
 750++6D55 ED 4B 48 6F  	ld bc,(scl_temp_bc)
 751++6D59
 752++6D59              scl_parse_cat1
 753++6D59 10 D2        	djnz scl_parse_cat
 754++6D5B 13           	inc de
 755++6D5C 13           	inc de
 756++6D5D 3A 40 6F     	ld a,(scl_cat_cycl)
 757++6D60 3D           	dec a
 758++6D61 32 40 6F     	ld (scl_cat_cycl),a
 759++6D64 20 C5        	jr nz,scl_parse_cat2
 760++6D66
 761++6D66 22 42 6F     	ld (scl_temp_hl),hl ;запомнить где остановились
 762++6D69
 763++6D69              ;подсчёт секторов и дорожек
 764++6D69 DD E5        	push ix
 765++6D6B 3A 41 6F     	ld a,(scl_files)
 766++6D6E 11 00 01     	ld de,#0100 ;данные с первой дорожки
 767++6D71 DD 21 00 48  	ld ix,cat_buf
 768++6D75 DD 73 0E     	ld (ix+14),e
 769++6D78 DD 72 0F     	ld (ix+15),d
 770++6D7B 21 00 00     	ld hl,0 ;общее количество секторов
 771++6D7E              scl_cacl
 772++6D7E 32 40 6F     	ld (scl_cat_cycl),a ;цикл
 773++6D81 DD 7E 0D     	ld a,(ix+13) ;длина файла в секторах
 774++6D84 4F           	ld c,a
 775++6D85 06 00        	ld b,0
 776++6D87 09           	add hl,bc ;секторов
 777++6D88
 778++6D88 01 10 00     	ld bc,16
 779++6D8B DD 09        	add ix,bc
 780++6D8D 47           	ld b,a
 781++6D8E CD B3 6E     	call calc_next_pos
 782++6D91 3A 40 6F     	ld a,(scl_cat_cycl)
 783++6D94 FE 01        	cp 1
 784++6D96 28 06        	jr z,scl_cacl2 ;в последний раз пропусим
 785++6D98 DD 73 0E     	ld (ix+14),e
 786++6D9B DD 72 0F     	ld (ix+15),d
 787++6D9E              scl_cacl2
 788++6D9E 3D           	dec a
 789++6D9F 20 DD        	jr nz,scl_cacl
 790++6DA1              	;теперь узнаем первый свободный сектор
 791++6DA1 DD 7E 0D     	ld a,(ix+13) ;длина файла в секторах
 792++6DA4 4F           	ld c,a
 793++6DA5 06 00        	ld b,0
 794++6DA7 09           	add hl,bc
 795++6DA8              	; ld b,a
 796++6DA8              	; call calc_next_pos
 797++6DA8 ED 53 E1 50  	ld (cat_buf+8*256+#e1),de ;Первый свободный сектор и дорожка на дискете
 798++6DAC 11 F0 09     	ld de,16*159
 799++6DAF EB           	ex de,hl
 800++6DB0 A7           	and a
 801++6DB1 ED 52        	sbc hl,de
 802++6DB3 22 E5 50     	ld (cat_buf+8*256+#e5),hl ;Число свободных секторов на диске
 803++6DB6 DD E1        	pop ix
 804++6DB8
 805++6DB8
 806++6DB8
 807++6DB8              ;запись содержимого файлов
 808++6DB8 3A 41 6F     	ld a,(scl_files) ;всего файлов
 809++6DBB 32 40 6F     	ld (scl_cat_cycl),a ;цикл
 810++6DBE 21 0D 48     	ld hl,cat_buf+13 ;адрес размер секторов файла
 811++6DC1 22 4A 6F     	ld (cat_cur_adr),hl
 812++6DC4
 813++6DC4 21 00 01     	ld hl,#0100 ;начиная с первой дорожки
 814++6DC7 22 F4 5C     	ld (#5cf4),hl
 815++6DCA              scl_parse_file2
 816++6DCA 2A 42 6F     	ld hl,(scl_temp_hl) ;адрес данных
 817++6DCD ED 5B 4A 6F  	ld de,(cat_cur_adr) ;адрес сектор дорожка файла
 818++6DD1              	;dec de
 819++6DD1 1A           	ld a,(de) ;количество секторов, цикл
 820++6DD2 4F           	ld c,a
 821++6DD3              scl_parse_file3
 822++6DD3 11 00 55     	ld de,scl_buf2 ;адрес ещё одного буфера
 823++6DD6 06 00        	ld b,0 ;256 байт один сектор, цикл
 824++6DD8              scl_parse_file
 825++6DD8 7E           	ld a,(hl)
 826++6DD9 12           	ld (de),a
 827++6DDA 13           	inc de
 828++6DDB 2C           	inc l ;адрес увеличиваем только в пределах младшего регистра
 829++6DDC 20 26        	jr nz,scl_parse_file1
 830++6DDE              	;тут пора запросить следующий сектор
 831++6DDE              ;запрос порции данных по 256 байт
 832++6DDE 22 42 6F     	ld (scl_temp_hl),hl
 833++6DE1 ED 53 46 6F  	ld (scl_temp_de),de
 834++6DE5 ED 43 48 6F  	ld (scl_temp_bc),bc
 835++6DE9 3E 01        	ld a,1
 836++6DEB 32 2C 6F     	ld (scl_que),a ;включим флаг что нужны данные
 837++6DEE 21 F5 6D     	ld hl,scl_parse_ret2 ;сохраним адрес возврата
 838++6DF1 22 3E 6F     	ld (scl_parse_ret_adr),hl
 839++6DF4 C9           	ret ;вернёмся для ожидания данных
 840++6DF5              scl_parse_ret2
 841++6DF5 AF           	xor a
 842++6DF6 32 2C 6F     	ld (scl_que),a
 843++6DF9 2A 42 6F     	ld hl,(scl_temp_hl)
 844++6DFC ED 5B 46 6F  	ld de,(scl_temp_de)
 845++6E00 ED 4B 48 6F  	ld bc,(scl_temp_bc)
 846++6E04
 847++6E04              scl_parse_file1
 848++6E04 10 D2        	djnz scl_parse_file
 849++6E06 22 42 6F     	ld (scl_temp_hl),hl
 850++6E09 ED 43 48 6F  	ld (scl_temp_bc),bc
 851++6E0D
 852++6E0D 21 00 55     	ld hl,scl_buf2 ;;запишем один сектор
 853++6E10 ED 5B F4 5C  	ld  de,(#5cf4)
 854++6E14 01 06 01         ld      bc,#0106 ;
 855++6E17 CD 13 3D         call    #3d13
 856++6E1A              	; ld a,c
 857++6E1A              	; cp 255
 858++6E1A              	; jp z,fwrite_no_chek ;выход если ошибка
 859++6E1A 2A 42 6F     	ld hl,(scl_temp_hl)
 860++6E1D ED 4B 48 6F  	ld bc,(scl_temp_bc)
 861++6E21
 862++6E21 0D           	dec c
 863++6E22 20 AF        	jr nz,scl_parse_file3
 864++6E24
 865++6E24 2A 4A 6F     	ld hl,(cat_cur_adr) ;адрес сектор дорожка файла
 866++6E27              	; ld e,(hl)
 867++6E27              	; inc hl
 868++6E27              	; ld d,(hl)
 869++6E27 01 10 00     	ld bc,16
 870++6E2A 09           	add hl,bc ;на следующий файл
 871++6E2B 22 4A 6F     	ld (cat_cur_adr),hl
 872++6E2E
 873++6E2E
 874++6E2E 3A 40 6F     	ld a,(scl_cat_cycl)
 875++6E31 3D           	dec a
 876++6E32 32 40 6F     	ld (scl_cat_cycl),a
 877++6E35 20 93        	jr nz,scl_parse_file2	;на следующий файл
 878++6E37
 879++6E37
 880++6E37
 881++6E37              ;формирование системного сектора №9 (8)
 882++6E37              	;
 883++6E37              	;ld (cat_buf+8*256+#e1),a ;// #E1 Первый свободный сектор на дискете
 884++6E37              	;
 885++6E37              	;ld (cat_buf+8*256+#e2),a ;// #E2 Первый свободный трек
 886++6E37 3E 16        	ld a,#16
 887++6E39 32 E3 50     	ld (cat_buf+8*256+#e3),a ;// #E3 16 80 дорожек, 2 стороны
 888++6E3C 3A 41 6F     	ld a,(scl_files)
 889++6E3F 32 E4 50     	ld (cat_buf+8*256+#e4),a ;// #E4 Общее количество файлов записанных на диск
 890++6E42              	;
 891++6E42              	;ld (cat_buf+8*256+#e5),a ;// #Е5,Е6 Число свободных секторов на диске
 892++6E42              	;ld (cat_buf+8*256+#e6),a
 893++6E42 3E 10        	ld a,#10
 894++6E44 32 E7 50     	ld (cat_buf+8*256+#e7),a ;// #E7 Код  #10,определяющий принадлежность к TR-DOS
 895++6E47
 896++6E47 21 02 6F     	ld hl,f_name ;запишем имя диска, взяв для этого имя файла
 897++6E4A 11 F5 50     	ld de,cat_buf+8*256+#f5 ;// #F5-#FC Имя диска в ASCII формате
 898++6E4D 01 08 00     	ld bc,8
 899++6E50 ED B0        	ldir
 900++6E52
 901++6E52 21 00 48     	ld hl,cat_buf ;запишем каталог на диск
 902++6E55 11 00 00     	ld de,0
 903++6E58 01 06 09         ld      bc,#0906 ;
 904++6E5B CD 13 3D         call    #3d13
 905++6E5E              	; ld a,c
 906++6E5E              	; cp 255
 907++6E5E              	; jp z,fwrite_no_chek ;выход если ошибка
 908++6E5E C9           	ret
 909++6E5F
 910++6E5F
 911++6E5F              ;-----------scl end --------------------
 912++6E5F
 913++6E5F
 914++6E5F
 915++6E5F
 916++6E5F
 917++6E5F
 918++6E5F
 919++6E5F
 920++6E5F
 921++6E5F
 922++6E5F              ; A - file stream id
 923++6E5F              ; fsync:
 924++6E5F              ;     esxCall ESX_FSYNC
 925++6E5F                  ; ret
 926++6E5F
 927++6E5F
 928++6E5F              ; HL - name (name.ext)
 929++6E5F              ; Returns:
 930++6E5F              ; HL - name (name    e)
 931++6E5F              format_name ;подгоняет имя файла под стандарт trdos (8+1)
 932++6E5F
 933++6E5F              	;сначала попробуем убрать из пути подпапку, если она есть
 934++6E5F 22 1C 6F     	ld (temp_hl),hl ;сохраним адрес исходного имени
 935++6E62 06 00        	ld b,#00 ;не больше 255 символов
 936++6E64              format_name5
 937++6E64 7E           	ld a,(hl)
 938++6E65 FE 2F        	cp "/" ;если есть подпапка
 939++6E67 28 0D        	jr z,format_name_path_yep
 940++6E69 7E           	ld a,(hl)
 941++6E6A FE 2E        	cp "." ;если ещё не дошли до расширения
 942++6E6C 20 05        	jr nz,format_name6
 943++6E6E 2A 1C 6F     	ld hl,(temp_hl) ;если дошли до расширения, то путей нет, вернёмся на начало имени
 944++6E71 18 04        	jr format_name_7 ;на выход
 945++6E73              format_name6
 946++6E73 23           	inc hl
 947++6E74 10 EE        	djnz format_name5
 948++6E76
 949++6E76              format_name_path_yep ;нашли
 950++6E76 23           	inc hl ;пропустим знак "/"
 951++6E77
 952++6E77              format_name_7
 953++6E77
 954++6E77
 955++6E77 E5           	push hl ;очистим место для нового имени
 956++6E78 21 02 6F     	ld hl,f_name
 957++6E7B 11 03 6F     	ld de,f_name+1
 958++6E7E 36 20        	ld (hl)," "
 959++6E80 01 08 00     	ld bc,8
 960++6E83 ED B0        	ldir
 961++6E85 E1           	pop hl
 962++6E86
 963++6E86 01 FF 09     	ld bc,#09ff ;длина имени 9 символов
 964++6E89 11 02 6F     	ld de,f_name ;куда
 965++6E8C              format_name2
 966++6E8C 7E           	ld a,(hl)
 967++6E8D FE 2E        	cp "."
 968++6E8F 20 08        	jr nz,format_name1
 969++6E91 23           	inc hl
 970++6E92 7E           	ld a,(hl)
 971++6E93 32 0A 6F     	ld (f_name+8),a ; и в конце первую букву расширения
 972++6E96 EB           	ex de,hl ;сохраним адрес исходного расширения
 973++6E97 18 16        	jr format_name_e
 974++6E99              format_name1
 975++6E99 ED A0        	ldi
 976++6E9B 10 EF        	djnz format_name2
 977++6E9D
 978++6E9D              	;если имя длинное, пропустим лишнее до расширения
 979++6E9D 06 00        	ld b,#00 ;не больше 255 символов
 980++6E9F              format_name3
 981++6E9F 7E           	ld a,(hl)
 982++6EA0 FE 2E        	cp "."
 983++6EA2 20 08        	jr nz,format_name4
 984++6EA4 23           	inc hl
 985++6EA5 7E           	ld a,(hl)
 986++6EA6 32 0A 6F     	ld (f_name+8),a ; и в конце первую букву расширения
 987++6EA9 EB           	ex de,hl ;сохраним адрес исходного расширения
 988++6EAA 18 03        	jr format_name_e
 989++6EAC              format_name4
 990++6EAC 23           	inc hl
 991++6EAD 10 F0        	djnz format_name3
 992++6EAF
 993++6EAF              format_name_e ;выход
 994++6EAF 21 02 6F     	ld hl,f_name ;вернём результат
 995++6EB2 C9           	ret
 996++6EB3
 997++6EB3              ; DE - trk/sec
 998++6EB3              ; B - sectors step
 999++6EB3              ; Returns:
1000++6EB3              ; DE - trk/sec
1001++6EB3              calc_next_pos		;вперёд на N секторов
1002++6EB3              			;ld b,4
1003++6EB3              			;ld  de,(#5ceb)
1004++6EB3              calc_next_pos2
1005++6EB3 1C           			inc e
1006++6EB4 7B           			ld a,e
1007++6EB5 FE 10        			cp 16
1008++6EB7 38 03        			jr c,calc_next_pos1
1009++6EB9 14           			inc d
1010++6EBA 1E 00        			ld e,0
1011++6EBC              calc_next_pos1
1012++6EBC              			;ld (#5ceb),de
1013++6EBC 10 F5        			djnz calc_next_pos2
1014++6EBE C9           			ret
1015++6EBF
1016++6EBF
1017++6EBF              ;testt db "123.trd"
1018++6EBF 49 6E 73 65  write_ima db "Insert disk to drive "
1018++6EC3 72 74 20 64
1018++6EC7 69 73 6B 20
1018++6ECB 74 6F 20 64
1018++6ECF 72 69 76 65
1018++6ED3 20
1019++6ED4 41 2E 20     write_ima_d db "A. "
1020++6ED7 41 6C 6C 20  		db "All data will be lost!",0
1020++6EDB 64 61 74 61
1020++6EDF 20 77 69 6C
1020++6EE3 6C 20 62 65
1020++6EE7 20 6C 6F 73
1020++6EEB 74 21 00
1021++6EEE
1022++6EEE 2E 74 72 64  trdExt1 db ".trd", 0
1022++6EF2 00
1023++6EF3 2E 54 52 44  trdExt2 db ".TRD", 0
1023++6EF7 00
1024++6EF8
1025++6EF8 2E 73 63 6C  sclExt1 db ".scl", 0
1025++6EFC 00
1026++6EFD 2E 53 43 4C  sclExt2 db ".SCL", 0
1026++6F01 00
1027++6F02
1028++6F02 00 00 00...  f_name ds 9 ;имя файла
1029++6F0B 00 00        f_r_cur_trk dw 	 0 ;текущие сектор-дорожка файла на чтение
1030++6F0D 00           f_r_len_sec db 0 ;длина файла на чтение в секторах
1031++6F0E 00 00        f_r_len dw 0;длина файла в байтах
1032++6F10 00           f_r_flag db 0 ;флаг что открыт файл на чтение
1033++6F11
1034++6F11 00 00        f_w_cur_trk dw 	 0 ;текущие сектор-дорожка файла на запись
1035++6F13 00           f_w_len_sec db 0 ;длина файла на запись в секторах
1036++6F14 00           f_w_flag db 0 ;флаг что открыт файл на запись
1037++6F15 00 00 00 00  f_w_len ds 4 ;длина записанных данных
1038++6F19 00           write_end_flag db 0 ;флаг что нужно записать остаток
1039++6F1A
1040++6F1A 00 00        temp_bc dw 0 ;хранение регистра
1041++6F1C 00 00        temp_hl dw 0 ;хранение регистра
1042++6F1E 00 00        temp_hl2 dw 0 ;хранение регистра
1043++6F20
1044++6F20 00           sec_shift db 0 ;указатель на каком байте остановлена запись
1045++6F21 00           sec_shift2 db 0 ;указатель на каком байте остановлена запись (остаток)
1046++6F22 00           sec_part db 0 ;сколько секторов во второй порции для записи
1047++6F23 00           sec_shift_flag db 0 ;флаг что буфер сектора не заполнен
1048++6F24
1049++6F24              ;секция scl
1050++6F24 53 49 4E 43  scl_sign db "SINCLAIR" ;метка
1050++6F28 4C 41 49 52
1051++6F2C 00           scl_que db 0 ;флаг запроса порции данных
1052++6F2D 53 43 4C 20  scl_err db "SCL image error!",0
1052++6F31 69 6D 61 67
1052++6F35 65 20 65 72
1052++6F39 72 6F 72 21
1052++6F3D 00
1053++6F3E 00 00        scl_parse_ret_adr dw 0; адрес возврата в цикл
1054++6F40 00           scl_cat_cycl db 0 ;переменная цикла
1055++6F41 00           scl_files db 0 ;всего файлов
1056++6F42 00 00        scl_temp_hl dw 0;;хранение регистра
1057++6F44 00 00        scl_temp_hl2 dw 0;
1058++6F46 00 00        scl_temp_de dw 0;
1059++6F48 00 00        scl_temp_bc dw 0;
1060++6F4A 00 00        cat_cur_adr dw 0;
1061++6F4C              ;scl end
1062++6F4C 00 00 00...  	align 256 ;временно
1063++7000              	;по адресу #4000 шрифт
1064++7000              cat_buf equ #4800 ;буфер для кататога диска 9*256
1065++7000              sec_buf equ cat_buf + 9*256 ;буфер сектора для записи 256
1066++7000              scl_buf equ sec_buf + 512 ;промежуточный буфер 256
1067++7000              scl_buf2 equ scl_buf + 512 ;промежуточный буфер 256
1068++7000
1069++7000                  ENDMODULE
# file closed: dos/trdos.asm
   9++7000              	ENDIF
  10++7000
  11++7000              	IFDEF ESXDOS
  12++7000 ~               		include "console.asm"
  13++7000 ~               		include "esxdos.asm"
  14++7000              	ENDIF
  15++7000
  16++7000              	IFDEF P3DOS
  17++7000 ~               		include "console.asm"
  18++7000 ~               		include "p3dos.asm"
  19++7000              	ENDIF
  20++7000
# file closed: dos/index.asm
  19+ 7000                  include "gopher/engine/history/index.asm"
# file opened: gopher/engine/history/index.asm
   1++7000                  include "controler.asm"
# file opened: gopher/engine/history/controler.asm
   1++7000                  module History
   2++7000              back:
   3++7000 3A 43 71         ld a, (depth)
   3++7003 FE 01          cp 1
   3++7005 CA 17 70       jp z, load
   4++7008 21 92 73 11      ld hl, historyBlock + HistoryRecord, de, historyBlock, bc, (total - 1) * HistoryRecord
   4++700C 44 71 01 38
   4++7010 09
   4++7011 ED B0          ldir ; Move history up
   5++7013 21 43 71         ld hl, depth
   5++7016 35             dec (hl)
   6++7017              ; Loads current resource
   7++7017              load:
   8++7017 21 34 70         ld hl, .msg
   8++701A CD 19 68       call DialogBox.msgNoWait
   9++701D AF               xor a
   9++701E 21 FF 94 11    ld hl, outputBuffer, de, outputBuffer + 1
   9++7022 00 95
  10++7024              	IFDEF MSX
  11++7024 ~                	ld bc, (ramtop)
  12++7024 ~                	dec bc
  13++7024              	ELSE
  14++7024 01 FF 6A         	ld bc, #ffff - outputBuffer - 1
  15++7027              	ENDIF
  16++7027
  17++7027 77               ld (hl), a
  18++7028 ED B0            ldir
  19++702A
  20++702A 3A 44 71         ld a, (historyBlock.isFile)
  20++702D A7             and a
  20++702E C2 2D 81       jp nz, Fetcher.fetchFromFS
  21++7031 C3 E0 80         jp Fetcher.fetchFromNet
  22++7034
  23++7034 20 20 20 20  .msg db "    Loading resource! Please wait! It will be here soon!", 0
  23++7038 4C 6F 61 64
  23++703C 69 6E 67 20
  23++7040 72 65 73 6F
  23++7044 75 72 63 65
  23++7048 21 20 50 6C
  23++704C 65 61 73 65
  23++7050 20 77 61 69
  23++7054 74 21 20 49
  23++7058 74 20 77 69
  23++705C 6C 6C 20 62
  23++7060 65 20 68 65
  23++7064 72 65 20 73
  23++7068 6F 6F 6E 21
  23++706C 00
  24++706D
  25++706D              home:
  26++706D 21 21 71         ld hl, homePage
  27++7070              ; HL - gopher row
  28++7070              navigate:
  29++7070 54 5D            ld de, hl
  30++7072 CD 59 7F         call UrlEncoder.isValidGopherRow
  31++7075 30 A0            jr nc, load ; Not valid - reload last
  32++7077 62 6B            ld hl, de
  33++7079 E5               push hl
  34++707A
  35++707A E5               push hl
  36++707B 21 C9 7C 11      ld hl, HistoryEnd - HistoryRecord, de, HistoryEnd, bc,  HistoryRecord * total
  36++707F 17 7F 01 86
  36++7083 0B
  36++7084 ED B8          lddr
  37++7086
  38++7086 ED 5B 8A 73      ld de, (Render.position), (historyBlock.position + HistoryRecord), de
  38++708A ED 53 D8 75
  39++708E                  ; Clean up struct
  40++708E AF               xor a
  40++708F 21 44 71 11    ld hl, historyBlock, de, historyBlock + 1, bc, historyBlockSize - 1, (hl), a
  40++7093 45 71 01 4D
  40++7097 02 77
  40++7099 ED B0          ldir
  41++709B E1               pop hl
  42++709C
  43++709C                  ; Fill record
  44++709C 54 5D            ld de, hl
  45++709E CD 18 7F         call UrlEncoder.isFile
  46++70A1 EB               ex hl, de
  47++70A2 11 44 71         ld de, historyBlock
  48++70A5 12               ld (de), a
  48++70A6 13             inc de
  49++70A7 7E               ld a, (hl)
  49++70A8 E5 D5          push hl, de
  49++70AA CD C3 62       call Render.getIcon
  49++70AD D1 E1          pop de, hl
  50++70AF 12               ld (de), a
  50++70B0 13             inc de
  51++70B1 3E 09            ld a, 9
  52++70B3
  53++70B3                  IFDEF MSX
  54++70B3 ~                	ld bc, #ff
  55++70B3                  ELSE
  56++70B3 01 FF 0F         	ld bc, #fff
  57++70B6                  ENDIF
  58++70B6
  59++70B6 ED B1            cpir
  60++70B8              .locatorCopy
  61++70B8 7E               ld a, (hl)
  61++70B9 FE 09          cp 9
  61++70BB 28 05          jr z, 1f
  62++70BD 12               ld (de), a
  62++70BE 23 13          inc hl, de
  63++70C0 18 F6            jr .locatorCopy
  64++70C2              1
  65++70C2 23               inc hl
  65++70C3 AF             xor a
  65++70C4 12             ld (de), a
  66++70C5 11 45 72         ld de, historyBlock.host
  67++70C8              .hostCopy
  68++70C8 7E               ld a, (hl)
  68++70C9 FE 09          cp 9
  68++70CB 28 05          jr z, 1f
  69++70CD 12               ld (de), a
  69++70CE 23 13          inc hl, de
  70++70D0 18 F6            jr .hostCopy
  71++70D2              1
  72++70D2 23               inc hl
  72++70D3 AF             xor a
  72++70D4 12             ld (de), a
  73++70D5 11 85 72         ld de, historyBlock.port
  74++70D8              .portCopy
  75++70D8 7E               ld a, (hl)
  76++70D9 FE 09            cp 9
  76++70DB 28 11          jr z, 1f
  77++70DD FE 0D            cp 13
  77++70DF 28 0D          jr z, 1f
  78++70E1 FE 0A            cp 10
  78++70E3 28 09          jr z, 1f
  79++70E5 FE 00            cp 0
  79++70E7 28 05          jr z, 1f
  80++70E9 12               ld (de), a
  80++70EA 23 13          inc hl, de
  81++70EC 18 EA            jr .portCopy
  82++70EE AF           1   xor a
  82++70EF 12             ld (de), a
  83++70F0 21 C0 67 11      ld hl, DialogBox.inputBuffer, de, historyBlock.search, bc, #ff
  83++70F4 8B 72 01 FF
  83++70F8 00
  83++70F9 ED B0          ldir
  84++70FB 11 00 00 ED      ld de, 0, (historyBlock.position), de
  84++70FF 53 8A 73
  85++7102 E1               pop hl
  86++7103 3A 43 71         ld a, (depth)
  86++7106 FE 05          cp total
  86++7108 30 04          jr nc, 1f
  87++710A 3C               inc a
  87++710B 32 43 71       ld (depth), a
  88++710E              1
  89++710E 3A 45 71         ld a,(historyBlock.mediaType)
  89++7111 FE 19          cp MIME_DOWNLOAD
  89++7113 CA C8 81       jp z, Gopher.download
  90++7116
  91++7116                  ifdef GS
  92++7116 ~                ld a,(historyBlock.mediaType)
  93++7116 ~                cp MIME_MOD
  94++7116 ~                jp nz,load
  95++7116 ~                ld a,(GeneralSound.GSdownType)
  96++7116 ~                xor 1
  97++7116 ~                jp z, downMod2file
  98++7116 ~
  99++7116 ~            downMod2GS
 100++7116 ~                jp Gopher.loadMod
 101++7116 ~            downMod2file
 102++7116 ~                jp Gopher.download
 103++7116                  else
 104++7116 3A 45 71         ld a,(historyBlock.mediaType)
 104++7119 FE 0D          cp MIME_MOD
 104++711B CA C8 81       jp z, Gopher.download
 105++711E                  endif
 106++711E
 107++711E C3 17 70         jp load
 108++7121
 109++7121              homePage:
 110++7121              	IFDEF MSX
 111++7121 ~                	db "1Home", TAB, "index.gph"
 112++7121 ~                	db TAB, "file", TAB, "70", CR, LF, 0
 113++7121                  ELSE
 114++7121 31 48 6F 6D      	db "1Home", TAB, "browser/index.gph"
 114++7125 65 09 62 72
 114++7129 6F 77 73 65
 114++712D 72 2F 69 6E
 114++7131 64 65 78 2E
 114++7135 67 70 68
 115++7138 09 66 69 6C      	db TAB, "file", TAB, "70", CR, LF, 0
 115++713C 65 09 37 30
 115++7140 0D 0A 00
 116++7143                  ENDIF
 117++7143                  endmodule
# file closed: gopher/engine/history/controler.asm
   2++7143                  include "model.asm"
# file opened: gopher/engine/history/model.asm
   1++7143              total   equ 5
   2++7143 00           depth   db 0
   3++7144
   4++7144              historyBlock:
   5++7144 00           .isFile    db  0
   6++7145 00           .mediaType db  0
   7++7146 00 00 00...  .locator   ds  #ff
   8++7245 00 00 00...  .host      ds  64
   9++7285 00 00 00...  .port      ds  6
  10++728B 00 00 00...  .search    ds  #ff
  11++738A 00 00        .position  dw  #0000    ;position
  12++738C
  13++738C 00 00 00 00      db 0,0,0,0,0,0  ;cursor_position page_offset
  13++7390 00 00
  14++7392
  15++7392              historyBlockSize = $ - historyBlock
  16++7392
  17++7392              HistoryRecord EQU $ - historyBlock
  18++7392                  dup total
  19++7392 00 00 00... >    ds HistoryRecord
  19++75E0 00 00 00... >    ds HistoryRecord
  19++782E 00 00 00... >    ds HistoryRecord
  19++7A7C 00 00 00... >    ds HistoryRecord
  19++7CCA 00 00 00... >    ds HistoryRecord
  20++7F18                  edup
  21++7F18              HistoryEnd equ $ - 1
  22++7F18
# file closed: gopher/engine/history/model.asm
# file closed: gopher/engine/history/index.asm
  20+ 7F18                  include "gopher/engine/urlencoder.asm"
# file opened: gopher/engine/urlencoder.asm
   1++7F18                  MODULE UrlEncoder
   2++7F18              ; HL - pointer to line in gopher page
   3++7F18              ; C - flag set when it's file
   4++7F18              isFile:
   5++7F18              .findServerLoop
   6++7F18 7E               ld a, (hl)
   6++7F19 A7             and a
   6++7F1A 28 3B          jr z, .notFile
   6++7F1C 23             inc hl
   7++7F1D FE 0D            cp 13
   7++7F1F 28 36          jr z, .notFile
   8++7F21 FE 09            cp 9
   8++7F23 28 02          jr z, .skipPath
   9++7F25 18 F1            jr .findServerLoop
  10++7F27              .skipPath
  11++7F27 7E               ld a, (hl)
  11++7F28 A7             and a
  11++7F29 28 2C          jr z, .notFile
  11++7F2B 23             inc hl
  12++7F2C FE 0D            cp 13
  12++7F2E 28 27          jr z, .notFile
  13++7F30 FE 09            cp 9
  13++7F32 28 02          jr z, .compareServer
  14++7F34 18 F1            jr .skipPath
  15++7F36              .compareServer
  16++7F36 7E               ld a, (hl)
  16++7F37 FE 66          cp "f"
  16++7F39 20 1C          jr nz, .notFile
  16++7F3B 23             inc hl
  17++7F3C 7E               ld a, (hl)
  17++7F3D FE 69          cp "i"
  17++7F3F 20 16          jr nz, .notFile
  17++7F41 23             inc hl
  18++7F42 7E               ld a, (hl)
  18++7F43 FE 6C          cp "l"
  18++7F45 20 10          jr nz, .notFile
  18++7F47 23             inc hl
  19++7F48 7E               ld a, (hl)
  19++7F49 FE 65          cp "e"
  19++7F4B 20 0A          jr nz, .notFile
  19++7F4D 23             inc hl
  20++7F4E 7E               ld a, (hl)
  20++7F4F FE 09          cp 9
  20++7F51 20 04          jr nz, .notFile
  20++7F53 23             inc hl
  21++7F54 3E 01            ld a, 1
  22++7F56 C9               ret
  23++7F57              .notFile
  24++7F57 AF               xor a
  25++7F58 C9               ret
  26++7F59
  27++7F59              ; Is enough fields to encode
  28++7F59              ; HL - pointer to line in gopher page
  29++7F59              ; C - flag set when there is enough fields
  30++7F59              isValidGopherRow:
  31++7F59 7E               ld a, (hl)
  31++7F5A A7             and a
  31++7F5B 28 FA          jr z, isFile.notFile
  31++7F5D 23             inc hl
  32++7F5E FE 0D            cp 13
  32++7F60 28 F5          jr z, isFile.notFile
  33++7F62 FE 09            cp 9
  33++7F64 28 02          jr z, .skipPath
  34++7F66 18 F1            jr isValidGopherRow
  35++7F68              .skipPath
  36++7F68 7E               ld a, (hl)
  36++7F69 A7             and a
  36++7F6A 28 EB          jr z, isFile.notFile
  36++7F6C 23             inc hl
  37++7F6D FE 0D            cp 13
  37++7F6F 28 E6          jr z, isFile.notFile
  38++7F71 FE 09            cp 9
  38++7F73 28 02          jr z, .skipHost
  39++7F75 18 F1            jr .skipPath
  40++7F77              .skipHost
  41++7F77 7E               ld a, (hl)
  41++7F78 A7             and a
  41++7F79 28 DC          jr z, isFile.notFile
  41++7F7B 23             inc hl
  42++7F7C FE 0D            cp 13
  42++7F7E 28 D7          jr z, isFile.notFile
  43++7F80 FE 09            cp 9
  43++7F82 28 02           jr z, .isValid
  44++7F84 18 F1            jr .skipHost
  45++7F86              .isValid:
  46++7F86 37               scf
  47++7F87 C9               ret
  48++7F88
  49++7F88              extractPath:
  50++7F88 21 46 71 11      ld hl, historyBlock.locator, de, nameBuffer, bc, #ff
  50++7F8C A0 7F 01 FF
  50++7F90 00
  50++7F91 ED B0          ldir
  51++7F93 C9               ret
  52++7F94
  53++7F94              extractHostName:
  54++7F94 21 45 72 11      ld hl, historyBlock.host, de, hostName, bc, 64
  54++7F98 A0 80 01 40
  54++7F9C 00
  54++7F9D ED B0          ldir
  55++7F9F C9               ret
  56++7FA0
  57++7FA0                  ENDMODULE
  58++7FA0
  59++7FA0 00 00 00...  nameBuffer ds #ff, 0
  60++809F
  61++809F 00                    db 0
  62++80A0 00 00 00...  hostName ds 64
# file closed: gopher/engine/urlencoder.asm
  21+ 80E0                  include "gopher/engine/fetcher.asm"
# file opened: gopher/engine/fetcher.asm
   1++80E0                  MODULE Fetcher
   2++80E0
   3++80E0              fetchFromNet:
   4++80E0
   5++80E0              	IFDEF MSX
   6++80E0 ~                	call Gopher.makeRequest
   6++80E0 ~              jr nz, .error
   7++80E0                  ELSE
   8++80E0 CD 9D 81         	call Gopher.makeRequest
   8++80E3 38 06          jr c, .error
   9++80E5                  ENDIF
  10++80E5
  11++80E5 CD B5 81         call Gopher.loadBuffer
  12++80E8 C3 39 81         jp MediaProcessor.processResource
  13++80EB              .error
  14++80EB 21 F4 80         ld hl, .err
  14++80EE CD 10 68       call DialogBox.msgBox
  15++80F1 C3 00 70         jp History.back
  16++80F4
  17++80F4 44 6F 63 75  .err db "Document fetch error! Check your connection or hostname!", 0
  17++80F8 6D 65 6E 74
  17++80FC 20 66 65 74
  17++8100 63 68 20 65
  17++8104 72 72 6F 72
  17++8108 21 20 43 68
  17++810C 65 63 6B 20
  17++8110 79 6F 75 72
  17++8114 20 63 6F 6E
  17++8118 6E 65 63 74
  17++811C 69 6F 6E 20
  17++8120 6F 72 20 68
  17++8124 6F 73 74 6E
  17++8128 61 6D 65 21
  17++812C 00
  18++812D
  19++812D
  20++812D              fetchFromFS:
  21++812D CD 88 7F         call UrlEncoder.extractPath
  22++8130              loadFile
  23++8130              	IFDEF MSX
  24++8130 ~                ld de, nameBuffer, a, FMODE_NO_WRITE
  25++8130 ~                call Dos.fopen
  26++8130 ~                ld a, b, (.fp), a
  27++8130 ~                ld de, outputBuffer, hl, (ramtop)
  28++8130 ~                call Dos.fread
  29++8130 ~                ld a, (.fp), b, a
  30++8130 ~                call Dos.fclose
  31++8130 ~                jp MediaProcessor.processResource
  32++8130 ~            .fp db 0
  33++8130              	ELSE
  34++8130 21 A0 7F         ld hl, nameBuffer
  35++8133 CD D3 69         call Dos.loadBuffer
  36++8136 C3 39 81         jp MediaProcessor.processResource
  37++8139              	ENDIF
  38++8139                  ENDMODULE
# file closed: gopher/engine/fetcher.asm
  22+ 8139                  include "gopher/engine/media-processor.asm"
# file opened: gopher/engine/media-processor.asm
   1++8139                  MODULE MediaProcessor
   2++8139              processResource:
   3++8139 CD 94 7F         call UrlEncoder.extractHostName
   4++813C 3A 45 71         ld a, (historyBlock.mediaType)
   5++813F FE 0E            cp MIME_MUSIC
   5++8141 28 13          jr z, processPT
   6++8143 FE 1A            cp MIME_LINK
   6++8145 28 15          jr z, processPage
   7++8147 FE B3            cp MIME_INPUT
   7++8149 28 11          jr z, processPage
   8++814B FE 01            cp MIME_IMAGE
   8++814D CA DA 94       jp z, ScreenViewer.display
   9++8150              	ifdef GS
  10++8150 ~                cp MIME_MOD
  10++8150 ~              jr z, processMOD
  11++8150              	endif
  12++8150              ; Fallback to plain text
  13++8150              processText:
  14++8150 CD 82 66         call Render.renderPlainTextScreen
  15++8153 C3 CA 66         jp   Render.plainTextLoop
  16++8156
  17++8156              processPT:
  18++8156 CD 8C 88         call VortexProcessor.play
  19++8159 C3 00 70         jp History.back
  20++815C
  21++815C                  ifdef GS
  22++815C ~            processMOD:
  23++815C ~                call ModProcessor.play
  24++815C ~                jp History.back
  25++815C              	endif
  26++815C
  27++815C              processPage:
  28++815C 3A 64 67         ld a, (Render.play_next)
  28++815F A7             and a
  28++8160 20 06          jr nz, .playNext
  29++8162 CD E5 64         call Render.renderGopherScreen
  30++8165 C3 34 65         jp   Render.workLoop
  31++8168              .playNext
  32++8168 21 8C 73         ld hl, Render.cursor_position
  33++816B 34               inc (hl)
  34++816C CD E5 64         call Render.renderGopherScreen
  35++816F C3 1E 65         jp Render.checkBorder
  36++8172                  ENDMODULE
# file closed: gopher/engine/media-processor.asm
  23+ 8172                  include "gopher/gopher.asm"
# file opened: gopher/gopher.asm
   1++8172                  module Gopher
   2++8172              ; HL - gopher row
   3++8172              extractRequest:
   4++8172 21 46 71         ld hl, historyBlock.locator
   5++8175 11 BB 82         ld de, requestbuffer
   6++8178              .loop
   7++8178 7E               ld a, (hl)
   8++8179 12               ld (de), a
   9++817A 23               inc hl
  10++817B 13               inc de
  11++817C FE 00            cp 0
  12++817E 28 02            jr z, .search
  13++8180 18 F6            jr .loop
  14++8182              .search
  15++8182 1B               dec de
  16++8183 3A 45 71         ld a, (historyBlock.mediaType)
  17++8186 FE B3            cp MIME_INPUT
  18++8188 20 10            jr nz, .exit
  19++818A 21 8B 72         ld hl, historyBlock.search
  20++818D 3E 09            ld a, TAB
  21++818F 12               ld (de), a
  22++8190 13               inc de
  23++8191              .searchCopy
  24++8191 7E               ld a, (hl)
  25++8192 A7               and a
  25++8193 28 05          jr z, .exit
  26++8195 12               ld (de), a
  27++8196 23               inc hl
  27++8197 13             inc de
  28++8198 18 F7            jr .searchCopy
  29++819A              .exit
  30++819A AF               xor a
  31++819B 12               ld (de), a
  32++819C C9               ret
  33++819D
  34++819D
  35++819D              makeRequest:
  36++819D CD 72 81         call extractRequest
  37++81A0
  38++81A0 21 45 72         ld hl, historyBlock.host
  39++81A3 11 85 72         ld de, historyBlock.port
  40++81A6 CD 68 86         call Wifi.openTCP
  41++81A9 D8               ret c
  42++81AA
  43++81AA 21 BB 82         ld hl, requestbuffer
  44++81AD CD 59 87         call Wifi.tcpSendZ
  45++81B0 AF               xor a
  45++81B1 32 33 85       ld (Wifi.closed), a
  46++81B4 C9               ret
  47++81B5
  48++81B5
  49++81B5              loadBuffer:
  50++81B5 21 FF 94         ld hl, outputBuffer
  51++81B8 22 31 85         ld (Wifi.buffer_pointer), hl
  52++81BB              .loop
  53++81BB CD A9 87         call Wifi.getPacket
  54++81BE 3A 33 85         ld a, (Wifi.closed)
  54++81C1 A7             and a
  54++81C2 C0             ret nz
  55++81C3 CD C6 86         call Wifi.continue
  56++81C6 18 F3            jr .loop
  57++81C8
  58++81C8                  ifdef GS
  59++81C8 ~            loadMod:
  60++81C8 ~                xor a
  60++81C8 ~              call GeneralSound.init
  61++81C8 ~                ld hl, .progress
  61++81C8 ~              call DialogBox.msgNoWait
  62++81C8 ~                call makeRequest
  62++81C8 ~              jp c, Fetcher.fetchFromNet.error
  63++81C8 ~                call GeneralSound.loadModule
  64++81C8 ~            .loop
  65++81C8 ~                ld hl, outputBuffer, (Wifi.buffer_pointer), hl
  66++81C8 ~                call Wifi.getPacket
  67++81C8 ~                ld a, (Wifi.closed)
  67++81C8 ~              and a
  67++81C8 ~              jr nz, .exit
  68++81C8 ~                ld hl, outputBuffer, bc, (Wifi.bytes_avail)
  69++81C8 ~            .loadLoop
  70++81C8 ~                ld a, b
  70++81C8 ~              or c
  70++81C8 ~              and a
  70++81C8 ~              jr z, .nextFrame
  71++81C8 ~                ld a, (hl)
  71++81C8 ~              call GeneralSound.sendByte
  72++81C8 ~                dec bc
  73++81C8 ~                inc hl
  74++81C8 ~                jr .loadLoop
  75++81C8 ~            .nextFrame
  76++81C8 ~                call pulsing
  77++81C8 ~                ;call Wifi.continue
  78++81C8 ~                jr .loop
  79++81C8 ~            .exit
  80++81C8 ~                call GeneralSound.finishLoadingModule
  81++81C8 ~                ;jp History.back
  82++81C8 ~            	jp MediaProcessor.processResource
  83++81C8 ~            .progress db "MOD downloading directly to GS!", 0
  84++81C8                  endif
  85++81C8
  86++81C8              download:
  87++81C8 11 46 71         ld de, historyBlock.locator
  88++81CB 62 6B            ld hl, de
  89++81CD              .findFileName
  90++81CD 1A               ld a, (de)
  90++81CE 13             inc de
  91++81CF FE 2F            cp '/'
  91++81D1 20 02          jr nz, .skip
  92++81D3 62 6B            ld hl, de
  93++81D5              .skip
  94++81D5 A7               and a
  94++81D6 20 F5          jr nz, .findFileName
  95++81D8              .copy
  96++81D8                  ;; HL - filename pointer
  97++81D8 11 C0 67         ld de, DialogBox.inputBuffer
  98++81DB              .copyFileName
  99++81DB 7E               ld a, (hl)
  99++81DC A7             and a
  99++81DD 28 05          jr z, .finishCopy
 100++81DF
 101++81DF 12               ld (de), a
 101++81E0 23 13          inc hl, de
 102++81E2 18 F7            jr .copyFileName
 103++81E4              .finishCopy
 104++81E4 12               ld (de), a
 105++81E5 CD 69 67         call DialogBox.inputBox.noclear
 106++81E8 3A C0 67         ld a, (DialogBox.namedownload)
 106++81EB A7             and a
 106++81EC CA 00 70       jp z, History.back
 107++81EF
 108++81EF CD 9D 81         call makeRequest
 108++81F2 DA EB 80       jp c, Fetcher.fetchFromNet.error
 109++81F5
 110++81F5 06 0E 21 C0      ld b, Dos.FMODE_CREATE, hl, DialogBox.namedownload
 110++81F9 67
 111++81FA CD EF 69         call Dos.fopen
 112++81FD 32 98 82         ld (.fp), a
 113++8200
 114++8200 21 73 82         ld hl, .progress
 114++8203 CD 19 68       call DialogBox.msgNoWait
 115++8206              .loop
 116++8206 21 FF 94 22      ld hl, outputBuffer, (Wifi.buffer_pointer), hl
 116++820A 31 85
 117++820C CD A9 87         call Wifi.getPacket
 118++820F 3A 33 85         ld a, (Wifi.closed)
 118++8212 A7             and a
 118++8213 20 0F          jr nz, .exit
 119++8215
 120++8215 3A 98 82 21      ld a, (.fp), hl, outputBuffer, bc, (Wifi.bytes_avail)
 120++8219 FF 94 ED 4B
 120++821D 2F 85
 121++821F                  ;call Dos.fwrite
 122++821F CD 9B 82         call pulsing
 123++8222                  ;call Wifi.continue
 124++8222 18 E2            jr .loop
 125++8224              .exit
 126++8224 3A 98 82         ld a, (.fp)
 127++8227 CD C8 6A         call Dos.fclose
 128++822A C3 00 70         jp History.back
 129++822D              .error
 130++822D 3A 98 82         ld a, (.fp)
 131++8230 CD C8 6A         call Dos.fclose
 132++8233 21 3C 82         ld hl, .err
 133++8236 CD 10 68         call DialogBox.msgBox
 134++8239 C3 00 70         jp History.back
 135++823C
 136++823C 4F 70 65 72  .err db "Operation failed! Sorry! Check filename or disk space!",0
 136++8240 61 74 69 6F
 136++8244 6E 20 66 61
 136++8248 69 6C 65 64
 136++824C 21 20 53 6F
 136++8250 72 72 79 21
 136++8254 20 43 68 65
 136++8258 63 6B 20 66
 136++825C 69 6C 65 6E
 136++8260 61 6D 65 20
 136++8264 6F 72 20 64
 136++8268 69 73 6B 20
 136++826C 73 70 61 63
 136++8270 65 21 00
 137++8273 44 6F 77 6E  .progress db "Downloading in progress! Wait a bit!", 0
 137++8277 6C 6F 61 64
 137++827B 69 6E 67 20
 137++827F 69 6E 20 70
 137++8283 72 6F 67 72
 137++8287 65 73 73 21
 137++828B 20 57 61 69
 137++828F 74 20 61 20
 137++8293 62 69 74 21
 137++8297 00
 138++8298 00           .fp db 0
 139++8299 00           socket db 0
 140++829A 20           pulsator db " "
 141++829B              pulsing
 142++829B 11 01 0B         ld de, #0B01
 142++829E CD 88 61       call TextMode.gotoXY
 143++82A1 3A 9A 82         ld a, (pulsator)
 144++82A4 FE 2A            cp '*'
 145++82A6 CA B2 82         jp z, printasterix
 146++82A9 CD 8E 60         call TextMode.putC
 147++82AC 3E 2A            ld a, '*'
 148++82AE 32 9A 82         ld (pulsator),a
 149++82B1 C9               ret
 150++82B2              printasterix
 151++82B2 CD 8E 60         call TextMode.putC
 152++82B5 3E 20            ld a, ' '
 153++82B7 32 9A 82         ld (pulsator),a
 154++82BA C9               ret
 155++82BB
 156++82BB 00 00 00...  requestbuffer ds #1ff
 157++84BA                  endmodule
 158++84BA
# file closed: gopher/gopher.asm
  24+ 84BA                  include "drivers/index.asm"
# file opened: drivers/index.asm
   1++84BA                  IFDEF UNO
   2++84BA ~                	include "uno-uart.asm"
   3++84BA                  ENDIF
   4++84BA
   5++84BA                  IFDEF UNOUART
   6++84BA ~                	include "uno-uart.asm"
   7++84BA                  ENDIF
   8++84BA
   9++84BA                  IFDEF MB03
  10++84BA ~                	include "mb03-uart.asm"
  11++84BA                  ENDIF
  12++84BA
  13++84BA                  IFDEF AY
  14++84BA ~                	include "ay-uart.asm"
  15++84BA                  ENDIF
  16++84BA
  17++84BA                  IFDEF ZW
  18++84BA                  	include "zx-wifi.asm"
# file opened: drivers/zx-wifi.asm
   1++84BA              ; This driver works with 16c550 uart that's support AFE
   2++84BA                  module Uart
   3++84BA              ; Make init shorter and readable:-)
   4++84BA                  macro outp port, value
   5++84BA ~            	ld b, port
   6++84BA ~            	ld c, #EF
   7++84BA ~                ld a, value
   8++84BA ~                out (c), a
   9++84BA                  endm
  10++84BA
  11++84BA              ; Internal port constants
  12++84BA              RBR_THR = #F8
  13++84BA              IER     = RBR_THR + 1
  14++84BA              IIR_FCR = RBR_THR + 2
  15++84BA              LCR     = RBR_THR + 3
  16++84BA              MCR     = RBR_THR + 4
  17++84BA              LSR     = RBR_THR + 5
  18++84BA              MSR     = RBR_THR + 6
  19++84BA              SR      = RBR_THR + 7
  20++84BA
  21++84BA
  22++84BA              init:
  23++84BA                  IFDEF GZ
  24++84BA                  outp MCR,     #0d  // Assert RTS
  24++84BA 06 FC       >	ld b, MCR
  24++84BC 0E EF       >	ld c, #EF
  24++84BE 3E 0D       >    ld a, #0d
  24++84C0 ED 79       >    out (c), a
  25++84C2                  outp IIR_FCR, #87  // Enable fifo 8 level, and clear it
  25++84C2 06 FA       >	ld b, IIR_FCR
  25++84C4 0E EF       >	ld c, #EF
  25++84C6 3E 87       >    ld a, #87
  25++84C8 ED 79       >    out (c), a
  26++84CA                  outp LCR,     #83  // 8n1, DLAB=1
  26++84CA 06 FB       >	ld b, LCR
  26++84CC 0E EF       >	ld c, #EF
  26++84CE 3E 83       >    ld a, #83
  26++84D0 ED 79       >    out (c), a
  27++84D2                  outp RBR_THR, 12  //(divider 12)
  27++84D2 06 F8       >	ld b, RBR_THR
  27++84D4 0E EF       >	ld c, #EF
  27++84D6 3E 0C       >    ld a, 12
  27++84D8 ED 79       >    out (c), a
  28++84DA                  outp IER,     #00  // (divider 0). Divider is 16 bit, so we get (#0002 divider)
  28++84DA 06 F9       >	ld b, IER
  28++84DC 0E EF       >	ld c, #EF
  28++84DE 3E 00       >    ld a, #00
  28++84E0 ED 79       >    out (c), a
  29++84E2
  30++84E2                  outp LCR,     #03 // 8n1, DLAB=0
  30++84E2 06 FB       >	ld b, LCR
  30++84E4 0E EF       >	ld c, #EF
  30++84E6 3E 03       >    ld a, #03
  30++84E8 ED 79       >    out (c), a
  31++84EA                  outp IER,     #00 // Disable int
  31++84EA 06 F9       >	ld b, IER
  31++84EC 0E EF       >	ld c, #EF
  31++84EE 3E 00       >    ld a, #00
  31++84F0 ED 79       >    out (c), a
  32++84F2                  outp MCR,     #2f // Enable AFE
  32++84F2 06 FC       >	ld b, MCR
  32++84F4 0E EF       >	ld c, #EF
  32++84F6 3E 2F       >    ld a, #2f
  32++84F8 ED 79       >    out (c), a
  33++84FA C9               ret
  34++84FB                  ELSE
  35++84FB ~                outp MCR,     #0d  // Assert RTS
  36++84FB ~                outp IIR_FCR, #87  // Enable fifo 8 level, and clear it
  37++84FB ~                outp LCR,     #83  // 8n1, DLAB=1
  38++84FB ~                outp RBR_THR, 1  // 115200 (divider 1)
  39++84FB ~                outp IER,     #00  // (divider 0). Divider is 16 bit, so we get (#0002 divider)
  40++84FB ~
  41++84FB ~                outp LCR,     #03 // 8n1, DLAB=0
  42++84FB ~                outp IER,     #00 // Disable int
  43++84FB ~                outp MCR,     #2f // Enable AFE
  44++84FB ~                ret
  45++84FB                  ENDIF
  46++84FB              retry_rec_count_max equ 50 ;ждать 1 байт максимум столько прерываний
  47++84FB
  48++84FB              ; Flag C <- Data available
  49++84FB              ; isAvailable:
  50++84FB                  ; ld a, LSR
  51++84FB                  ; in a, (#EF)
  52++84FB                  ; rrca
  53++84FB                  ; ret
  54++84FB
  55++84FB              ; Non-blocking read
  56++84FB              ; Flag C <- is byte was readen
  57++84FB              ; A <- byte
  58++84FB              ; read1:
  59++84FB                  ; ld a, LSR
  60++84FB                  ; in a, (#EF)
  61++84FB                  ; rrca
  62++84FB                  ; ret nc
  63++84FB                  ; ld a, RBR_THR
  64++84FB                  ; in a, (#EF)
  65++84FB                  ; scf
  66++84FB                  ; ret
  67++84FB
  68++84FB              ; Tries read byte with timeout
  69++84FB              ; Flag C <- is byte read
  70++84FB              ; A <- byte
  71++84FB              read:
  72++84FB AF           	xor a ;4
  73++84FC 32 78 5C     	ld (#5C78),a ;обнулить счётчик ожидания ;13
  74++84FF              .wait
  75++84FF 3E FD            ld a, LSR
  76++8501 DB EF            in a, (#EF)
  77++8503 0F               rrca
  78++8504 30 05        	jr nc, .readW
  79++8506 3E F8            ld a, RBR_THR
  80++8508 DB EF            in a, (#EF)
  81++850A C9           	ret
  82++850B              .readW
  83++850B 3A 78 5C     	ld a,(#5C78)
  84++850E FE 32        	cp retry_rec_count_max
  85++8510 38 ED        	jr c, .wait ;ещё попытка
  86++8512 AF           	xor a ;выключим флаг переноса если время вышло
  87++8513 C9           	ret
  88++8514
  89++8514
  90++8514
  91++8514
  92++8514              ; Blocking read
  93++8514              ; A <- Byte
  94++8514              ; readB:
  95++8514                  ; ld a, LSR
  96++8514                  ; in a, (#EF)
  97++8514                  ; rrca
  98++8514                  ; jr nc, readB
  99++8514              	; ld a, RBR_THR
 100++8514                  ; in a, (#EF)
 101++8514                  ; ret
 102++8514
 103++8514              ; A -> byte to send
 104++8514              write:
 105++8514 F5               push af
 106++8515              .wait
 107++8515 3E FD        	ld a, LSR
 108++8517 DB EF            in a, (#EF)
 109++8519 E6 20            and #20
 110++851B 28 F8            jr z, .wait
 111++851D F1               pop af
 112++851E 06 F8        	ld b, RBR_THR
 113++8520 0E EF        	ld c, #EF
 114++8522 ED 79            out (c), a
 115++8524 C9               ret
 116++8525
 117++8525                  endmodule
# file closed: drivers/zx-wifi.asm
  19++8525                  ENDIF
  20++8525
  21++8525              	include "utils.asm"
# file opened: drivers/utils.asm
   1++8525              ;;; Macroses!!!!
   2++8525                  MACRO EspSend Text
   3++8525 ~                ld hl, .txtB
   4++8525 ~                ld e, (.txtE - .txtB)
   5++8525 ~                call espSend
   6++8525 ~                jr .txtE
   7++8525 ~            .txtB
   8++8525 ~                db Text
   9++8525 ~            .txtE
  10++8525                  ENDM
  11++8525
  12++8525                  MACRO EspCmd Text
  13++8525 ~                ld hl, .txtB
  14++8525 ~                ld e, (.txtE - .txtB)
  15++8525 ~                call espSend
  16++8525 ~                jr .txtE
  17++8525 ~            .txtB
  18++8525 ~                db Text
  19++8525 ~                db 13, 10
  20++8525 ~            .txtE
  21++8525                  ENDM
  22++8525
  23++8525                  MACRO EspCmdOkErr text
  24++8525 ~                EspCmd text
  25++8525 ~                call checkOkErr
  26++8525                  ENDM
  27++8525
  28++8525              ; IN DE - string pointer
  29++8525              ; OUT HL - string len
  30++8525              strLen:
  31++8525 21 00 00         ld hl, 0
  32++8528              .loop
  33++8528 1A               ld a, (de)
  33++8529 A7             and a
  33++852A C8             ret z
  34++852B 13 23            inc de, hl
  35++852D 18 F9            jr .loop
# file closed: drivers/utils.asm
  22++852F
  23++852F              	IFDEF NEDOOSATM
  24++852F ~            		include "atm-uart.asm"
  25++852F              	ENDIF
  26++852F
  27++852F              	IFDEF NEDOOSEVO
  28++852F ~            		include "evo-uart.asm"
  29++852F                  ENDIF
  30++852F
  31++852F              	IFDEF NEDONET
  32++852F ~            		include "nedowifi.asm"
  33++852F              	ELSE
  34++852F              		include "wifi.asm"
# file opened: drivers/wifi.asm
   1++852F                  MODULE Wifi
   2++852F 00 00        bytes_avail dw 0
   3++8531 00 00        buffer_pointer dw 0
   4++8533 01           closed db 1
   5++8534              ; Initialize Wifi chip to work
   6++8534              init:
   7++8534
   8++8534 21 26 86         ld hl, .uartIniting
   8++8537 CD 83 60       call TextMode.printZ
   9++853A CD BA 84         call Uart.init
  10++853D 21 37 86         ld hl, .chipIniting
  10++8540 CD 83 60       call TextMode.printZ
  11++8543
  12++8543                  EspCmdOkErr "ATE0"
  12++8543             >    EspCmd "ATE0"
  12++8543 21 4D 85    >    ld hl, .txtB
  12++8546 1E 06       >    ld e, (.txtE - .txtB)
  12++8548 CD 3C 87    >    call espSend
  12++854B 18 06       >    jr .txtE
  12++854D             >.txtB
  12++854D 41 54 45 30 >    db "ATE0"
  12++8551 0D 0A       >    db 13, 10
  12++8553             >.txtE
  12++8553 CD C7 86    >    call checkOkErr
  13++8556 DA 06 86         jp c, .initError
  14++8559
  15++8559              ; Reading auth.pwd and send it to ESP
  16++8559 21 62 95 06      ld hl, creds, b, Dos.FMODE_READ
  16++855D 01
  16++855E CD EF 69       call Dos.fopen
  17++8561 F5               push af
  18++8562 21 73 95 01      ld hl,outputBuffer2, bc, 255
  18++8566 FF 00
  18++8568 CD DC 6A       call Dos.fread
  19++856B F1               pop af
  20++856C CD C8 6A         call Dos.fclose
  21++856F
  22++856F 21 4F 86         ld hl, .doneInit1
  22++8572 CD 83 60       call TextMode.printZ
  23++8575
  24++8575 21 73 95         ld hl,outputBuffer2
  25++8578 CD 46 87         call espSendT
  26++857B 3E 0D            ld a, 13
  26++857D CD 14 85       call Uart.write
  27++8580 3E 0A            ld a, 10
  27++8582 CD 14 85       call Uart.write
  28++8585 CD C7 86         call checkOkErr
  29++8588 DA 06 86         jp c, .initError
  30++858B              ;
  31++858B                 	EspCmdOkErr "AT+CIPSERVER=0"
  31++858B             >    EspCmd "AT+CIPSERVER=0"
  31++858B 21 95 85    >    ld hl, .txtB
  31++858E 1E 10       >    ld e, (.txtE - .txtB)
  31++8590 CD 3C 87    >    call espSend
  31++8593 18 10       >    jr .txtE
  31++8595             >.txtB
  31++8595 41 54 2B 43 >    db "AT+CIPSERVER=0"
  31++8599 49 50 53 45 >
  31++859D 52 56 45 52 >
  31++85A1 3D 30       >
  31++85A3 0D 0A       >    db 13, 10
  31++85A5             >.txtE
  31++85A5 CD C7 86    >    call checkOkErr
  32++85A8                  EspCmdOkErr "AT+CIPCLOSE" ; Close if there some connection was. Don't care about result
  32++85A8             >    EspCmd "AT+CIPCLOSE"
  32++85A8 21 B2 85    >    ld hl, .txtB
  32++85AB 1E 0D       >    ld e, (.txtE - .txtB)
  32++85AD CD 3C 87    >    call espSend
  32++85B0 18 0D       >    jr .txtE
  32++85B2             >.txtB
  32++85B2 41 54 2B 43 >    db "AT+CIPCLOSE"
  32++85B6 49 50 43 4C >
  32++85BA 4F 53 45    >
  32++85BD 0D 0A       >    db 13, 10
  32++85BF             >.txtE
  32++85BF CD C7 86    >    call checkOkErr
  33++85C2                  EspCmdOkErr "AT+CIPMUX=0" ; Single connection mode
  33++85C2             >    EspCmd "AT+CIPMUX=0"
  33++85C2 21 CC 85    >    ld hl, .txtB
  33++85C5 1E 0D       >    ld e, (.txtE - .txtB)
  33++85C7 CD 3C 87    >    call espSend
  33++85CA 18 0D       >    jr .txtE
  33++85CC             >.txtB
  33++85CC 41 54 2B 43 >    db "AT+CIPMUX=0"
  33++85D0 49 50 4D 55 >
  33++85D4 58 3D 30    >
  33++85D7 0D 0A       >    db 13, 10
  33++85D9             >.txtE
  33++85D9 CD C7 86    >    call checkOkErr
  34++85DC DA 06 86         jp c, .initError
  35++85DF
  36++85DF                  EspCmdOkErr "AT+CIPDINFO=0" ; Disable additional info
  36++85DF             >    EspCmd "AT+CIPDINFO=0"
  36++85DF 21 E9 85    >    ld hl, .txtB
  36++85E2 1E 0F       >    ld e, (.txtE - .txtB)
  36++85E4 CD 3C 87    >    call espSend
  36++85E7 18 0F       >    jr .txtE
  36++85E9             >.txtB
  36++85E9 41 54 2B 43 >    db "AT+CIPDINFO=0"
  36++85ED 49 50 44 49 >
  36++85F1 4E 46 4F 3D >
  36++85F5 30          >
  36++85F6 0D 0A       >    db 13, 10
  36++85F8             >.txtE
  36++85F8 CD C7 86    >    call checkOkErr
  37++85FB DA 06 86         jp c, .initError
  38++85FE
  39++85FE 21 48 86         ld hl, .doneInit
  39++8601 CD 83 60       call TextMode.printZ
  40++8604
  41++8604 B7               or a
  42++8605 C9               ret
  43++8606              .initError
  44++8606 21 0E 86         ld hl, .errMsg
  44++8609 CD 10 68       call DialogBox.msgBox
  45++860C 37               scf
  46++860D C9               ret
  47++860E 57 69 46 69  .errMsg      db "WiFi chip init failed!", "\r", 0
  47++8612 20 63 68 69
  47++8616 70 20 69 6E
  47++861A 69 74 20 66
  47++861E 61 69 6C 65
  47++8622 64 21 0D 00
  48++8626 55 61 72 74  .uartIniting db "Uart initing...", "\r", 0
  48++862A 20 69 6E 69
  48++862E 74 69 6E 67
  48++8632 2E 2E 2E 0D
  48++8636 00
  49++8637 43 68 69 70  .chipIniting db "Chip initing...", "\r", 0
  49++863B 20 69 6E 69
  49++863F 74 69 6E 67
  49++8643 2E 2E 2E 0D
  49++8647 00
  50++8648 44 6F 6E 65  .doneInit    db "Done!","\r", 0
  50++864C 21 0D 00
  51++864F 53 65 6E 64  .doneInit1   db "Sending auth.pwd to ESP","\r", 0
  51++8653 69 6E 67 20
  51++8657 61 75 74 68
  51++865B 2E 70 77 64
  51++865F 20 74 6F 20
  51++8663 45 53 50 0D
  51++8667 00
  52++8668                  IFNDEF PROXY
  53++8668              ; HL - host pointer in gopher row
  54++8668              ; DE - port pointer in gopher row
  55++8668              openTCP:
  56++8668 D5               push de
  57++8669 E5               push hl
  58++866A                  EspCmdOkErr "AT+CIPCLOSE" ; Don't care about result. Just close if it didn't happens before
  58++866A             >    EspCmd "AT+CIPCLOSE"
  58++866A 21 74 86    >    ld hl, .txtB
  58++866D 1E 0D       >    ld e, (.txtE - .txtB)
  58++866F CD 3C 87    >    call espSend
  58++8672 18 0D       >    jr .txtE
  58++8674             >.txtB
  58++8674 41 54 2B 43 >    db "AT+CIPCLOSE"
  58++8678 49 50 43 4C >
  58++867C 4F 53 45    >
  58++867F 0D 0A       >    db 13, 10
  58++8681             >.txtE
  58++8681 CD C7 86    >    call checkOkErr
  59++8684                  EspSend 'AT+CIPSTART="TCP","'
  59++8684 21 8E 86    >    ld hl, .txtB
  59++8687 1E 13       >    ld e, (.txtE - .txtB)
  59++8689 CD 3C 87    >    call espSend
  59++868C 18 13       >    jr .txtE
  59++868E             >.txtB
  59++868E 41 54 2B 43 >    db 'AT+CIPSTART="TCP","'
  59++8692 49 50 53 54 >
  59++8696 41 52 54 3D >
  59++869A 22 54 43 50 >
  59++869E 22 2C 22    >
  59++86A1             >.txtE
  60++86A1 E1               pop hl
  61++86A2 CD 46 87         call espSendT
  62++86A5                  EspSend '",'
  62++86A5 21 AF 86    >    ld hl, .txtB
  62++86A8 1E 02       >    ld e, (.txtE - .txtB)
  62++86AA CD 3C 87    >    call espSend
  62++86AD 18 02       >    jr .txtE
  62++86AF             >.txtB
  62++86AF 22 2C       >    db '",'
  62++86B1             >.txtE
  63++86B1 E1               pop hl
  64++86B2 CD 46 87         call espSendT
  65++86B5 3E 0D            ld a, 13
  65++86B7 CD 14 85       call Uart.write
  66++86BA 3E 0A            ld a, 10
  66++86BC CD 14 85       call Uart.write
  67++86BF AF               xor a
  67++86C0 32 33 85       ld (closed), a
  68++86C3 C3 C7 86         jp checkOkErr
  69++86C6
  70++86C6              continue:
  71++86C6 C9               ret
  72++86C7                  ENDIF
  73++86C7
  74++86C7
  75++86C7
  76++86C7              checkOkErr:
  77++86C7 CD FB 84         call Uart.read
  78++86CA FE 4F            cp 'O'
  78++86CC CA DC 86       jp z, .okStart ; OK
  79++86CF FE 45            cp 'E'
  79++86D1 CA F1 86       jp z, .errStart ; ERROR
  80++86D4 FE 46            cp 'F'
  80++86D6 CA 16 87       jp z, .failStart ; FAIL
  81++86D9 C3 C7 86         jp checkOkErr
  82++86DC              .okStart
  83++86DC CD FB 84         call Uart.read
  83++86DF FE 4B          cp 'K'
  83++86E1 C2 C7 86       jp nz, checkOkErr
  84++86E4 CD FB 84         call Uart.read
  84++86E7 FE 0D          cp 13
  84++86E9 C2 C7 86       jp nz, checkOkErr
  85++86EC CD 33 87         call .flushToLF
  86++86EF B7               or a
  87++86F0 C9               ret
  88++86F1              .errStart
  89++86F1 CD FB 84         call Uart.read
  89++86F4 FE 52          cp 'R'
  89++86F6 C2 C7 86       jp nz, checkOkErr
  90++86F9 CD FB 84         call Uart.read
  90++86FC FE 52          cp 'R'
  90++86FE C2 C7 86       jp nz, checkOkErr
  91++8701 CD FB 84         call Uart.read
  91++8704 FE 4F          cp 'O'
  91++8706 C2 C7 86       jp nz, checkOkErr
  92++8709 CD FB 84         call Uart.read
  92++870C FE 52          cp 'R'
  92++870E C2 C7 86       jp nz, checkOkErr
  93++8711 CD 33 87         call .flushToLF
  94++8714 37               scf
  95++8715 C9               ret
  96++8716              .failStart
  97++8716 CD FB 84         call Uart.read
  97++8719 FE 41          cp 'A'
  97++871B C2 C7 86       jp nz, checkOkErr
  98++871E CD FB 84         call Uart.read
  98++8721 FE 49          cp 'I'
  98++8723 C2 C7 86       jp nz, checkOkErr
  99++8726 CD FB 84         call Uart.read
  99++8729 FE 4C          cp 'L'
  99++872B C2 C7 86       jp nz, checkOkErr
 100++872E CD 33 87         call .flushToLF
 101++8731 37               scf
 102++8732 C9               ret
 103++8733              .flushToLF
 104++8733 CD FB 84         call Uart.read
 105++8736 FE 0A            cp 10
 105++8738 C2 33 87       jp nz, .flushToLF
 106++873B C9               ret
 107++873C
 108++873C              ; Send buffer to UART
 109++873C              ; HL - buff
 110++873C              ; E - count
 111++873C              espSend:
 112++873C 7E               ld a, (hl)
 112++873D CD 14 85       call Uart.write
 113++8740 23               inc hl
 114++8741 1D               dec e
 115++8742 C2 3C 87         jp nz, espSend
 116++8745 C9               ret
 117++8746
 118++8746              ; HL - string that ends with one of the terminator(CR/LF/TAB/NULL)
 119++8746              espSendT:
 120++8746 7E               ld a, (hl)
 121++8747
 122++8747 A7               and a
 122++8748 C8             ret z
 123++8749 FE 09            cp 9
 123++874B C8             ret z
 124++874C FE 0D            cp 13
 124++874E C8             ret z
 125++874F FE 0A            cp 10
 125++8751 C8             ret z
 126++8752
 127++8752 CD 14 85         call Uart.write
 128++8755 23               inc hl
 129++8756 C3 46 87         jp espSendT
 130++8759
 131++8759              ; HL - stringZ to send
 132++8759              ; Adds CR LF
 133++8759              tcpSendZ:
 134++8759 E5               push hl
 135++875A                  EspSend "AT+CIPSEND="
 135++875A 21 64 87    >    ld hl, .txtB
 135++875D 1E 0B       >    ld e, (.txtE - .txtB)
 135++875F CD 3C 87    >    call espSend
 135++8762 18 0B       >    jr .txtE
 135++8764             >.txtB
 135++8764 41 54 2B 43 >    db "AT+CIPSEND="
 135++8768 49 50 53 45 >
 135++876C 4E 44 3D    >
 135++876F             >.txtE
 136++876F D1               pop de
 136++8770 D5             push de
 137++8771 CD 25 85         call strLen
 138++8774 23               inc hl
 138++8775 23             inc hl ; +CRLF
 139++8776 CD 3E 88         call hlToNumEsp
 140++8779 3E 0D            ld a, 13
 140++877B CD 14 85       call Uart.write
 141++877E 3E 0A            ld a, 10
 141++8780 CD 14 85       call Uart.write
 142++8783 CD C7 86         call checkOkErr
 142++8786 D8             ret c
 143++8787              .wait
 144++8787 CD FB 84         call Uart.read
 144++878A FE 3E          cp '>'
 144++878C C2 87 87       jp nz, .wait
 145++878F E1               pop hl
 146++8790              .loop
 147++8790 7E               ld a, (hl)
 147++8791 A7             and a
 147++8792 CA 9C 87       jp z, .exit
 148++8795 CD 14 85         call Uart.write
 149++8798 23               inc hl
 150++8799 C3 90 87         jp .loop
 151++879C              .exit
 152++879C 3E 0D            ld a, 13
 152++879E CD 14 85       call Uart.write
 153++87A1 3E 0A            ld a, 10
 153++87A3 CD 14 85       call Uart.write
 154++87A6 C3 C7 86         jp checkOkErr
 155++87A9
 156++87A9              getPacket:
 157++87A9 CD FB 84         call Uart.read
 158++87AC FE 2B            cp '+'
 158++87AE CA DF 87       jp z, .ipdBegun    ; "+IPD," packet
 159++87B1 FE 4F            cp 'O'
 159++87B3 CA B9 87       jp z, .closedBegun ; It enough to check "OSED\n" :-)
 160++87B6 C3 A9 87         jp getPacket
 161++87B9              .closedBegun
 162++87B9 CD FB 84         call Uart.read
 162++87BC FE 53          cp 'S'
 162++87BE C2 B9 87       jp nz, .closedBegun
 163++87C1 CD FB 84         call Uart.read
 163++87C4 FE 45          cp 'E'
 163++87C6 C2 B9 87       jp nz, .closedBegun
 164++87C9 CD FB 84         call Uart.read
 164++87CC FE 44          cp 'D'
 164++87CE C2 B9 87       jp nz, .closedBegun
 165++87D1 CD FB 84         call Uart.read
 165++87D4 FE 0D          cp 13
 165++87D6 C2 B9 87       jp nz, .closedBegun
 166++87D9 3E 01 32 33      ld a, 1, (closed), a
 166++87DD 85
 167++87DE C9               ret
 168++87DF              .ipdBegun
 169++87DF CD FB 84         call Uart.read
 169++87E2 FE 49          cp 'I'
 169++87E4 C2 DF 87       jp nz, .ipdBegun
 170++87E7 CD FB 84         call Uart.read
 170++87EA FE 50          cp 'P'
 170++87EC C2 DF 87       jp nz, .ipdBegun
 171++87EF CD FB 84         call Uart.read
 171++87F2 FE 44          cp 'D'
 171++87F4 C2 DF 87       jp nz, .ipdBegun
 172++87F7 CD FB 84         call Uart.read  ;Comma
 173++87FA CD 24 88         call .count_ipd_lenght
 173++87FD 22 2F 85       ld (bytes_avail), hl
 174++8800 54 5D            ld de, hl
 175++8802 2A 31 85         ld hl, (buffer_pointer)
 176++8805              .readp
 177++8805 7C               ld a, h
 177++8806 FE FF          cp #ff
 177++8808 D2 1A 88       jp nc, .skipbuff
 178++880B CD FB 84         call Uart.read
 179++880E 77               ld (hl), a
 180++880F 1B               dec de
 181++8810 23               inc hl
 182++8811 7A               ld a, d
 182++8812 B3             or e
 182++8813 C2 05 88       jp nz, .readp
 183++8816 22 31 85         ld (buffer_pointer), hl
 184++8819 C9               ret
 185++881A              .skipbuff
 186++881A CD FB 84         call Uart.read
 187++881D 1B               dec de
 187++881E 7A             ld a, d
 187++881F B3             or e
 187++8820 C2 1A 88       jp nz, .skipbuff
 188++8823 C9               ret
 189++8824              .count_ipd_lenght
 190++8824 21 00 00     		ld hl,0			; count lenght
 191++8827 E5           .cil1	push  hl
 192++8828 CD FB 84             call Uart.read
 193++882B E1                   pop hl
 194++882C FE 3A        		cp ':'
 195++882E C8                   ret z
 196++882F D6 30        		sub 0x30
 197++8831 4D                   ld c,l
 198++8832 44                   ld b,h
 199++8833 29                   add hl,hl
 200++8834 29                   add hl,hl
 201++8835 09                   add hl,bc
 202++8836 29                   add hl,hl
 203++8837 4F                   ld c,a
 204++8838 06 00                ld b,0
 205++883A 09                   add hl,bc
 206++883B C3 27 88     		jp .cil1
 207++883E
 208++883E              ; Based on: https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispHL
 209++883E              ; HL - number
 210++883E              ; It will be written to UART
 211++883E              hlToNumEsp:
 212++883E 01 F0 D8     	ld	bc,-10000
 213++8841 CD 57 88     	call	.n1
 214++8844 01 18 FC     	ld	bc,-1000
 215++8847 CD 57 88     	call	.n1
 216++884A 01 9C FF     	ld	bc,-100
 217++884D CD 57 88     	call	.n1
 218++8850 0E F6        	ld	c,-10
 219++8852 CD 57 88     	call	.n1
 220++8855 0E FF        	ld	c,-1
 221++8857 3E 2F        .n1	ld	a,'0'-1
 222++8859 3C           .n2	inc	a
 223++885A 09           	add	hl,bc
 224++885B DA 59 88     	jp	c, .n2
 225++885E ED 42        	sbc	hl,bc
 226++8860 C5               push bc
 227++8861 CD 14 85     	call Uart.write
 228++8864 C1               pop bc
 229++8865 C9               ret
 230++8866              flushToLF1
 231++8866 CD FB 84         call Uart.read
 232++8869 FE 0A            cp 10
 232++886B C2 66 88       jp nz, flushToLF1
 233++886E C9               ret
 234++886F                  ENDMODULE
# file closed: drivers/wifi.asm
  35++886F              	ENDIF
  36++886F
  37++886F                  IFDEF SMUCRTC
  38++886F ~                include "smuc-rtc.asm"
  39++886F                  ENDIF
  40++886F
  41++886F                  IFDEF NOSRTC
  42++886F ~                include "nos-rtc.asm"
  43++886F                  ENDIF
  44++886F
  45++886F
  46++886F              	include "proxy.asm"
# file opened: drivers/proxy.asm
   1++886F                  IFDEF PROXY
   2++886F ~                MODULE Wifi
   3++886F ~            ; Same singature as wifi.openTCP
   4++886F ~            ; HL - host pointer in gopher row
   5++886F ~            ; DE - port pointer in gopher row
   6++886F ~            openTCP:
   7++886F ~                push de
   8++886F ~                push hl
   9++886F ~
  10++886F ~                xor a
  10++886F ~              ld hl, hostBuff, de, hostBuff + 1, bc, 102, (hl), a
  10++886F ~              ldir
  11++886F ~
  12++886F ~                EspCmdOkErr "AT+CIPCLOSE"
  13++886F ~                EspCmdOkErr 'AT+CIPSTART="TCP","138.68.76.243",6912' // Replace here for yourown proxy. If you wish
  14++886F ~                jr c, .error
  15++886F ~                pop hl
  15++886F ~              ld de, hostBuff
  16++886F ~            .copyHost
  17++886F ~                ld a, (hl)
  17++886F ~              and a
  17++886F ~              jr z, 1F
  17++886F ~              and a
  17++886F ~              jr z, 1F
  18++886F ~                ld (de), a
  18++886F ~              inc hl, de
  19++886F ~                jr .copyHost
  20++886F ~            1   xor a
  20++886F ~              ld (de), a
  21++886F ~                pop hl
  21++886F ~              ld de, portBuff
  22++886F ~            .copyPort
  23++886F ~                ld a, (hl)
  23++886F ~              and a
  23++886F ~              jr z, 1F
  23++886F ~              and a
  23++886F ~              jr z, 1F
  24++886F ~                ld (de), a
  24++886F ~              inc hl, de
  25++886F ~                jr .copyPort
  26++886F ~            1   ld hl, hostBuff
  26++886F ~              call tcpSendZ
  27++886F ~                ld hl, portBuff
  27++886F ~              call tcpSendZ
  28++886F ~                xor a
  28++886F ~              ld (closed), a
  29++886F ~                ret
  30++886F ~            .error
  31++886F ~                pop hl
  31++886F ~              pop de
  32++886F ~                ret
  33++886F ~
  34++886F ~            continue:
  35++886F ~                EspCmdOkErr "AT+CIPSEND=1"
  36++886F ~                ret c
  37++886F ~            .wait
  38++886F ~                call Uart.read
  38++886F ~              cp '>'
  38++886F ~              jr nz, .wait
  39++886F ~                ld a, 'c'
  39++886F ~              call Uart.write
  40++886F ~                jp checkOkErr
  41++886F ~
  42++886F ~            hostBuff ds 96
  43++886F ~            portBuff ds 7
  44++886F ~                ENDMODULE
  45++886F                  ENDIF
# file closed: drivers/proxy.asm
  47++886F              	include "memory.asm"
# file opened: drivers/memory.asm
   1++886F                  module Memory
   2++886F              BANKM = #5b5c
   3++886F              MEM_PORT = #7ffd
   4++886F
   5++886F              init:
   6++886F F3               di
   7++8870 FD CB 01 A6      res 4, (iy + 1)
   8++8874
   9++8874 AF               xor a
   9++8875 CD 79 88       call setPage
  10++8878 C9               ret
  11++8879
  12++8879              ; a - page
  13++8879              setPage:
  14++8879 F6 18            or #18
  14++887B 32 5C 5B       ld (BANKM), a
  15++887E 01 FD 7F         ld bc, MEM_PORT
  15++8881 ED 79          out (c), a
  16++8883 C9               ret
  17++8884
  18++8884                  endmodule
# file closed: drivers/memory.asm
  48++8884              	include "general-sound.asm"
# file opened: drivers/general-sound.asm
   1++8884                  ifdef GS
   2++8884 ~                macro GS_WaitCommand
   3++8884 ~            .wait
   4++8884 ~                in a, (GeneralSound.CMD)
   5++8884 ~                rrca
   6++8884 ~                jr c, .wait
   7++8884 ~                endm
   8++8884 ~
   9++8884 ~                macro GS_WaitData
  10++8884 ~            .wait
  11++8884 ~                in a, (GeneralSound.CMD)
  12++8884 ~                rlca
  13++8884 ~                jr c, .wait
  14++8884 ~                endm
  15++8884 ~
  16++8884 ~                macro GS_SendCommand nn
  17++8884 ~                ld a, nn
  17++8884 ~              out (GeneralSound.CMD), a
  18++8884 ~                endm
  19++8884 ~
  20++8884 ~                module GeneralSound
  21++8884 ~            ;; Control ports
  22++8884 ~            CMD  = 187
  23++8884 ~            DATA = 179
  24++8884 ~
  25++8884 ~            ;; Commands
  26++8884 ~            CMD_WARM_RESET      = #F3
  27++8884 ~            CMD_COLD_RESET      = #F4
  28++8884 ~            CMD_LOAD_MODULE     = #30
  29++8884 ~            CMD_PLAY_MODULE     = #31
  30++8884 ~            CMD_STOP_MODULE     = #32
  31++8884 ~            CMD_CONTINUE_MODULE = #33
  32++8884 ~            CMD_OPEN_STREAM     = #D1
  33++8884 ~            CMD_CLOSE_STREAM    = #D2
  34++8884 ~
  35++8884 ~            ; A - 0 warm reset, other - cold
  36++8884 ~            init:
  37++8884 ~                and a
  37++8884 ~              jr nz, .cold
  38++8884 ~                GS_SendCommand CMD_WARM_RESET
  39++8884 ~                ret
  40++8884 ~            .cold
  41++8884 ~                GS_SendCommand CMD_COLD_RESET
  42++8884 ~                ret
  43++8884 ~
  44++8884 ~            ;; Initializes loading module
  45++8884 ~            loadModule:
  46++8884 ~                GS_SendCommand CMD_LOAD_MODULE
  47++8884 ~                GS_WaitCommand
  48++8884 ~                GS_SendCommand CMD_OPEN_STREAM
  49++8884 ~                GS_WaitCommand
  50++8884 ~                ret
  51++8884 ~
  52++8884 ~            ;; Use it for streaming mod file
  53++8884 ~            sendByte:
  54++8884 ~                out (DATA), a
  55++8884 ~                GS_WaitData
  56++8884 ~                ret
  57++8884 ~
  58++8884 ~            ;; Call it when module was loaded
  59++8884 ~            finishLoadingModule:
  60++8884 ~                GS_SendCommand CMD_CLOSE_STREAM
  61++8884 ~                GS_WaitCommand
  62++8884 ~            rewind:
  63++8884 ~                ld a, 1
  63++8884 ~              out (DATA), a
  64++8884 ~                GS_SendCommand CMD_PLAY_MODULE
  65++8884 ~                GS_WaitCommand
  66++8884 ~                ld a, 1, (state),a
  67++8884 ~                ret
  68++8884 ~
  69++8884 ~            ;; Works like pause too
  70++8884 ~            stopModule:
  71++8884 ~                xor a
  71++8884 ~              ld (state), a
  72++8884 ~                GS_SendCommand CMD_STOP_MODULE
  73++8884 ~                ret
  74++8884 ~
  75++8884 ~            continueModule:
  76++8884 ~                ld a, 1
  76++8884 ~              ld (state), a
  77++8884 ~                GS_SendCommand CMD_CONTINUE_MODULE
  78++8884 ~                ret
  79++8884 ~
  80++8884 ~            ; Pauses resumes
  81++8884 ~            toggleModule:
  82++8884 ~                call Console.waitForKeyUp
  83++8884 ~                ld a, (state)
  83++8884 ~              and a
  84++8884 ~                jr z, continueModule
  85++8884 ~                jr stopModule
  86++8884 ~
  87++8884 ~            toggleDownload:
  88++8884 ~                ld a,(GSdownType)
  89++8884 ~                xor 1
  90++8884 ~                ld (GSdownType),a
  91++8884 ~                ret
  92++8884 ~
  93++8884 ~            GSdownType  db 0
  94++8884 ~            state db 0
  95++8884 ~                endmodule
  96++8884 ~
  97++8884                  endif
# file closed: drivers/general-sound.asm
  49++8884
# file closed: drivers/index.asm
  25+ 8884                  include "screen/rtc.asm"
# file opened: screen/rtc.asm
   1++8884              printRTC
   2++8884              	ifdef SMUCRTC
   3++8884 ~            	;печать текущего времени
   4++8884 ~            	call Clock.readTime
   5++8884 ~            	jr nc,read_time_ok
   6++8884 ~            	; ld hl,mes_no_RTC
   7++8884 ~            	; call print_mes
   8++8884 ~            	; scf
   9++8884 ~            	ret ;выход
  10++8884 ~            read_time_ok
  11++8884 ~            	push bc
  12++8884 ~            	ld l,e ;часы
  13++8884 ~            	ld h,0
  14++8884 ~            	call toDecimal
  15++8884 ~            	ld de,00 ;координаты
  16++8884 ~            	call TextMode.gotoXY
  17++8884 ~            	ld hl,decimalS+3
  18++8884 ~            	call TextMode.printZ
  19++8884 ~            	ld a,":"
  20++8884 ~            	call TextMode.putC
  21++8884 ~            	pop bc
  22++8884 ~            	ld l,b ;минуты
  23++8884 ~            	ld h,0
  24++8884 ~            	call toDecimal
  25++8884 ~            	ld hl,decimalS+3
  26++8884 ~            	call TextMode.printZ
  27++8884 ~            	; ld a,":"
  28++8884 ~            	; call TextMode.putC
  29++8884 ~            	; ld l,c ;секунды
  30++8884 ~            	; ld h,0
  31++8884 ~            	; call toDecimal
  32++8884 ~            	; ld hl,decimalS+3
  33++8884 ~            	; call TextMode.printZ
  34++8884 ~            	; or a ;нет ошибки
  35++8884 ~            	ret
  36++8884 ~
  37++8884 ~
  38++8884 ~            toDecimal		;конвертирует 2 байта в 5 десятичных цифр
  39++8884 ~            				;на входе в HL число
  40++8884 ~            			ld de,10000 ;десятки тысяч
  41++8884 ~            			ld a,255
  42++8884 ~            toDecimal10k
  43++8884 ~            			and a
  44++8884 ~            			sbc hl,de
  45++8884 ~            			inc a
  46++8884 ~            			jr nc,toDecimal10k
  47++8884 ~            			add hl,de
  48++8884 ~            			add a,48
  49++8884 ~            			ld (decimalS),a
  50++8884 ~            			ld de,1000 ;тысячи
  51++8884 ~            			ld a,255
  52++8884 ~            toDecimal1k
  53++8884 ~            			and a
  54++8884 ~            			sbc hl,de
  55++8884 ~            			inc a
  56++8884 ~            			jr nc,toDecimal1k
  57++8884 ~            			add hl,de
  58++8884 ~            			add a,48
  59++8884 ~            			ld (decimalS+1),a
  60++8884 ~            			ld de,100 ;сотни
  61++8884 ~            			ld a,255
  62++8884 ~            toDecimal01k
  63++8884 ~            			and a
  64++8884 ~            			sbc hl,de
  65++8884 ~            			inc a
  66++8884 ~            			jr nc,toDecimal01k
  67++8884 ~            			add hl,de
  68++8884 ~            			add a,48
  69++8884 ~            			ld (decimalS+2),a
  70++8884 ~            			ld de,10 ;десятки
  71++8884 ~            			ld a,255
  72++8884 ~            toDecimal001k
  73++8884 ~            			and a
  74++8884 ~            			sbc hl,de
  75++8884 ~            			inc a
  76++8884 ~            			jr nc,toDecimal001k
  77++8884 ~            			add hl,de
  78++8884 ~            			add a,48
  79++8884 ~            			ld (decimalS+3),a
  80++8884 ~            			ld de,1 ;единицы
  81++8884 ~            			ld a,255
  82++8884 ~            toDecimal0001k
  83++8884 ~            			and a
  84++8884 ~            			sbc hl,de
  85++8884 ~            			inc a
  86++8884 ~            			jr nc,toDecimal0001k
  87++8884 ~            			add hl,de
  88++8884 ~            			add a,48
  89++8884 ~            			ld (decimalS+4),a
  90++8884 ~            			ret
  91++8884 ~
  92++8884              	ENDIF
  93++8884
  94++8884              	IFDEF NOSRTC
  95++8884 ~            	call Clock.readTime	;bc=date, hl=time
  96++8884 ~
  97++8884 ~            	push hl
  98++8884 ~            	pop de
  99++8884 ~            	ld a,e
 100++8884 ~                add a,a
 101++8884 ~                and 63	;seconds
 102++8884 ~            	ld (seconds),a
 103++8884 ~
 104++8884 ~            	ld a,d
 105++8884 ~                rra
 106++8884 ~                rra
 107++8884 ~                rra
 108++8884 ~                and 31 		;hours
 109++8884 ~            	ld (hours),a
 110++8884 ~
 111++8884 ~                ex de,hl
 112++8884 ~                add hl,hl
 113++8884 ~                add hl,hl
 114++8884 ~                add hl,hl
 115++8884 ~                ex de,hl
 116++8884 ~                ld a,d
 117++8884 ~                and 63       ;minutes
 118++8884 ~             	ld (minutes),a
 119++8884 ~
 120++8884 ~            ;        ld a,h
 121++8884 ~            ;        srl a
 122++8884 ~            ;        ;sub 20
 123++8884 ~            ;        ld b,0x93		;year
 124++8884 ~            ;        call send2ve
 125++8884 ~            ;
 126++8884 ~            ;        ld a,l
 127++8884 ~            ;        and 31
 128++8884 ~            ;        ld b,0x13		;day
 129++8884 ~            ;        call send2ve
 130++8884 ~            ;
 131++8884 ~            ;        add hl,hl
 132++8884 ~            ;        add hl,hl
 133++8884 ~            ;        add hl,hl
 134++8884 ~            ;        ld a,h
 135++8884 ~            ;        and 15
 136++8884 ~            ;        ld b,0x53	        ;month
 137++8884 ~            ;        call send2ve
 138++8884 ~            	ld a, (oldminutes)
 139++8884 ~            	ld d,a
 140++8884 ~            	ld a, (minutes)
 141++8884 ~            	cp d
 142++8884 ~            	ret z
 143++8884 ~            	ld (oldminutes), a
 144++8884 ~
 145++8884 ~            	ld d,1 ;координаты
 146++8884 ~            	ld e,73
 147++8884 ~            	call TextMode.gotoXY
 148++8884 ~            	ld a,'['
 149++8884 ~            	call TextMode.putC
 150++8884 ~            	ld h,0
 151++8884 ~            	ld a,(hours) ;часы
 152++8884 ~            	ld l,a
 153++8884 ~            	call toDecimal
 154++8884 ~            	ld hl,decimalS+3
 155++8884 ~            	call TextMode.printZ
 156++8884 ~            	ld a,':'
 157++8884 ~            	call TextMode.putC
 158++8884 ~            	ld h,0
 159++8884 ~            	ld a,(minutes) ;минуты
 160++8884 ~            	ld l,a
 161++8884 ~            	call toDecimal
 162++8884 ~            	ld hl,decimalS+3
 163++8884 ~            	call TextMode.printZ
 164++8884 ~            	;ld a,':'
 165++8884 ~            	;call TextMode.putC
 166++8884 ~            	;ld h,0
 167++8884 ~            	;ld a,(seconds) ;секунды
 168++8884 ~            	;ld l,a
 169++8884 ~            	;call toDecimal
 170++8884 ~            	;ld hl,decimalS+3
 171++8884 ~            	;call TextMode.printZ
 172++8884 ~            	ld a,']'
 173++8884 ~            	call TextMode.putC
 174++8884 ~            	ret
 175++8884 ~
 176++8884 ~            toDecimal		;конвертирует 2 байта в 5 десятичных цифр
 177++8884 ~            				;на входе в HL число
 178++8884 ~            			ld de,10000 ;десятки тысяч
 179++8884 ~            			ld a,255
 180++8884 ~            toDecimal10k
 181++8884 ~            			and a
 182++8884 ~            			sbc hl,de
 183++8884 ~            			inc a
 184++8884 ~            			jr nc,toDecimal10k
 185++8884 ~            			add hl,de
 186++8884 ~            			add a,48
 187++8884 ~            			ld (decimalS),a
 188++8884 ~            			ld de,1000 ;тысячи
 189++8884 ~            			ld a,255
 190++8884 ~            toDecimal1k
 191++8884 ~            			and a
 192++8884 ~            			sbc hl,de
 193++8884 ~            			inc a
 194++8884 ~            			jr nc,toDecimal1k
 195++8884 ~            			add hl,de
 196++8884 ~            			add a,48
 197++8884 ~            			ld (decimalS+1),a
 198++8884 ~            			ld de,100 ;сотни
 199++8884 ~            			ld a,255
 200++8884 ~            toDecimal01k
 201++8884 ~            			and a
 202++8884 ~            			sbc hl,de
 203++8884 ~            			inc a
 204++8884 ~            			jr nc,toDecimal01k
 205++8884 ~            			add hl,de
 206++8884 ~            			add a,48
 207++8884 ~            			ld (decimalS+2),a
 208++8884 ~            			ld de,10 ;десятки
 209++8884 ~            			ld a,255
 210++8884 ~            toDecimal001k
 211++8884 ~            			and a
 212++8884 ~            			sbc hl,de
 213++8884 ~            			inc a
 214++8884 ~            			jr nc,toDecimal001k
 215++8884 ~            			add hl,de
 216++8884 ~            			add a,48
 217++8884 ~            			ld (decimalS+3),a
 218++8884 ~            			ld de,1 ;единицы
 219++8884 ~            			ld a,255
 220++8884 ~            toDecimal0001k
 221++8884 ~            			and a
 222++8884 ~            			sbc hl,de
 223++8884 ~            			inc a
 224++8884 ~            			jr nc,toDecimal0001k
 225++8884 ~            			add hl,de
 226++8884 ~            			add a,48
 227++8884 ~            			ld (decimalS+4),a
 228++8884 ~            			ret
 229++8884 ~            hours
 230++8884 ~            	db 0
 231++8884 ~            minutes
 232++8884 ~            	db 0
 233++8884 ~            seconds
 234++8884 ~            	db 0
 235++8884              	ENDIF
 236++8884
 237++8884              	IFDEF MSX
 238++8884              	ENDIF
 239++8884
 240++8884 C9           	ret
 241++8885 00 00 00...  decimalS	ds 6 ;десятичные цифры
 242++888B
 243++888B              oldminutes
 244++888B FF           	db 255
 245++888C
 246++888C
 247++888C
# file closed: screen/rtc.asm
  26+ 888C
  27+ 888C                  IFDEF NEDOOS
  28+ 888C ~                    include "screen/nedoscreen.asm"
  29+ 888C ~                    include "player/vortexnedoos.asm"
  30+ 888C ~                    include "player/mod-processor.asm"
  31+ 888C ~            start:
  32+ 888C ~            outputBuffer:
  33+ 888C ~                    ld sp, 0x4000
  34+ 888C ~                    ld c,nos.CMD_SETSYSDRV
  35+ 888C ~                 	ex af,af'
  36+ 888C ~            	    call nos.BDOS
  37+ 888C              	ELSE
  38+ 888C                      include "player/vortex-processor.asm"
# file opened: player/vortex-processor.asm
   1++888C                  MODULE VortexProcessor
   2++888C              	IFDEF MSX
   3++888C ~            play:
   4++888C ~                call Console.peekC
   4++888C ~              and a
   5++888C ~                jr nz, play
   6++888C ~
   7++888C ~                ld hl, message
   7++888C ~              call DialogBox.msgNoWait
   8++888C ~
   9++888C ~                ld hl, outputBuffer
   9++888C ~              call VTPL.INIT
  10++888C ~            .loop
  11++888C ~                halt
  11++888C ~              di
  11++888C ~              call VTPL.PLAY
  11++888C ~              ei
  12++888C ~                call Console.peekC
  12++888C ~              and a
  12++888C ~              jp nz, .stop
  13++888C ~                jr nc, .loop
  14++888C ~            .stop
  15++888C ~                call VTPL.MUTE
  16++888C ~            .wlp
  17++888C ~                call Console.peekC
  17++888C ~              and a
  18++888C ~                jr nz, .wlp
  19++888C ~                ret
  20++888C ~
  21++888C ~            message db "Press key to stop...", 0
  22++888C ~                ENDMODULE
  23++888C ~                include "msxplayer.asm"
  24++888C              	ELSE
  25++888C              play:
  26++888C 3E FF            ld a, 255
  27++888E 32 8B 88         ld (oldminutes), a
  28++8891
  29++8891 CD 48 68         call Console.waitForKeyUp
  30++8894
  31++8894 21 CF 88         ld hl, message
  31++8897 CD 19 68       call DialogBox.msgNoWait
  32++889A
  33++889A 21 FF 94         ld hl, outputBuffer
  33++889D CD 25 89       call VTPL.INIT
  34++88A0
  35++88A0
  36++88A0 3E 01 32 64      ld a, 1, (Render.play_next), a
  36++88A4 67
  37++88A5
  38++88A5                  IFDEF GS
  39++88A5 ~                call GeneralSound.stopModule
  40++88A5                  ENDIF
  41++88A5              .loop
  42++88A5 76               halt
  42++88A6 F3             di
  42++88A7 CD 48 91       call VTPL.PLAY
  42++88AA FB             ei
  43++88AB AF               xor a
  43++88AC DB FE          in a, (#fe)
  43++88AE 2F             cpl
  43++88AF E6 1F          and 31
  43++88B1 C2 C9 88       jp nz, .stopKey
  44++88B4 CD 84 88         call printRTC
  45++88B7 3A EE 88         ld a, (VTPL.SETUP)
  45++88BA 17             rla
  45++88BB 30 E8          jr nc, .loop
  46++88BD 3E 01 32 64      ld a, 1, (Render.play_next), a
  46++88C1 67
  47++88C2              .stop
  48++88C2 CD 13 89         call VTPL.MUTE
  49++88C5
  50++88C5                  IFDEF AY
  51++88C5 ~                call restoreAyState
  52++88C5                  ENDIF
  53++88C5
  54++88C5 CD 48 68         call Console.waitForKeyUp
  55++88C8 C9               ret
  56++88C9              .stopKey
  57++88C9 AF               xor a
  57++88CA 32 64 67       ld (Render.play_next), a
  58++88CD 18 F3            jr .stop
  59++88CF
  60++88CF                  IFDEF AY
  61++88CF ~            restoreAyState:
  62++88CF ~                ld a, #07
  63++88CF ~                ld bc, #fffd
  64++88CF ~                out (c), a
  65++88CF ~                ld a, #fc
  66++88CF ~                ld b, #bf
  67++88CF ~                out (c), a ; Enable read mode
  68++88CF ~
  69++88CF ~                ld a, #0e
  70++88CF ~                ld bc, #fffd
  71++88CF ~                out (c), a
  72++88CF ~                ret
  73++88CF              	ENDIF
  74++88CF 50 72 65 73  message db "Press key to stop...", 0
  74++88D3 73 20 6B 65
  74++88D7 79 20 74 6F
  74++88DB 20 73 74 6F
  74++88DF 70 2E 2E 2E
  74++88E3 00
  75++88E4                  ENDMODULE
  76++88E4                  include "player.asm"
# file opened: player/player.asm
   1++88E4              ;Universal PT2'n'PT3 Turbo Sound player for ZX Spectrum
   2++88E4              ;(c)2004-2007 S.V.Bulba <vorobey@mail.khstu.ru>
   3++88E4              ;Specially for AlCo
   4++88E4              ;http://bulba.untergrund.net/ (http://bulba.at.kz/)
   5++88E4              	MODULE VTPL
   6++88E4              ;Release number
   7++88E4              Release EQU "0"
   8++88E4              ;Conditional assembly
   9++88E4              ;1) Current position counters at (Vars1+0) and (Vars2+0)
  10++88E4              CurPosCounter=0
  11++88E4              ;2) Allow channels allocation bits at (START+10)
  12++88E4              ACBBAC=0
  13++88E4              ;3) Allow loop checking and disabling
  14++88E4              LoopChecker=1
  15++88E4              ;4) Insert official identificator
  16++88E4              Id=0
  17++88E4              ;5) Set IY for correct return to ZX Basic
  18++88E4              Basic=1
  19++88E4
  20++88E4              ;Features
  21++88E4              ;--------
  22++88E4              ;-Can be compiled at any address (i.e. no need rounding ORG
  23++88E4              ; address).
  24++88E4              ;-Variables (VARS) can be located at any address (not only after
  25++88E4              ; code block).
  26++88E4              ;-INIT subprogram checks PT3-module version and rightly
  27++88E4              ; generates both note and volume tables outside of code block
  28++88E4              ; (in VARS).
  29++88E4              ;-Two portamento (spc. command 3xxx) algorithms (depending of
  30++88E4              ; PT3 module version).
  31++88E4              ;-New 1.XX and 2.XX special command behaviour (only for PT v3.7
  32++88E4              ; and higher).
  33++88E4              ;-Any Tempo value are accepted (including Tempo=1 and Tempo=2).
  34++88E4              ;-TS modes: 2xPT3, 2xPT2 and PT v3.7 TS standard.
  35++88E4              ;-Fully compatible with Ay_Emul PT3 and PT2 players codes.
  36++88E4              ;-See also notes at the end of this source code.
  37++88E4
  38++88E4              ;Limitations
  39++88E4              ;-----------
  40++88E4              ;-Can run in RAM only (self-modified code is used).
  41++88E4              ;-PT2 position list must be end by #FF marker only.
  42++88E4
  43++88E4              ;Warning!!! PLAY subprogram can crash if no module are loaded
  44++88E4              ;into RAM or INIT subprogram was not called before.
  45++88E4
  46++88E4              ;Call MUTE or INIT one more time to mute sound after stopping
  47++88E4              ;playing
  48++88E4
  49++88E4              ;Test codes (commented)
  50++88E4              ;	LD A,32 ;SinglePT3(TS if TSPT3.7),ABC,Looped
  51++88E4              ;	LD (START+10),A
  52++88E4              ;	LD HL,#8000 ;Mod1
  53++88E4              ;	LD DE,#A000 ;Mod2 (optional)
  54++88E4              ;	CALL START+3
  55++88E4              ;	EI
  56++88E4              ;_LP	HALT
  57++88E4              ;	CALL START+5
  58++88E4              ;	XOR A
  59++88E4              ;	IN A,(#FE)
  60++88E4              ;	CPL
  61++88E4              ;	AND 15
  62++88E4              ;	JR Z,_LP
  63++88E4              ;	JR START+8
  64++88E4
  65++88E4              TonA	EQU 0
  66++88E4              TonB	EQU 2
  67++88E4              TonC	EQU 4
  68++88E4              Noise	EQU 6
  69++88E4              Mixer	EQU 7
  70++88E4              AmplA	EQU 8
  71++88E4              AmplB	EQU 9
  72++88E4              AmplC	EQU 10
  73++88E4              Env	EQU 11
  74++88E4              EnvTp	EQU 13
  75++88E4
  76++88E4              ;Entry and other points
  77++88E4              ;START initialize playing of modules at MDLADDR (single module)
  78++88E4              ;START+3 initialization with module address in HL and DE (TS)
  79++88E4              ;START+5 play one quark
  80++88E4              ;START+8 mute
  81++88E4              ;START+10 setup and status flags
  82++88E4
  83++88E4              START:
  84++88E4 21 FF 94     	LD HL,outputBuffer ;DE - address of 2nd module for TS
  85++88E7 18 3C        	JR INIT
  86++88E9 C3 48 91     	JP PLAY
  87++88EC 18 25        	JR MUTE
  88++88EE 00           SETUP	DB 0 ;set bit0, if you want to play without looping
  89++88EF              	     ;(optional);
  90++88EF              	     ;set bit1 for PT2 and reset for PT3 before
  91++88EF              	     ;calling INIT;
  92++88EF              	     ;bits2-3: %00-ABC, %01-ACB, %10-BAC (optional);
  93++88EF              	     ;bits4-5: %00-no TS, %01-2 modules TS, %10-
  94++88EF              	     ;autodetect PT3 TS-format by AlCo (PT 3.7+);
  95++88EF              	     ;Remark: old PT3 TS-format by AlCo (PT 3.6) is not
  96++88EF              	     ;documented and must be converted to new standard.
  97++88EF              	     ;bit6 is set each time, when loop point of 2nd TS
  98++88EF              	     ;module is passed (optional).
  99++88EF              	     ;bit7 is set each time, when loop point of 1st TS
 100++88EF              	     ;or of single module is passed (optional).
 101++88EF
 102++88EF              ;Identifier
 103++88EF              	IF Id
 104++88EF ~            	DB "=UniPT2/PT3/TS-Player r.",Release,"="
 105++88EF              	ENDIF
 106++88EF
 107++88EF              	IF LoopChecker
 108++88EF 21 EE 88     CHECKLP	LD HL,SETUP
 109++88F2 FD CB 9E 46  	BIT 0,(IY-100+VRS.ModNum)
 110++88F6 28 04        	JR Z,CHL1
 111++88F8 CB F6        	SET 6,(HL)
 112++88FA 18 02        	JR CHL2
 113++88FC CB FE        CHL1	SET 7,(HL)
 114++88FE CB 46        CHL2	BIT 0,(HL)
 115++8900 C8           	RET Z
 116++8901 E1           	POP HL
 117++8902 FD 34 09     	INC (IY-100+VRS.DelyCnt)
 118++8905 FD 34 BA     	INC (IY-100+VRS.ChanA+CHP.NtSkCn)
 119++8908 AF           	XOR A
 120++8909 FD 77 1D     	LD (IY-100+VRS.AYREGS+AmplA),A
 121++890C FD 77 1E     	LD (IY-100+VRS.AYREGS+AmplB),A
 122++890F FD 77 1F     	LD (IY-100+VRS.AYREGS+AmplC),A
 123++8912 C9           	RET
 124++8913              	ENDIF
 125++8913
 126++8913 AF           MUTE: XOR A
 127++8914 67           	LD H,A
 128++8915 6F           	LD L,A
 129++8916 32 9D 92     	LD (VARS1+VRS.AYREGS+AmplA),A
 130++8919 22 9E 92     	LD (VARS1+VRS.AYREGS+AmplB),HL
 131++891C 32 24 93     	LD (VARS2+VRS.AYREGS+AmplA),A
 132++891F 22 25 93     	LD (VARS2+VRS.AYREGS+AmplB),HL
 133++8922 C3 60 91     	JP ROUT
 134++8925
 135++8925              INIT:
 136++8925              ;HL - AddressOfModule
 137++8925              ;DE - AddresOf2ndModule
 138++8925 D5           	PUSH DE
 139++8926 E5           	PUSH HL
 140++8927 21 1B 92     	LD HL,VARS
 141++892A 36 00        	LD (HL),0
 142++892C 11 1C 92     	LD DE,VARS+1
 143++892F 01 0E 01     	LD BC,VAR0END-VARS-1
 144++8932 ED B0        	LDIR
 145++8934 23           	INC HL
 146++8935 22 7E 92     	LD (VARS1+VRS.AdInPtA),HL ;ptr to zero
 147++8938 22 05 93     	LD (VARS2+VRS.AdInPtA),HL
 148++893B
 149++893B E1           	POP HL
 150++893C FD 21 80 92  	LD IY,VARS1+100
 151++8940 3A EE 88     	LD A,(START+10)
 152++8943 E6 02        	AND 2
 153++8945 C2 CE 89     	JP NZ,I_PT2
 154++8948
 155++8948 CD 1B 8B     	CALL INITPT3
 156++894B 21 18 1F     	LD HL,(e_-SamCnv-2)*256+#18
 157++894E 22 EE 8E     	LD (SamCnv),HL
 158++8951 3E BA        	LD A,#BA
 159++8953 32 B9 8E     	LD (OrnCP),A
 160++8956 32 E5 8E     	LD (SamCP),A
 161++8959 3E 7B        	LD A,#7B
 162++895B 32 BC 8E     	LD (OrnLD),A
 163++895E 32 E8 8E     	LD (SamLD),A
 164++8961 3E 87        	LD A,#87
 165++8963 32 DF 8E     	LD (SamClc2),A
 166++8966 E1           	POP HL
 167++8967              	;Use version and ton table of 1st module
 168++8967 DD 7E A9     	LD A,(IX+13-100) ;EXTRACT VERSION NUMBER
 169++896A D6 30        	SUB #30
 170++896C 38 04        	JR C,L20
 171++896E FE 0A        	CP 10
 172++8970 38 02        	JR C,L21
 173++8972 3E 06        L20	LD A,6
 174++8974 32 8C 8D     L21	LD (Version),A
 175++8977 F5           	PUSH AF ;VolTable version
 176++8978 FE 04        	CP 4
 177++897A DD 7E FF     	LD A,(IX+99-100) ;TONE TABLE NUMBER
 178++897D 17           	RLA
 179++897E E6 07        	AND 7
 180++8980 F5           	PUSH AF ;NoteTable number
 181++8981
 182++8981 FD 21 07 93  	LD IY,VARS2+100
 183++8985 3A EE 88     	LD A,(START+10)
 184++8988 E6 30        	AND 48
 185++898A 28 37        	JR Z,NOTS
 186++898C FE 10        	CP 16
 187++898E 28 27        	JR Z,TwoPT3s
 188++8990 3A 8C 8D     	LD A,(Version)
 189++8993 FE 07        	CP 7
 190++8995 38 2C        	JR C,NOTS
 191++8997 DD 7E FE     	LD A,(IX+98-100) ;ALCO TS MARKER
 192++899A FE 20        	CP #20
 193++899C 28 25        	JR Z,NOTS
 194++899E 21 1C 92     	LD HL,VARS1
 195++89A1 11 A3 92     	LD DE,VARS2
 196++89A4 01 87 00     	LD BC,VRS
 197++89A7 ED B0        	LDIR
 198++89A9 FD CB 9E CE  	SET 1,(IY-100+VRS.ModNum)
 199++89AD 4F           	LD C,A
 200++89AE 87           	ADD A,A
 201++89AF 81           	ADD A,C
 202++89B0 D6 02        	SUB 2
 203++89B2 32 53 90     	LD (TSSub),A
 204++89B5 18 03        	JR AlCoTS_
 205++89B7 CD 1B 8B     TwoPT3s	CALL INITPT3
 206++89BA 3E 01        AlCoTS_	LD A,1
 207++89BC 32 1B 92     	LD (is_ts),A
 208++89BF FD CB 9E C6  	SET 0,(IY-100+VRS.ModNum)
 209++89C3
 210++89C3 01 D8 8C     NOTS	LD BC,PT3PD
 211++89C6 21 00 00     	LD HL,0
 212++89C9 11 E3 91     	LD DE,PT3EMPTYORN
 213++89CC 18 48        	JR INITCOMMON
 214++89CE
 215++89CE CD 53 8B     I_PT2	CALL INITPT2
 216++89D1 21 CB 51     	LD HL,#51CB
 217++89D4 22 EE 8E     	LD (SamCnv),HL
 218++89D7 3E BB        	LD A,#BB
 219++89D9 32 B9 8E     	LD (OrnCP),A
 220++89DC 32 E5 8E     	LD (SamCP),A
 221++89DF 3E 7A        	LD A,#7A
 222++89E1 32 BC 8E     	LD (OrnLD),A
 223++89E4 32 E8 8E     	LD (SamLD),A
 224++89E7 3E 80        	LD A,#80
 225++89E9 32 DF 8E     	LD (SamClc2),A
 226++89EC E1           	POP HL
 227++89ED 3E 05        	LD A,5
 228++89EF 32 8C 8D     	LD (Version),A
 229++89F2 F5           	PUSH AF
 230++89F3 3E 02        	LD A,2
 231++89F5 F5           	PUSH AF
 232++89F6
 233++89F6 3A EE 88     	LD A,(START+10)
 234++89F9 E6 30        	AND 48
 235++89FB 28 10        	JR Z,NOTS2
 236++89FD
 237++89FD FD 21 07 93  	LD IY,VARS2+100
 238++8A01 3E 01        	LD A,1
 239++8A03 32 1B 92     	LD (is_ts),A
 240++8A06 FD CB 9E C6  	SET 0,(IY-100+VRS.ModNum)
 241++8A0A CD 53 8B     	CALL INITPT2
 242++8A0D
 243++8A0D 01 12 8C     NOTS2	LD BC,PT2PD
 244++8A10 21 87 86     	LD HL,#8687
 245++8A13 11 39 93     	LD DE,PT2EMPTYORN
 246++8A16
 247++8A16              INITCOMMON
 248++8A16
 249++8A16              	IF Basic
 250++8A16 FD 21 3A 5C  	LD IY,#5C3A
 251++8A1A              	ENDIF
 252++8A1A
 253++8A1A ED 43 C3 8B  	LD (PTDEC),BC
 254++8A1E 22 55 90     	LD (PsCalc),HL
 255++8A21 D5           	PUSH DE
 256++8A22
 257++8A22              ;note table data depacker
 258++8A22              ;(c) Ivan Roshin
 259++8A22 11 E6 91     	LD DE,T_PACK
 260++8A25 01 8B 93     	LD BC,T1_+(2*49)-1
 261++8A28 1A           TP_0	LD A,(DE)
 262++8A29 13           	INC DE
 263++8A2A FE 1E        	CP 15*2
 264++8A2C 30 06        	JR NC,TP_1
 265++8A2E 67           	LD H,A
 266++8A2F 1A           	LD A,(DE)
 267++8A30 6F           	LD L,A
 268++8A31 13           	INC DE
 269++8A32 18 07        	JR TP_2
 270++8A34 D5           TP_1	PUSH DE
 271++8A35 16 00        	LD D,0
 272++8A37 5F           	LD E,A
 273++8A38 19           	ADD HL,DE
 274++8A39 19           	ADD HL,DE
 275++8A3A D1           	POP DE
 276++8A3B 7C           TP_2	LD A,H
 277++8A3C 02           	LD (BC),A
 278++8A3D 0B           	DEC BC
 279++8A3E 7D           	LD A,L
 280++8A3F 02           	LD (BC),A
 281++8A40 0B           	DEC BC
player.asm(282): warning: value 0x1F0 is truncated to 8bit value: 0xF0
 282++8A41 D6 F0        	SUB #F8*2
 283++8A43 20 E3        	JR NZ,TP_0
 284++8A45
 285++8A45 3C           	INC A
 286++8A46 32 89 92     	LD (VARS1+VRS.DelyCnt),A
 287++8A49 32 10 93     	LD (VARS2+VRS.DelyCnt),A
 288++8A4C 21 01 F0     	LD HL,#F001 ;H - CHP.Volume, L - CHP.NtSkCn
 289++8A4F 22 3A 92     	LD (VARS1+VRS.ChanA+CHP.NtSkCn),HL
 290++8A52 22 57 92     	LD (VARS1+VRS.ChanB+CHP.NtSkCn),HL
 291++8A55 22 74 92     	LD (VARS1+VRS.ChanC+CHP.NtSkCn),HL
 292++8A58 22 C1 92     	LD (VARS2+VRS.ChanA+CHP.NtSkCn),HL
 293++8A5B 22 DE 92     	LD (VARS2+VRS.ChanB+CHP.NtSkCn),HL
 294++8A5E 22 FB 92     	LD (VARS2+VRS.ChanC+CHP.NtSkCn),HL
 295++8A61 E1           	POP HL
 296++8A62 22 2C 92     	LD (VARS1+VRS.ChanA+CHP.OrnPtr),HL
 297++8A65 22 49 92     	LD (VARS1+VRS.ChanB+CHP.OrnPtr),HL
 298++8A68 22 66 92     	LD (VARS1+VRS.ChanC+CHP.OrnPtr),HL
 299++8A6B 22 B3 92     	LD (VARS2+VRS.ChanA+CHP.OrnPtr),HL
 300++8A6E 22 D0 92     	LD (VARS2+VRS.ChanB+CHP.OrnPtr),HL
 301++8A71 22 ED 92     	LD (VARS2+VRS.ChanC+CHP.OrnPtr),HL
 302++8A74
 303++8A74 F1           	POP AF
 304++8A75
 305++8A75              ;NoteTableCreator (c) Ivan Roshin
 306++8A75              ;A - NoteTableNumber*2+VersionForNoteTable
 307++8A75              ;(xx1b - 3.xx..3.4r, xx0b - 3.4x..3.6x..VTII1.0)
 308++8A75
 309++8A75 21 93 91     	LD HL,NT_DATA
 310++8A78 16 00        	LD D,0
 311++8A7A 87           	ADD A,A
 312++8A7B 5F           	LD E,A
 313++8A7C 19           	ADD HL,DE
 314++8A7D 5E           	LD E,(HL)
 315++8A7E 23           	INC HL
 316++8A7F CB 3B        	SRL E
 317++8A81 9F           	SBC A,A
 318++8A82 E6 A7        	AND #A7 ;#00 (NOP) or #A7 (AND A)
 319++8A84 32 AC 8A     	LD (L3),A
 320++8A87 EB           	EX DE,HL
 321++8A88 01 2A 93     	LD BC,T1_
 322++8A8B 09           	ADD HL,BC
 323++8A8C
 324++8A8C 1A           	LD A,(DE)
player.asm(325): warning: value 0x91A3 is truncated to 8bit value: 0xA3
 325++8A8D C6 A3        	ADD A,T_
 326++8A8F 4F           	LD C,A
 327++8A90 CE 91        	ADC A,T_/256
 328++8A92 91           	SUB C
 329++8A93 47           	LD B,A
 330++8A94 C5           	PUSH BC
 331++8A95 11 1A 94     	LD DE,NT_
 332++8A98 D5           	PUSH DE
 333++8A99
 334++8A99 06 0C        	LD B,12
 335++8A9B C5           L1	PUSH BC
 336++8A9C 4E           	LD C,(HL)
 337++8A9D 23           	INC HL
 338++8A9E E5           	PUSH HL
 339++8A9F 46           	LD B,(HL)
 340++8AA0
 341++8AA0 D5           	PUSH DE
 342++8AA1 EB           	EX DE,HL
 343++8AA2 11 17 00     	LD DE,23
 344++8AA5 DD 26 08     	LD IXH,8
 345++8AA8
 346++8AA8 CB 38        L2	SRL B
 347++8AAA CB 19        	RR C
 348++8AAC 19           L3	DB #19	;AND A or NOP
 349++8AAD 79           	LD A,C
 350++8AAE 8A           	ADC A,D	;=ADC 0
 351++8AAF 77           	LD (HL),A
 352++8AB0 23           	INC HL
 353++8AB1 78           	LD A,B
 354++8AB2 8A           	ADC A,D
 355++8AB3 77           	LD (HL),A
 356++8AB4 19           	ADD HL,DE
 357++8AB5 DD 25        	DEC IXH
 358++8AB7 20 EF        	JR NZ,L2
 359++8AB9
 360++8AB9 D1           	POP DE
 361++8ABA 13           	INC DE
 362++8ABB 13           	INC DE
 363++8ABC E1           	POP HL
 364++8ABD 23           	INC HL
 365++8ABE C1           	POP BC
 366++8ABF 10 DA        	DJNZ L1
 367++8AC1
 368++8AC1 E1           	POP HL
 369++8AC2 D1           	POP DE
 370++8AC3
 371++8AC3 7B           	LD A,E
player.asm(372): warning: value 0x91AF is truncated to 8bit value: 0xAF
 372++8AC4 FE AF        	CP TCOLD_1
 373++8AC6 20 05        	JR NZ,CORR_1
 374++8AC8 3E FD        	LD A,#FD
 375++8ACA 32 48 94     	LD (NT_+#2E),A
 376++8ACD
 377++8ACD 1A           CORR_1	LD A,(DE)
 378++8ACE A7           	AND A
 379++8ACF 28 11        	JR Z,TC_EXIT
 380++8AD1 1F           	RRA
 381++8AD2 F5           	PUSH AF
 382++8AD3 87           	ADD A,A
 383++8AD4 4F           	LD C,A
 384++8AD5 09           	ADD HL,BC
 385++8AD6 F1           	POP AF
 386++8AD7 30 02        	JR NC,CORR_2
 387++8AD9 35           	DEC (HL)
 388++8ADA 35           	DEC (HL)
 389++8ADB 34           CORR_2	INC (HL)
 390++8ADC A7           	AND A
 391++8ADD ED 42        	SBC HL,BC
 392++8ADF 13           	INC DE
 393++8AE0 18 EB        	JR CORR_1
 394++8AE2
 395++8AE2              TC_EXIT
 396++8AE2
 397++8AE2 F1           	POP AF
 398++8AE3
 399++8AE3              ;VolTableCreator (c) Ivan Roshin
 400++8AE3              ;A - VersionForVolumeTable (0..4 - 3.xx..3.4x;
 401++8AE3              			   ;5.. - 2.x,3.5x..3.6x..VTII1.0)
 402++8AE3
 403++8AE3 FE 05        	CP 5
 404++8AE5 21 11 00     	LD HL,#11
 405++8AE8 54           	LD D,H
 406++8AE9 5C           	LD E,H
 407++8AEA 3E 17        	LD A,#17
 408++8AEC 30 03        	JR NC,M1
 409++8AEE 2D           	DEC L
 410++8AEF 5D           	LD E,L
 411++8AF0 AF           	XOR A
 412++8AF1 32 02 8B     M1      LD (M2),A
 413++8AF4
 414++8AF4 DD 21 2A 93  	LD IX,VT_+16
 415++8AF8
 416++8AF8 0E 0F        	LD C,#F
 417++8AFA E5           INITV2  PUSH HL
 418++8AFB
 419++8AFB 19           	ADD HL,DE
 420++8AFC EB           	EX DE,HL
 421++8AFD ED 62        	SBC HL,HL
 422++8AFF
 423++8AFF 06 10        	LD B,#10
 424++8B01 7D           INITV1  LD A,L
 425++8B02 7D           M2      DB #7D
 426++8B03 7C           	LD A,H
 427++8B04 CE 00        	ADC A,0
 428++8B06 DD 77 00     	LD (IX),A
 429++8B09 DD 23        	INC IX
 430++8B0B 19           	ADD HL,DE
 431++8B0C 10 F3        	DJNZ INITV1
 432++8B0E
 433++8B0E E1           	POP HL
 434++8B0F 7B           	LD A,E
 435++8B10 FE 77        	CP #77
 436++8B12 20 01        	JR NZ,M3
 437++8B14 1C           	INC E
 438++8B15 0D           M3      DEC C
 439++8B16 20 E2        	JR NZ,INITV2
 440++8B18
 441++8B18 C3 60 91     	JP ROUT
 442++8B1B
 443++8B1B CD 8E 8B     INITPT3	CALL SETMDAD
 444++8B1E E5           	PUSH HL
 445++8B1F 11 64 00     	LD DE,100
 446++8B22 19           	ADD HL,DE
 447++8B23 7E           	LD A,(HL)
 448++8B24 FD 77 08     	LD (IY-100+VRS.Delay),A
 449++8B27 E5           	PUSH HL
 450++8B28 DD E1        	POP IX
 451++8B2A 19           	ADD HL,DE
 452++8B2B CD 9C 8B     	CALL SETCPPT
 453++8B2E DD 5E 02     	LD E,(IX+102-100)
 454++8B31 23           	INC HL
 455++8B32
 456++8B32              	IF CurPosCounter
 457++8B32 ~            	LD (IY-100+VRS.PosSub),L
 458++8B32              	ENDIF
 459++8B32
 460++8B32 19           	ADD HL,DE
 461++8B33 CD A3 8B     	CALL SETLPPT
 462++8B36 D1           	POP DE
 463++8B37 DD 6E 03     	LD L,(IX+103-100)
 464++8B3A DD 66 04     	LD H,(IX+104-100)
 465++8B3D 19           	ADD HL,DE
 466++8B3E CD 87 8B     	CALL SETPTPT
 467++8B41 21 A9 00     	LD HL,169
 468++8B44 19           	ADD HL,DE
 469++8B45 CD 95 8B     	CALL SETORPT
 470++8B48 21 69 00     	LD HL,105
 471++8B4B 19           	ADD HL,DE
 472++8B4C
 473++8B4C FD 75 FA     SETSMPT LD (IY-100+VRS.SamPtrs),L
 474++8B4F FD 74 FB     	LD (IY-100+VRS.SamPtrs+1),H
 475++8B52 C9           	RET
 476++8B53
 477++8B53 7E           INITPT2	LD A,(HL)
 478++8B54 FD 77 08     	LD (IY-100+VRS.Delay),A
 479++8B57 E5           	PUSH HL
 480++8B58 E5           	PUSH HL
 481++8B59 E5           	PUSH HL
 482++8B5A 23           	INC HL
 483++8B5B 23           	INC HL
 484++8B5C 7E           	LD A,(HL)
 485++8B5D 23           	INC HL
 486++8B5E CD 4C 8B     	CALL SETSMPT
 487++8B61 5E           	LD E,(HL)
 488++8B62 23           	INC HL
 489++8B63 56           	LD D,(HL)
 490++8B64 E1           	POP HL
 491++8B65 A7           	AND A
 492++8B66 ED 52        	SBC HL,DE
 493++8B68 CD 8E 8B     	CALL SETMDAD
 494++8B6B E1           	POP HL
 495++8B6C 11 43 00     	LD DE,67
 496++8B6F 19           	ADD HL,DE
 497++8B70 CD 95 8B     	CALL SETORPT
 498++8B73 1E 20        	LD E,32
 499++8B75 19           	ADD HL,DE
 500++8B76 4E           	LD C,(HL)
 501++8B77 23           	INC HL
 502++8B78 46           	LD B,(HL)
 503++8B79 1E 1E        	LD E,30
 504++8B7B 19           	ADD HL,DE
 505++8B7C CD 9C 8B     	CALL SETCPPT
 506++8B7F 5F           	LD E,A
 507++8B80 23           	INC HL
 508++8B81
 509++8B81              	IF CurPosCounter
 510++8B81 ~            	LD (IY-100+VRS.PosSub),L
 511++8B81              	ENDIF
 512++8B81
 513++8B81 19           	ADD HL,DE
 514++8B82 CD A3 8B     	CALL SETLPPT
 515++8B85 E1           	POP HL
 516++8B86 09           	ADD HL,BC
 517++8B87
 518++8B87 FD 75 FC     SETPTPT	LD (IY-100+VRS.PatsPtr),L
 519++8B8A FD 74 FD     	LD (IY-100+VRS.PatsPtr+1),H
 520++8B8D C9           	RET
 521++8B8E
 522++8B8E FD 75 F6     SETMDAD	LD (IY-100+VRS.MODADDR),L
 523++8B91 FD 74 F7     	LD (IY-100+VRS.MODADDR+1),H
 524++8B94 C9           	RET
 525++8B95
 526++8B95 FD 75 F8     SETORPT	LD (IY-100+VRS.OrnPtrs),L
 527++8B98 FD 74 F9     	LD (IY-100+VRS.OrnPtrs+1),H
 528++8B9B C9           	RET
 529++8B9C
 530++8B9C FD 75 04     SETCPPT	LD (IY-100+VRS.CrPsPtr),L
 531++8B9F FD 74 05     	LD (IY-100+VRS.CrPsPtr+1),H
 532++8BA2 C9           	RET
 533++8BA3
 534++8BA3 FD 75 06     SETLPPT	LD (IY-100+VRS.LPosPtr),L
 535++8BA6 FD 74 07     	LD (IY-100+VRS.LPosPtr+1),H
 536++8BA9 C9           	RET
 537++8BAA
 538++8BAA FD 75 13     SETENBS	LD (IY-100+VRS.EnvBase),L
 539++8BAD FD 74 14     	LD (IY-100+VRS.EnvBase+1),H
 540++8BB0 C9           	RET
 541++8BB1
 542++8BB1 FD 75 0C     SETESLD	LD (IY-100+VRS.CurESld),L
 543++8BB4 FD 74 0D     	LD (IY-100+VRS.CurESld+1),H
 544++8BB7 C9           	RET
 545++8BB8
 546++8BB8 FD E5        GETIX	PUSH IY
 547++8BBA DD E1        	POP IX
 548++8BBC DD 19        	ADD IX,DE
 549++8BBE C9           	RET
 550++8BBF
 551++8BBF CD B8 8B     PTDECOD CALL GETIX
 552++8BC2              PTDEC	EQU $+1
 553++8BC2 C3 C3 C3     	JP #C3C3
 554++8BC5
 555++8BC5              ;PT2 pattern decoder
 556++8BC5 CD 5B 8E     PD2_SAM	CALL SETSAM
 557++8BC8 18 4A        	JR PD2_LOOP
 558++8BCA
 559++8BCA DD 77 08     PD2_EOff LD (IX-12+CHP.Env_En),A
 560++8BCD 18 45        	JR PD2_LOOP
 561++8BCF
 562++8BCF DD 36 08 10  PD2_ENV	LD (IX-12+CHP.Env_En),16
 563++8BD3 FD 77 22     	LD (IY-100+VRS.AYREGS+EnvTp),A
 564++8BD6 0A           	LD A,(BC)
 565++8BD7 03           	INC BC
 566++8BD8 6F           	LD L,A
 567++8BD9 0A           	LD A,(BC)
 568++8BDA 03           	INC BC
 569++8BDB 67           	LD H,A
 570++8BDC CD AA 8B     	CALL SETENBS
 571++8BDF 18 33        	JR PD2_LOOP
 572++8BE1
 573++8BE1 CD 3C 8E     PD2_ORN	CALL SETORN
 574++8BE4 18 2E        	JR PD2_LOOP
 575++8BE6
 576++8BE6 3C           PD2_SKIP INC A
 577++8BE7 DD 77 05     	LD (IX-12+CHP.NNtSkp),A
 578++8BEA 18 28        	JR PD2_LOOP
 579++8BEC
 580++8BEC 0F           PD2_VOL	RRCA
 581++8BED 0F           	RRCA
 582++8BEE 0F           	RRCA
 583++8BEF 0F           	RRCA
 584++8BF0 DD 77 10     	LD (IX-12+CHP.Volume),A
 585++8BF3 18 1F        	JR PD2_LOOP
 586++8BF5
 587++8BF5 CD 0C 8E     PD2_DEL	CALL C_DELAY
 588++8BF8 18 1A        	JR PD2_LOOP
 589++8BFA
 590++8BFA DD CB 09 D6  PD2_GLIS SET 2,(IX-12+CHP.Flags)
 591++8BFE 3C           	INC A
 592++8BFF DD 77 0A     	LD (IX-12+CHP.TnSlDl),A
 593++8C02 DD 77 F9     	LD (IX-12+CHP.TSlCnt),A
 594++8C05 0A           	LD A,(BC)
 595++8C06 03           	INC BC
 596++8C07 DD 77 0B             LD (IX-12+CHP.TSlStp),A
 597++8C0A 87           	ADD A,A
 598++8C0B 9F           	SBC A,A
 599++8C0C DD 77 0C             LD (IX-12+CHP.TSlStp+1),A
 600++8C0F 37           	SCF
 601++8C10 18 01        	JR PD2_LP2
 602++8C12
 603++8C12 A7           PT2PD	AND A
 604++8C13
 605++8C13 08           PD2_LP2	EX AF,AF'
 606++8C14
 607++8C14 0A           PD2_LOOP LD A,(BC)
 608++8C15 03           	INC BC
 609++8C16 C6 20        	ADD A,#20
 610++8C18 28 3F        	JR Z,PD2_REL
 611++8C1A 38 A9        	JR C,PD2_SAM
 612++8C1C C6 60        	ADD A,96
 613++8C1E 38 3E        	JR C,PD2_NOTE
 614++8C20 3C           	INC A
 615++8C21 28 A7        	JR Z,PD2_EOff
 616++8C23 C6 0F        	ADD A,15
 617++8C25 CA 3B 8D     	JP Z,PD_FIN
 618++8C28 38 A5        	JR C,PD2_ENV
 619++8C2A C6 10        	ADD A,#10
 620++8C2C 38 B3        	JR C,PD2_ORN
 621++8C2E C6 40        	ADD A,#40
 622++8C30 38 B4        	JR C,PD2_SKIP
 623++8C32 C6 10        	ADD A,#10
 624++8C34 38 B6        	JR C,PD2_VOL
 625++8C36 3C           	INC A
 626++8C37 28 BC        	JR Z,PD2_DEL
 627++8C39 3C           	INC A
 628++8C3A 28 BE        	JR Z,PD2_GLIS
 629++8C3C 3C           	INC A
 630++8C3D 28 0A        	JR Z,PD2_PORT
 631++8C3F 3C           	INC A
 632++8C40 28 12        	JR Z,PD2_STOP
 633++8C42 0A           	LD A,(BC)
 634++8C43 03           	INC BC
 635++8C44 DD 77 F7     	LD (IX-12+CHP.CrNsSl),A
 636++8C47 18 CB        	JR PD2_LOOP
 637++8C49
 638++8C49 DD CB 09 96  PD2_PORT RES 2,(IX-12+CHP.Flags)
 639++8C4D 0A           	LD A,(BC)
 640++8C4E 03           	INC BC
 641++8C4F 03           	INC BC ;ignoring precalc delta to right sound
 642++8C50 03           	INC BC
 643++8C51 37           	SCF
 644++8C52 18 BF        	JR PD2_LP2
 645++8C54
 646++8C54 DD 77 F9     PD2_STOP LD (IX-12+CHP.TSlCnt),A
 647++8C57 18 BB        	JR PD2_LOOP
 648++8C59
 649++8C59 DD 77 09     PD2_REL	LD (IX-12+CHP.Flags),A
 650++8C5C 18 2C        	JR PD2_EXIT
 651++8C5E
 652++8C5E 6F           PD2_NOTE LD L,A
 653++8C5F DD 7E 06     	LD A,(IX-12+CHP.Note)
 654++8C62 32 75 8D     	LD (PrNote+1),A
 655++8C65 DD 75 06     	LD (IX-12+CHP.Note),L
 656++8C68 AF           	XOR A
 657++8C69 DD 77 F9     	LD (IX-12+CHP.TSlCnt),A
 658++8C6C DD CB 09 C6  	SET 0,(IX-12+CHP.Flags)
 659++8C70 08           	EX AF,AF'
 660++8C71 30 16        	JR NC,NOGLIS2
 661++8C73 DD CB 09 56  	BIT 2,(IX-12+CHP.Flags)
 662++8C77 20 0C        	JR NZ,NOPORT2
 663++8C79 32 9B 8D     	LD (LoStep),A
 664++8C7C 87           	ADD A,A
 665++8C7D 9F           	SBC A,A
 666++8C7E 08           	EX AF,AF'
 667++8C7F 67           	LD H,A
 668++8C80 6F           	LD L,A
 669++8C81 3C           	INC A
 670++8C82 CD 56 8D     	CALL SETPORT
 671++8C85 DD 36 F9 01  NOPORT2	LD (IX-12+CHP.TSlCnt),1
 672++8C89 AF           NOGLIS2	XOR A
 673++8C8A
 674++8C8A
 675++8C8A DD 77 F5     PD2_EXIT LD (IX-12+CHP.PsInSm),A
 676++8C8D DD 77 F4     	LD (IX-12+CHP.PsInOr),A
 677++8C90 DD 77 FA     	LD (IX-12+CHP.CrTnSl),A
 678++8C93 DD 77 FB     	LD (IX-12+CHP.CrTnSl+1),A
 679++8C96 C3 3B 8D     	JP PD_FIN
 680++8C99
 681++8C99              ;PT3 pattern decoder
 682++8C99 DD 36 08 00  PD_OrSm	LD (IX-12+CHP.Env_En),0
 683++8C9D CD 3C 8E     	CALL SETORN
 684++8CA0 0A           PD_SAM_	LD A,(BC)
 685++8CA1 03           	INC BC
 686++8CA2 0F           	RRCA
 687++8CA3
 688++8CA3 CD 5B 8E     PD_SAM	CALL SETSAM
 689++8CA6 18 3F        	JR PD_LOOP
 690++8CA8
 691++8CA8 0F           PD_VOL	RRCA
 692++8CA9 0F           	RRCA
 693++8CAA 0F           	RRCA
 694++8CAB 0F           	RRCA
 695++8CAC DD 77 10     	LD (IX-12+CHP.Volume),A
 696++8CAF 18 39        	JR PD_LP2
 697++8CB1
 698++8CB1 DD 77 08     PD_EOff	LD (IX-12+CHP.Env_En),A
 699++8CB4 DD 77 F4     	LD (IX-12+CHP.PsInOr),A
 700++8CB7 18 31        	JR PD_LP2
 701++8CB9
 702++8CB9 3D           PD_SorE	DEC A
 703++8CBA 20 07        	JR NZ,PD_ENV
 704++8CBC 0A           	LD A,(BC)
 705++8CBD 03           	INC BC
 706++8CBE DD 77 05     	LD (IX-12+CHP.NNtSkp),A
 707++8CC1 18 27        	JR PD_LP2
 708++8CC3
 709++8CC3 CD 21 8E     PD_ENV	CALL SETENV
 710++8CC6 18 22        	JR PD_LP2
 711++8CC8
 712++8CC8 CD 3C 8E     PD_ORN	CALL SETORN
 713++8CCB 18 1A        	JR PD_LOOP
 714++8CCD
 715++8CCD DD 77 08     PD_ESAM	LD (IX-12+CHP.Env_En),A
 716++8CD0 DD 77 F4     	LD (IX-12+CHP.PsInOr),A
 717++8CD3 C4 21 8E     	CALL NZ,SETENV
 718++8CD6 18 C8        	JR PD_SAM_
 719++8CD8
 720++8CD8 DD 7E 06     PT3PD	LD A,(IX-12+CHP.Note)
 721++8CDB 32 75 8D     	LD (PrNote+1),A
 722++8CDE DD 6E FA     	LD L,(IX-12+CHP.CrTnSl)
 723++8CE1 DD 66 FB     	LD H,(IX-12+CHP.CrTnSl+1)
 724++8CE4 22 92 8D     	LD (PrSlide+1),HL
 725++8CE7
 726++8CE7 11 10 20     PD_LOOP	LD DE,#2010
 727++8CEA 0A           PD_LP2	LD A,(BC)
 728++8CEB 03           	INC BC
 729++8CEC 83           	ADD A,E
 730++8CED 38 AA        	JR C,PD_OrSm
 731++8CEF 82           	ADD A,D
 732++8CF0 28 49        	JR Z,PD_FIN
 733++8CF2 38 AF        	JR C,PD_SAM
 734++8CF4 83           	ADD A,E
 735++8CF5 28 25        	JR Z,PD_REL
 736++8CF7 38 AF        	JR C,PD_VOL
 737++8CF9 83           	ADD A,E
 738++8CFA 28 B5        	JR Z,PD_EOff
 739++8CFC 38 BB        	JR C,PD_SorE
 740++8CFE C6 60        	ADD A,96
 741++8D00 38 20        	JR C,PD_NOTE
 742++8D02 83           	ADD A,E
 743++8D03 38 C3        	JR C,PD_ORN
 744++8D05 82           	ADD A,D
 745++8D06 38 0F        	JR C,PD_NOIS
 746++8D08 83           	ADD A,E
 747++8D09 38 C2        	JR C,PD_ESAM
 748++8D0B 87           	ADD A,A
 749++8D0C 5F           	LD E,A
player.asm(750): warning: value 0x16D97 is truncated to 16bit value: 0x6D97
 750++8D0D 21 97 6D     	LD HL,SPCCOMS+#FF20-#2000
 751++8D10 19           	ADD HL,DE
 752++8D11 5E           	LD E,(HL)
 753++8D12 23           	INC HL
 754++8D13 56           	LD D,(HL)
 755++8D14 D5           	PUSH DE
 756++8D15 18 D0        	JR PD_LOOP
 757++8D17
 758++8D17 FD 77 10     PD_NOIS	LD (IY-100+VRS.Ns_Base),A
 759++8D1A 18 CE        	JR PD_LP2
 760++8D1C
 761++8D1C DD CB 09 86  PD_REL	RES 0,(IX-12+CHP.Flags)
 762++8D20 18 08        	JR PD_RES
 763++8D22
 764++8D22 DD 77 06     PD_NOTE	LD (IX-12+CHP.Note),A
 765++8D25 DD CB 09 C6  	SET 0,(IX-12+CHP.Flags)
 766++8D29 AF           	XOR A
 767++8D2A
 768++8D2A ED 73 39 8D  PD_RES	LD (PDSP_+1),SP
 769++8D2E DD F9        	LD SP,IX
 770++8D30 67           	LD H,A
 771++8D31 6F           	LD L,A
 772++8D32 E5           	PUSH HL
 773++8D33 E5           	PUSH HL
 774++8D34 E5           	PUSH HL
 775++8D35 E5           	PUSH HL
 776++8D36 E5           	PUSH HL
 777++8D37 E5           	PUSH HL
 778++8D38 31 31 31     PDSP_	LD SP,#3131
 779++8D3B
 780++8D3B DD 7E 05     PD_FIN	LD A,(IX-12+CHP.NNtSkp)
 781++8D3E DD 77 0F     	LD (IX-12+CHP.NtSkCn),A
 782++8D41 C9           	RET
 783++8D42
 784++8D42 0A           C_PORTM LD A,(BC)
 785++8D43 03           	INC BC
 786++8D44              ;SKIP PRECALCULATED TONE DELTA (BECAUSE
 787++8D44              ;CANNOT BE RIGHT AFTER PT3 COMPILATION)
 788++8D44 03           	INC BC
 789++8D45 03           	INC BC
 790++8D46 08           	EX AF,AF'
 791++8D47 0A           	LD A,(BC) ;SIGNED TONE STEP
 792++8D48 03           	INC BC
 793++8D49 32 9B 8D     	LD (LoStep),A
 794++8D4C 0A           	LD A,(BC)
 795++8D4D 03           	INC BC
 796++8D4E A7           	AND A
 797++8D4F 08           	EX AF,AF'
 798++8D50 DD 6E FA     	LD L,(IX-12+CHP.CrTnSl)
 799++8D53 DD 66 FB     	LD H,(IX-12+CHP.CrTnSl+1)
 800++8D56
 801++8D56              ;Set portamento variables
 802++8D56              ;A - Delay; A' - Hi(Step); ZF' - (A'=0); HL - CrTnSl
 803++8D56
 804++8D56 DD CB 09 96  SETPORT	RES 2,(IX-12+CHP.Flags)
 805++8D5A DD 77 0A     	LD (IX-12+CHP.TnSlDl),A
 806++8D5D DD 77 F9     	LD (IX-12+CHP.TSlCnt),A
 807++8D60 E5           	PUSH HL
 808++8D61 11 1A 94     	LD DE,NT_
 809++8D64 DD 7E 06     	LD A,(IX-12+CHP.Note)
 810++8D67 DD 77 07     	LD (IX-12+CHP.SlToNt),A
 811++8D6A 87           	ADD A,A
 812++8D6B 6F           	LD L,A
 813++8D6C 26 00        	LD H,0
 814++8D6E 19           	ADD HL,DE
 815++8D6F 7E           	LD A,(HL)
 816++8D70 23           	INC HL
 817++8D71 66           	LD H,(HL)
 818++8D72 6F           	LD L,A
 819++8D73 E5           	PUSH HL
 820++8D74 3E 3E        PrNote	LD A,#3E
 821++8D76 DD 77 06     	LD (IX-12+CHP.Note),A
 822++8D79 87           	ADD A,A
 823++8D7A 6F           	LD L,A
 824++8D7B 26 00        	LD H,0
 825++8D7D 19           	ADD HL,DE
 826++8D7E 5E           	LD E,(HL)
 827++8D7F 23           	INC HL
 828++8D80 56           	LD D,(HL)
 829++8D81 E1           	POP HL
 830++8D82 ED 52        	SBC HL,DE
 831++8D84 DD 75 0D     	LD (IX-12+CHP.TnDelt),L
 832++8D87 DD 74 0E     	LD (IX-12+CHP.TnDelt+1),H
 833++8D8A D1           	POP DE
 834++8D8B              Version EQU $+1
 835++8D8B 3E 3E        	LD A,#3E
 836++8D8D FE 06        	CP 6
 837++8D8F 38 09        	JR C,OLDPRTM ;Old 3xxx for PT v3.5-
 838++8D91 11 11 11     PrSlide	LD DE,#1111
 839++8D94 DD 73 FA     	LD (IX-12+CHP.CrTnSl),E
 840++8D97 DD 72 FB     	LD (IX-12+CHP.CrTnSl+1),D
 841++8D9A              LoStep	EQU $+1
 842++8D9A 3E 3E        OLDPRTM	LD A,#3E
 843++8D9C 08           	EX AF,AF'
 844++8D9D 28 01        	JR Z,NOSIG
 845++8D9F EB           	EX DE,HL
 846++8DA0 ED 52        NOSIG	SBC HL,DE
 847++8DA2 F2 AA 8D     	JP P,SET_STP
 848++8DA5 2F           	CPL
 849++8DA6 08           	EX AF,AF'
 850++8DA7 ED 44        	NEG
 851++8DA9 08           	EX AF,AF'
 852++8DAA DD 77 0C     SET_STP	LD (IX-12+CHP.TSlStp+1),A
 853++8DAD 08           	EX AF,AF'
 854++8DAE DD 77 0B     	LD (IX-12+CHP.TSlStp),A
 855++8DB1 DD 36 FE 00  	LD (IX-12+CHP.COnOff),0
 856++8DB5 C9           	RET
 857++8DB6
 858++8DB6 DD CB 09 D6  C_GLISS	SET 2,(IX-12+CHP.Flags)
 859++8DBA 0A           	LD A,(BC)
 860++8DBB 03           	INC BC
 861++8DBC DD 77 0A     	LD (IX-12+CHP.TnSlDl),A
 862++8DBF A7           	AND A
 863++8DC0 20 07        	JR NZ,GL36
 864++8DC2 3A 8C 8D     	LD A,(Version) ;AlCo PT3.7+
 865++8DC5 FE 07        	CP 7
 866++8DC7 9F           	SBC A,A
 867++8DC8 3C           	INC A
 868++8DC9 DD 77 F9     GL36	LD (IX-12+CHP.TSlCnt),A
 869++8DCC 0A           	LD A,(BC)
 870++8DCD 03           	INC BC
 871++8DCE 08           	EX AF,AF'
 872++8DCF 0A           	LD A,(BC)
 873++8DD0 03           	INC BC
 874++8DD1 18 D7        	JR SET_STP
 875++8DD3
 876++8DD3 0A           C_SMPOS	LD A,(BC)
 877++8DD4 03           	INC BC
 878++8DD5 DD 77 F5     	LD (IX-12+CHP.PsInSm),A
 879++8DD8 C9           	RET
 880++8DD9
 881++8DD9 0A           C_ORPOS	LD A,(BC)
 882++8DDA 03           	INC BC
 883++8DDB DD 77 F4     	LD (IX-12+CHP.PsInOr),A
 884++8DDE C9           	RET
 885++8DDF
 886++8DDF 0A           C_VIBRT	LD A,(BC)
 887++8DE0 03           	INC BC
 888++8DE1 DD 77 FF     	LD (IX-12+CHP.OnOffD),A
 889++8DE4 DD 77 FE     	LD (IX-12+CHP.COnOff),A
 890++8DE7 0A           	LD A,(BC)
 891++8DE8 03           	INC BC
 892++8DE9 DD 77 00     	LD (IX-12+CHP.OffOnD),A
 893++8DEC AF           	XOR A
 894++8DED DD 77 F9     	LD (IX-12+CHP.TSlCnt),A
 895++8DF0 DD 77 FA     	LD (IX-12+CHP.CrTnSl),A
 896++8DF3 DD 77 FB     	LD (IX-12+CHP.CrTnSl+1),A
 897++8DF6 C9           	RET
 898++8DF7
 899++8DF7 0A           C_ENGLS	LD A,(BC)
 900++8DF8 03           	INC BC
 901++8DF9 FD 77 0E     	LD (IY-100+VRS.Env_Del),A
 902++8DFC FD 77 0F     	LD (IY-100+VRS.CurEDel),A
 903++8DFF 0A           	LD A,(BC)
 904++8E00 03           	INC BC
 905++8E01 6F           	LD L,A
 906++8E02 0A           	LD A,(BC)
 907++8E03 03           	INC BC
 908++8E04 67           	LD H,A
 909++8E05 FD 75 0A     	LD (IY-100+VRS.ESldAdd),L
 910++8E08 FD 74 0B     	LD (IY-100+VRS.ESldAdd+1),H
 911++8E0B C9           	RET
 912++8E0C
 913++8E0C 0A           C_DELAY	LD A,(BC)
 914++8E0D 03           	INC BC
 915++8E0E FD 77 08     	LD (IY-100+VRS.Delay),A
 916++8E11 21 A5 92     	LD HL,VARS2+VRS.ModNum ;if AlCo_TS
 917++8E14 CB 4E        	BIT 1,(HL)
 918++8E16 C8           	RET Z
 919++8E17 32 88 92     	LD (VARS1+VRS.Delay),A
 920++8E1A 32 89 92     	LD (VARS1+VRS.DelyCnt),A
 921++8E1D 32 0F 93     	LD (VARS2+VRS.Delay),A
 922++8E20 C9           	RET
 923++8E21
 924++8E21 DD 73 08     SETENV	LD (IX-12+CHP.Env_En),E
 925++8E24 FD 77 22     	LD (IY-100+VRS.AYREGS+EnvTp),A
 926++8E27 0A           	LD A,(BC)
 927++8E28 03           	INC BC
 928++8E29 67           	LD H,A
 929++8E2A 0A           	LD A,(BC)
 930++8E2B 03           	INC BC
 931++8E2C 6F           	LD L,A
 932++8E2D CD AA 8B     	CALL SETENBS
 933++8E30 AF           	XOR A
 934++8E31 DD 77 F4     	LD (IX-12+CHP.PsInOr),A
 935++8E34 FD 77 0F     	LD (IY-100+VRS.CurEDel),A
 936++8E37 67           	LD H,A
 937++8E38 6F           	LD L,A
 938++8E39 C3 B1 8B     	JP SETESLD
 939++8E3C
 940++8E3C 87           SETORN	ADD A,A
 941++8E3D 5F           	LD E,A
 942++8E3E 16 00        	LD D,0
 943++8E40 DD 72 F4     	LD (IX-12+CHP.PsInOr),D
 944++8E43 FD 6E F8     	LD L,(IY-100+VRS.OrnPtrs)
 945++8E46 FD 66 F9     	LD H,(IY-100+VRS.OrnPtrs+1)
 946++8E49 19           	ADD HL,DE
 947++8E4A 5E           	LD E,(HL)
 948++8E4B 23           	INC HL
 949++8E4C 56           	LD D,(HL)
 950++8E4D FD 6E F6     	LD L,(IY-100+VRS.MODADDR)
 951++8E50 FD 66 F7     	LD H,(IY-100+VRS.MODADDR+1)
 952++8E53 19           	ADD HL,DE
 953++8E54 DD 75 01     	LD (IX-12+CHP.OrnPtr),L
 954++8E57 DD 74 02     	LD (IX-12+CHP.OrnPtr+1),H
 955++8E5A C9           C_NOP	RET
 956++8E5B
 957++8E5B 87           SETSAM	ADD A,A
 958++8E5C 5F           	LD E,A
 959++8E5D 16 00        	LD D,0
 960++8E5F FD 6E FA     	LD L,(IY-100+VRS.SamPtrs);
 961++8E62 FD 66 FB     	LD H,(IY-100+VRS.SamPtrs+1);
 962++8E65 19           	ADD HL,DE
 963++8E66 5E           	LD E,(HL)
 964++8E67 23           	INC HL
 965++8E68 56           	LD D,(HL)
 966++8E69 FD 6E F6     	LD L,(IY-100+VRS.MODADDR)
 967++8E6C FD 66 F7     	LD H,(IY-100+VRS.MODADDR+1)
 968++8E6F 19           	ADD HL,DE
 969++8E70 DD 75 03     	LD (IX-12+CHP.SamPtr),L
 970++8E73 DD 74 04     	LD (IX-12+CHP.SamPtr+1),H
 971++8E76 C9           	RET
 972++8E77
 973++8E77              ;ALL 16 ADDRESSES TO PROTECT FROM BROKEN PT3 MODULES
 974++8E77 5A 8E        SPCCOMS DW C_NOP
 975++8E79 B6 8D        	DW C_GLISS
 976++8E7B 42 8D        	DW C_PORTM
 977++8E7D D3 8D        	DW C_SMPOS
 978++8E7F D9 8D        	DW C_ORPOS
 979++8E81 DF 8D        	DW C_VIBRT
 980++8E83 5A 8E        	DW C_NOP
 981++8E85 5A 8E        	DW C_NOP
 982++8E87 F7 8D        	DW C_ENGLS
 983++8E89 0C 8E        	DW C_DELAY
 984++8E8B 5A 8E        	DW C_NOP
 985++8E8D 5A 8E        	DW C_NOP
 986++8E8F 5A 8E        	DW C_NOP
 987++8E91 5A 8E        	DW C_NOP
 988++8E93 5A 8E        	DW C_NOP
 989++8E95 5A 8E        	DW C_NOP
 990++8E97
 991++8E97 CD B8 8B     CHREGS	CALL GETIX
 992++8E9A AF           	XOR A
 993++8E9B 32 D7 90     	LD (Ampl),A
 994++8E9E DD CB 15 46  	BIT 0,(IX+CHP.Flags)
 995++8EA2 E5           	PUSH HL
 996++8EA3 CA EA 8F     	JP Z,CH_EXIT
 997++8EA6 ED 73 34 8F  	LD (CSP_+1),SP
 998++8EAA DD 6E 0D     	LD L,(IX+CHP.OrnPtr)
 999++8EAD DD 66 0E     	LD H,(IX+CHP.OrnPtr+1)
1000++8EB0 F9           	LD SP,HL
1001++8EB1 D1           	POP DE
1002++8EB2 67           	LD H,A
1003++8EB3 DD 7E 00     	LD A,(IX+CHP.PsInOr)
1004++8EB6 6F           	LD L,A
1005++8EB7 39           	ADD HL,SP
1006++8EB8 3C           	INC A
1007++8EB9              		;PT2	PT3
1008++8EB9 3C           OrnCP	INC A	;CP E	CP D
1009++8EBA 38 01        	JR C,CH_ORPS
1010++8EBC 01           OrnLD	DB 1	;LD A,D	LD A,E
1011++8EBD DD 77 00     CH_ORPS	LD (IX+CHP.PsInOr),A
1012++8EC0 DD 7E 12     	LD A,(IX+CHP.Note)
1013++8EC3 86           	ADD A,(HL)
1014++8EC4 F2 C8 8E     	JP P,CH_NTP
1015++8EC7 AF           	XOR A
1016++8EC8 FE 60        CH_NTP	CP 96
1017++8ECA 38 02        	JR C,CH_NOK
1018++8ECC 3E 5F        	LD A,95
1019++8ECE 87           CH_NOK	ADD A,A
1020++8ECF 08           	EX AF,AF'
1021++8ED0 DD 6E 0F     	LD L,(IX+CHP.SamPtr)
1022++8ED3 DD 66 10     	LD H,(IX+CHP.SamPtr+1)
1023++8ED6 F9           	LD SP,HL
1024++8ED7 D1           	POP DE
1025++8ED8 26 00        	LD H,0
1026++8EDA DD 7E 01     	LD A,(IX+CHP.PsInSm)
1027++8EDD 47           	LD B,A
1028++8EDE 87           	ADD A,A
1029++8EDF 87           SamClc2	ADD A,A ;or ADD A,B for PT2
1030++8EE0 6F           	LD L,A
1031++8EE1 39           	ADD HL,SP
1032++8EE2 F9           	LD SP,HL
1033++8EE3 78           	LD A,B
1034++8EE4 3C           	INC A
1035++8EE5              		;PT2	PT3
1036++8EE5 3C           SamCP	INC A	;CP E	CP D
1037++8EE6 38 01        	JR C,CH_SMPS
1038++8EE8 01           SamLD	DB 1	;LD A,D	LD A,E
1039++8EE9 DD 77 01     CH_SMPS	LD (IX+CHP.PsInSm),A
1040++8EEC C1           	POP BC
1041++8EED E1           	POP HL
1042++8EEE
1043++8EEE              ;Convert PT2 sample to PT3
1044++8EEE              		;PT2		PT3
1045++8EEE E1           SamCnv	POP HL  ;BIT 2,C	JR e_
1046++8EEF E1           	POP HL
1047++8EF0 60           	LD H,B
1048++8EF1 20 06        	JR NZ,$+8
1049++8EF3 EB           	EX DE,HL
1050++8EF4 A7           	AND A
1051++8EF5 ED 62        	SBC HL,HL
1052++8EF7 ED 52        	SBC HL,DE
1053++8EF9 51           	LD D,C
1054++8EFA CB 19        	RR C
1055++8EFC 9F           	SBC A,A
1056++8EFD 2F           	CPL
1057++8EFE E6 3E        	AND #3E
1058++8F00 CB 19        	RR C
1059++8F02 CB 18        	RR B
1060++8F04 A1           	AND C
1061++8F05 4F           	LD C,A
1062++8F06 78           	LD A,B
1063++8F07 1F           	RRA
1064++8F08 1F           	RRA
1065++8F09 CB 1A        	RR D
1066++8F0B 1F           	RRA
1067++8F0C E6 9F        	AND #9F
1068++8F0E 47           	LD B,A
1069++8F0F
1070++8F0F DD 5E 08     e_	LD E,(IX+CHP.TnAcc)
1071++8F12 DD 56 09     	LD D,(IX+CHP.TnAcc+1)
1072++8F15 19           	ADD HL,DE
1073++8F16 CB 70        	BIT 6,B
1074++8F18 28 06        	JR Z,CH_NOAC
1075++8F1A DD 75 08     	LD (IX+CHP.TnAcc),L
1076++8F1D DD 74 09     	LD (IX+CHP.TnAcc+1),H
1077++8F20 EB           CH_NOAC EX DE,HL
1078++8F21 08           	EX AF,AF'
player.asm(1079): warning: value 0x941A is truncated to 8bit value: 0x1A
1079++8F22 C6 1A        	ADD A,NT_
1080++8F24 6F           	LD L,A
1081++8F25 CE 94        	ADC A,NT_/256
1082++8F27 95           	SUB L
1083++8F28 67           	LD H,A
1084++8F29 F9           	LD SP,HL
1085++8F2A E1           	POP HL
1086++8F2B 19           	ADD HL,DE
1087++8F2C DD 5E 06     	LD E,(IX+CHP.CrTnSl)
1088++8F2F DD 56 07     	LD D,(IX+CHP.CrTnSl+1)
1089++8F32 19           	ADD HL,DE
1090++8F33 31 31 31     CSP_	LD SP,#3131
1091++8F36 E3           	EX (SP),HL
1092++8F37 AF           	XOR A
1093++8F38 DD B6 05     	OR (IX+CHP.TSlCnt)
1094++8F3B 28 3E        	JR Z,CH_AMP
1095++8F3D DD 35 05     	DEC (IX+CHP.TSlCnt)
1096++8F40 20 39        	JR NZ,CH_AMP
1097++8F42 DD 7E 16     	LD A,(IX+CHP.TnSlDl)
1098++8F45 DD 77 05     	LD (IX+CHP.TSlCnt),A
1099++8F48 DD 6E 17     	LD L,(IX+CHP.TSlStp)
1100++8F4B DD 66 18     	LD H,(IX+CHP.TSlStp+1)
1101++8F4E 7C           	LD A,H
1102++8F4F 19           	ADD HL,DE
1103++8F50 DD 75 06     	LD (IX+CHP.CrTnSl),L
1104++8F53 DD 74 07     	LD (IX+CHP.CrTnSl+1),H
1105++8F56 DD CB 15 56  	BIT 2,(IX+CHP.Flags)
1106++8F5A 20 1F        	JR NZ,CH_AMP
1107++8F5C DD 5E 19     	LD E,(IX+CHP.TnDelt)
1108++8F5F DD 56 1A     	LD D,(IX+CHP.TnDelt+1)
1109++8F62 A7           	AND A
1110++8F63 28 01        	JR Z,CH_STPP
1111++8F65 EB           	EX DE,HL
1112++8F66 ED 52        CH_STPP SBC HL,DE
1113++8F68 FA 7B 8F     	JP M,CH_AMP
1114++8F6B DD 7E 13     	LD A,(IX+CHP.SlToNt)
1115++8F6E DD 77 12     	LD (IX+CHP.Note),A
1116++8F71 AF           	XOR A
1117++8F72 DD 77 05     	LD (IX+CHP.TSlCnt),A
1118++8F75 DD 77 06     	LD (IX+CHP.CrTnSl),A
1119++8F78 DD 77 07     	LD (IX+CHP.CrTnSl+1),A
1120++8F7B DD 7E 02     CH_AMP	LD A,(IX+CHP.CrAmSl)
1121++8F7E CB 79        	BIT 7,C
1122++8F80 28 13        	JR Z,CH_NOAM
1123++8F82 CB 71        	BIT 6,C
1124++8F84 28 07        	JR Z,CH_AMIN
1125++8F86 FE 0F        	CP 15
1126++8F88 28 0B        	JR Z,CH_NOAM
1127++8F8A 3C           	INC A
1128++8F8B 18 05        	JR CH_SVAM
1129++8F8D FE F1        CH_AMIN	CP -15
1130++8F8F 28 04        	JR Z,CH_NOAM
1131++8F91 3D           	DEC A
1132++8F92 DD 77 02     CH_SVAM	LD (IX+CHP.CrAmSl),A
1133++8F95 6F           CH_NOAM	LD L,A
1134++8F96 78           	LD A,B
1135++8F97 E6 0F        	AND 15
1136++8F99 85           	ADD A,L
1137++8F9A F2 9E 8F     	JP P,CH_APOS
1138++8F9D AF           	XOR A
1139++8F9E FE 10        CH_APOS	CP 16
1140++8FA0 38 02        	JR C,CH_VOL
1141++8FA2 3E 0F        	LD A,15
1142++8FA4 DD B6 1C     CH_VOL	OR (IX+CHP.Volume)
player.asm(1143): warning: value 0x931A is truncated to 8bit value: 0x1A
1143++8FA7 C6 1A        	ADD A,VT_
1144++8FA9 6F           	LD L,A
1145++8FAA CE 93        	ADC A,VT_/256
1146++8FAC 95           	SUB L
1147++8FAD 67           	LD H,A
1148++8FAE 7E           	LD A,(HL)
1149++8FAF CB 41        CH_ENV	BIT 0,C
1150++8FB1 20 03        	JR NZ,CH_NOEN
1151++8FB3 DD B6 14     	OR (IX+CHP.Env_En)
1152++8FB6 32 D7 90     CH_NOEN	LD (Ampl),A
1153++8FB9 CB 78        	BIT 7,B
1154++8FBB 79           	LD A,C
1155++8FBC 28 1A        	JR Z,NO_ENSL
1156++8FBE 17           	RLA
1157++8FBF 17           	RLA
1158++8FC0 CB 2F        	SRA A
1159++8FC2 CB 2F        	SRA A
1160++8FC4 CB 2F        	SRA A
1161++8FC6 DD 86 04     	ADD A,(IX+CHP.CrEnSl) ;SEE COMMENT BELOW
1162++8FC9 CB 68        	BIT 5,B
1163++8FCB 28 03        	JR Z,NO_ENAC
1164++8FCD DD 77 04     	LD (IX+CHP.CrEnSl),A
1165++8FD0 FD 86 12     NO_ENAC	ADD A,(IY-100+VRS.AddToEn) ;BUG IN PT3 - NEED WORD HERE
1166++8FD3 FD 77 12     	LD (IY-100+VRS.AddToEn),A
1167++8FD6 18 0E        	JR CH_MIX
1168++8FD8 1F           NO_ENSL RRA
1169++8FD9 DD 86 03     	ADD A,(IX+CHP.CrNsSl)
1170++8FDC FD 77 11     	LD (IY-100+VRS.AddToNs),A
1171++8FDF CB 68        	BIT 5,B
1172++8FE1 28 03        	JR Z,CH_MIX
1173++8FE3 DD 77 03     	LD (IX+CHP.CrNsSl),A
1174++8FE6 78           CH_MIX	LD A,B
1175++8FE7 1F           	RRA
1176++8FE8 E6 48        	AND #48
1177++8FEA FD B6 1C     CH_EXIT	OR (IY-100+VRS.AYREGS+Mixer)
1178++8FED 0F           	RRCA
1179++8FEE FD 77 1C     	LD (IY-100+VRS.AYREGS+Mixer),A
1180++8FF1 E1           	POP HL
1181++8FF2 AF           	XOR A
1182++8FF3 DD B6 0A     	OR (IX+CHP.COnOff)
1183++8FF6 C8           	RET Z
1184++8FF7 DD 35 0A     	DEC (IX+CHP.COnOff)
1185++8FFA C0           	RET NZ
1186++8FFB DD AE 15     	XOR (IX+CHP.Flags)
1187++8FFE DD 77 15     	LD (IX+CHP.Flags),A
1188++9001 1F           	RRA
1189++9002 DD 7E 0B     	LD A,(IX+CHP.OnOffD)
1190++9005 38 03        	JR C,CH_ONDL
1191++9007 DD 7E 0C     	LD A,(IX+CHP.OffOnD)
1192++900A DD 77 0A     CH_ONDL	LD (IX+CHP.COnOff),A
1193++900D C9           	RET
1194++900E
1195++900E AF           PLAY_	XOR A
1196++900F FD 77 12     	LD (IY-100+VRS.AddToEn),A
1197++9012 FD 77 1C     	LD (IY-100+VRS.AYREGS+Mixer),A
1198++9015 3D           	DEC A
1199++9016 FD 77 22     	LD (IY-100+VRS.AYREGS+EnvTp),A
1200++9019 FD 35 09     	DEC (IY-100+VRS.DelyCnt)
1201++901C C2 C4 90     	JP NZ,PL2
1202++901F FD 35 BA     	DEC (IY-100+VRS.ChanA+CHP.NtSkCn)
1203++9022 20 6C        	JR NZ,PL1B
1204++9024 FD 4E FE     	LD C,(IY-100+VRS.AdInPtA)
1205++9027 FD 46 FF     	LD B,(IY-100+VRS.AdInPtA+1)
1206++902A 0A           	LD A,(BC)
1207++902B A7           	AND A
1208++902C 20 56        	JR NZ,PL1A
1209++902E 57           	LD D,A
1210++902F FD 77 10     	LD (IY-100+VRS.Ns_Base),A
1211++9032 FD 6E 04     	LD L,(IY-100+VRS.CrPsPtr)
1212++9035 FD 66 05     	LD H,(IY-100+VRS.CrPsPtr+1)
1213++9038 23           	INC HL
1214++9039 7E           	LD A,(HL)
1215++903A 3C           	INC A
1216++903B 20 0B        	JR NZ,PLNLP
1217++903D
1218++903D              	IF LoopChecker
1219++903D CD EF 88     	CALL CHECKLP
1220++9040              	ENDIF
1221++9040
1222++9040 FD 6E 06     	LD L,(IY-100+VRS.LPosPtr)
1223++9043 FD 66 07     	LD H,(IY-100+VRS.LPosPtr+1)
1224++9046 7E           	LD A,(HL)
1225++9047 3C           	INC A
1226++9048 CD 9C 8B     PLNLP	CALL SETCPPT
1227++904B 3D           	DEC A
1228++904C FD CB 9E 4E  	BIT 1,(IY-100+VRS.ModNum)
1229++9050 28 03        	JR Z,NoAlCo
1230++9052              TSSub	EQU $+1
1231++9052 D6 D6        	SUB #D6
1232++9054 2F           	CPL
1233++9055              NoAlCo
1234++9055              		;PT2		PT3
1235++9055 3D           PsCalc	DEC A	;ADD A,A	NOP
1236++9056 3D           	DEC A	;ADD A,(HL)	NOP
1237++9057 87           	ADD A,A
1238++9058 5F           	LD E,A
1239++9059 CB 12        	RL D
1240++905B
1241++905B              	IF CurPosCounter
1242++905B ~            	LD A,L
1243++905B ~            	SUB (IY-100+VRS.PosSub)
1244++905B ~            	LD (IY-100+VRS.CurPos),A
1245++905B              	ENDIF
1246++905B
1247++905B FD 6E FC     	LD L,(IY-100+VRS.PatsPtr)
1248++905E FD 66 FD     	LD H,(IY-100+VRS.PatsPtr+1)
1249++9061 19           	ADD HL,DE
1250++9062 FD 5E F6     	LD E,(IY-100+VRS.MODADDR)
1251++9065 FD 56 F7     	LD D,(IY-100+VRS.MODADDR+1)
1252++9068 ED 73 82 90  	LD (PSP_+1),SP
1253++906C F9           	LD SP,HL
1254++906D E1           	POP HL
1255++906E 19           	ADD HL,DE
1256++906F 44           	LD B,H
1257++9070 4D           	LD C,L
1258++9071 E1           	POP HL
1259++9072 19           	ADD HL,DE
1260++9073 FD 75 00     	LD (IY-100+VRS.AdInPtB),L
1261++9076 FD 74 01     	LD (IY-100+VRS.AdInPtB+1),H
1262++9079 E1           	POP HL
1263++907A 19           	ADD HL,DE
1264++907B FD 75 02     	LD (IY-100+VRS.AdInPtC),L
1265++907E FD 74 03     	LD (IY-100+VRS.AdInPtC+1),H
1266++9081 31 31 31     PSP_	LD SP,#3131
1267++9084 11 AB FF     PL1A	LD DE,VRS.ChanA+12-100
1268++9087 CD BF 8B     	CALL PTDECOD
1269++908A FD 71 FE     	LD (IY-100+VRS.AdInPtA),C
1270++908D FD 70 FF     	LD (IY-100+VRS.AdInPtA+1),B
1271++9090
1272++9090 FD 35 D7     PL1B	DEC (IY-100+VRS.ChanB+CHP.NtSkCn)
1273++9093 20 12        	JR NZ,PL1C
1274++9095 11 C8 FF     	LD DE,VRS.ChanB+12-100
1275++9098 FD 4E 00     	LD C,(IY-100+VRS.AdInPtB)
1276++909B FD 46 01     	LD B,(IY-100+VRS.AdInPtB+1)
1277++909E CD BF 8B     	CALL PTDECOD
1278++90A1 FD 71 00     	LD (IY-100+VRS.AdInPtB),C
1279++90A4 FD 70 01     	LD (IY-100+VRS.AdInPtB+1),B
1280++90A7
1281++90A7 FD 35 F4     PL1C	DEC (IY-100+VRS.ChanC+CHP.NtSkCn)
1282++90AA 20 12        	JR NZ,PL1D
1283++90AC 11 E5 FF     	LD DE,VRS.ChanC+12-100
1284++90AF FD 4E 02     	LD C,(IY-100+VRS.AdInPtC)
1285++90B2 FD 46 03     	LD B,(IY-100+VRS.AdInPtC+1)
1286++90B5 CD BF 8B     	CALL PTDECOD
1287++90B8 FD 71 02     	LD (IY-100+VRS.AdInPtC),C
1288++90BB FD 70 03     	LD (IY-100+VRS.AdInPtC+1),B
1289++90BE
1290++90BE FD 7E 08     PL1D	LD A,(IY-100+VRS.Delay)
1291++90C1 FD 77 09     	LD (IY-100+VRS.DelyCnt),A
1292++90C4
1293++90C4 11 9F FF     PL2	LD DE,VRS.ChanA-100
1294++90C7 FD 6E 15     	LD L,(IY-100+VRS.AYREGS+TonA)
1295++90CA FD 66 16     	LD H,(IY-100+VRS.AYREGS+TonA+1)
1296++90CD CD 97 8E     	CALL CHREGS
1297++90D0 FD 75 15     	LD (IY-100+VRS.AYREGS+TonA),L
1298++90D3 FD 74 16     	LD (IY-100+VRS.AYREGS+TonA+1),H
1299++90D6              Ampl	EQU $+1
1300++90D6 3E 3E        	LD A,#3E
1301++90D8 FD 77 1D     	LD (IY-100+VRS.AYREGS+AmplA),A
1302++90DB 11 BC FF     	LD DE,VRS.ChanB-100
1303++90DE FD 6E 17     	LD L,(IY-100+VRS.AYREGS+TonB)
1304++90E1 FD 66 18     	LD H,(IY-100+VRS.AYREGS+TonB+1)
1305++90E4 CD 97 8E     	CALL CHREGS
1306++90E7 FD 75 17     	LD (IY-100+VRS.AYREGS+TonB),L
1307++90EA FD 74 18     	LD (IY-100+VRS.AYREGS+TonB+1),H
1308++90ED 3A D7 90     	LD A,(Ampl)
1309++90F0 FD 77 1E     	LD (IY-100+VRS.AYREGS+AmplB),A
1310++90F3 11 D9 FF     	LD DE,VRS.ChanC-100
1311++90F6 FD 6E 19     	LD L,(IY-100+VRS.AYREGS+TonC)
1312++90F9 FD 66 1A     	LD H,(IY-100+VRS.AYREGS+TonC+1)
1313++90FC CD 97 8E     	CALL CHREGS
1314++90FF FD 75 19     	LD (IY-100+VRS.AYREGS+TonC),L
1315++9102 FD 74 1A     	LD (IY-100+VRS.AYREGS+TonC+1),H
1316++9105 3A D7 90     	LD A,(Ampl)
1317++9108 FD 77 1F     	LD (IY-100+VRS.AYREGS+AmplC),A
1318++910B
1319++910B FD 7E 10     	LD A,(IY-100+VRS.Ns_Base)
1320++910E FD 86 11     	ADD (IY-100+VRS.AddToNs)
1321++9111 FD 77 1B     	LD (IY-100+VRS.AYREGS+Noise),A
1322++9114
1323++9114 FD 7E 12     	LD A,(IY-100+VRS.AddToEn)
1324++9117 5F           	LD E,A
1325++9118 87           	ADD A,A
1326++9119 9F           	SBC A,A
1327++911A 57           	LD D,A
1328++911B FD 6E 13     	LD L,(IY-100+VRS.EnvBase)
1329++911E FD 66 14     	LD H,(IY-100+VRS.EnvBase+1)
1330++9121 19           	ADD HL,DE
1331++9122 FD 5E 0C     	LD E,(IY-100+VRS.CurESld)
1332++9125 FD 56 0D     	LD D,(IY-100+VRS.CurESld+1)
1333++9128 19           	ADD HL,DE
1334++9129 FD 75 20     	LD (IY-100+VRS.AYREGS+Env),L
1335++912C FD 74 21     	LD (IY-100+VRS.AYREGS+Env+1),H
1336++912F
1337++912F AF           	XOR A
1338++9130 FD B6 0F     	OR (IY-100+VRS.CurEDel)
1339++9133 C8           	RET Z
1340++9134 FD 35 0F     	DEC (IY-100+VRS.CurEDel)
1341++9137 C0           	RET NZ
1342++9138 FD 7E 0E     	LD A,(IY-100+VRS.Env_Del)
1343++913B FD 77 0F     	LD (IY-100+VRS.CurEDel),A
1344++913E FD 6E 0A     	LD L,(IY-100+VRS.ESldAdd)
1345++9141 FD 66 0B     	LD H,(IY-100+VRS.ESldAdd+1)
1346++9144 19           	ADD HL,DE
1347++9145 C3 B1 8B     	JP SETESLD
1348++9148
1349++9148 FD 21 80 92  PLAY    LD IY,VARS1+100
1350++914C CD 0E 90     	CALL PLAY_
1351++914F 3A 1B 92     	LD A,(is_ts)
1352++9152 A7           	AND A
1353++9153 28 07        	JR Z,PL_nts
1354++9155 FD 21 07 93  	LD IY,VARS2+100
1355++9159 CD 0E 90     	CALL PLAY_
1356++915C              PL_nts
1357++915C              	IF Basic
1358++915C FD 21 3A 5C  	LD IY,#5C3A
1359++9160              	ENDIF
1360++9160
1361++9160 01 FD FF     ROUT	LD BC,#FFFD
1362++9163 3A 1B 92     	LD A,(is_ts)
1363++9166 A7           	AND A
1364++9167 28 02        	JR Z,r_nts ;keep old standard
1365++9169 ED 41        	OUT (C),B
1366++916B 08           r_nts	EX AF,AF'
1367++916C
1368++916C              	IF ACBBAC
1369++916C ~            	LD IX,VARS1+VRS.AYREGS
1370++916C              	ELSE
1371++916C 21 95 92     	LD HL,VARS1+VRS.AYREGS
1372++916F              	ENDIF
1373++916F
1374++916F CD 7B 91     	CALL ROUT_
1375++9172 08           	EX AF,AF'
1376++9173 C8           	RET Z
1377++9174 42           	LD B,D
1378++9175 2F           	CPL
1379++9176 ED 79        	OUT (C),A
1380++9178
1381++9178              	IF ACBBAC
1382++9178 ~            	LD IX,VARS2+VRS.AYREGS
1383++9178              	ELSE
1384++9178 21 1C 93     	LD HL,VARS2+VRS.AYREGS
1385++917B              	ENDIF
1386++917B
1387++917B              ROUT_
1388++917B              	IF ACBBAC
1389++917B ~            	LD A,(SETUP)
1390++917B ~            	AND 12
1391++917B ~            	JR Z,ABC
1392++917B ~            	ADD A,CHTABLE
1393++917B ~            	LD E,A
1394++917B ~            	ADC A,CHTABLE/256
1395++917B ~            	SUB E
1396++917B ~            	LD D,A
1397++917B ~            	LD B,0
1398++917B ~            	PUSH IX
1399++917B ~            	POP HL
1400++917B ~            	LD A,(DE)
1401++917B ~            	INC DE
1402++917B ~            	LD C,A
1403++917B ~            	ADD HL,BC
1404++917B ~            	LD A,(IX+TonB)
1405++917B ~            	LD C,(HL)
1406++917B ~            	LD (IX+TonB),C
1407++917B ~            	LD (HL),A
1408++917B ~            	INC HL
1409++917B ~            	LD A,(IX+TonB+1)
1410++917B ~            	LD C,(HL)
1411++917B ~            	LD (IX+TonB+1),C
1412++917B ~            	LD (HL),A
1413++917B ~            	LD A,(DE)
1414++917B ~            	INC DE
1415++917B ~            	LD C,A
1416++917B ~            	ADD HL,BC
1417++917B ~            	LD A,(IX+AmplB)
1418++917B ~            	LD C,(HL)
1419++917B ~            	LD (IX+AmplB),C
1420++917B ~            	LD (HL),A
1421++917B ~            	LD A,(DE)
1422++917B ~            	INC DE
1423++917B ~            	LD (RxCA1),A
1424++917B ~            	XOR 8
1425++917B ~            	LD (RxCA2),A
1426++917B ~            	LD A,(DE)
1427++917B ~            	AND (IX+Mixer)
1428++917B ~            	LD E,A
1429++917B ~            	LD A,(IX+Mixer)
1430++917B ~            RxCA1	DB #E6
1431++917B ~            	AND %010010
1432++917B ~            	OR E
1433++917B ~            	LD E,A
1434++917B ~            	LD A,(IX+Mixer)
1435++917B ~            	AND %010010
1436++917B ~            RxCA2	OR E
1437++917B ~            	OR E
1438++917B ~            	LD (IX+Mixer),A
1439++917B ~            ABC
1440++917B              	ENDIF
1441++917B
1442++917B AF           	XOR A
1443++917C 11 BF FF     	LD DE,#FFBF
1444++917F
1445++917F              	IF ACBBAC
1446++917F ~            	LD BC,#FFFD
1447++917F ~            	PUSH IX
1448++917F ~            	POP HL
1449++917F              	ENDIF
1450++917F
1451++917F ED 79        LOUT	OUT (C),A
1452++9181 43           	LD B,E
1453++9182 ED A3        	OUTI
1454++9184 42           	LD B,D
1455++9185 3C           	INC A
1456++9186 FE 0D        	CP 13
1457++9188 20 F5        	JR NZ,LOUT
1458++918A ED 79        	OUT (C),A
1459++918C 7E           	LD A,(HL)
1460++918D A7           	AND A
1461++918E F8           	RET M
1462++918F 43           	LD B,E
1463++9190 ED 79        	OUT (C),A
1464++9192 C9           	RET
1465++9193
1466++9193              	IF ACBBAC
1467++9193 ~            CHTABLE	EQU $-4
1468++9193 ~            	DB 4,5,15,%001001,0,7,7,%100100
1469++9193              	ENDIF
1470++9193
1471++9193 64           NT_DATA	DB (T_NEW_0-T1_)*2
1472++9194 2A           	DB TCNEW_0-T_
1473++9195 65           	DB (T_OLD_0-T1_)*2+1
1474++9196 00           	DB TCOLD_0-T_
1475++9197 01           	DB (T_NEW_1-T1_)*2+1
1476++9198 0C           	DB TCNEW_1-T_
1477++9199 01           	DB (T_OLD_1-T1_)*2+1
1478++919A 0C           	DB TCOLD_1-T_
1479++919B 94           	DB (T_NEW_2-T1_)*2
1480++919C 35           	DB TCNEW_2-T_
1481++919D 30           	DB (T_OLD_2-T1_)*2
1482++919E 0E           	DB TCOLD_2-T_
1483++919F 60           	DB (T_NEW_3-T1_)*2
1484++91A0 20           	DB TCNEW_3-T_
1485++91A1 60           	DB (T_OLD_3-T1_)*2
1486++91A2 21           	DB TCOLD_3-T_
1487++91A3
1488++91A3              T_
1489++91A3
1490++91A3 01 05 09 0B  TCOLD_0	DB #00+1,#04+1,#08+1,#0A+1,#0C+1,#0E+1,#12+1,#14+1
1490++91A7 0D 0F 13 15
1491++91AB 19 25 3D 00  	DB #18+1,#24+1,#3C+1,0
1492++91AF 5D 00        TCOLD_1	DB #5C+1,0
1493++91B1 31 37 4D 53  TCOLD_2	DB #30+1,#36+1,#4C+1,#52+1,#5E+1,#70+1,#82,#8C,#9C
1493++91B5 5F 71 82 8C
1493++91B9 9C
1494++91BA 9E A0 A6 A8  	DB #9E,#A0,#A6,#A8,#AA,#AC,#AE,#AE,0
1494++91BE AA AC AE AE
1494++91C2 00
1495++91C3 57           TCNEW_3	DB #56+1
1496++91C4 1F 23 25 29  TCOLD_3	DB #1E+1,#22+1,#24+1,#28+1,#2C+1,#2E+1,#32+1,#BE+1,0
1496++91C8 2D 2F 33 BF
1496++91CC 00
1497++91CD 1D 21 23 27  TCNEW_0	DB #1C+1,#20+1,#22+1,#26+1,#2A+1,#2C+1,#30+1,#54+1
1497++91D1 2B 2D 31 55
1498++91D5 BD BF 00     	DB #BC+1,#BE+1,0
1499++91D8              TCNEW_1 EQU TCOLD_1
1500++91D8 1B 21 25 29  TCNEW_2	DB #1A+1,#20+1,#24+1,#28+1,#2A+1,#3A+1,#4C+1,#5E+1
1500++91DC 2B 3B 4D 5F
1501++91E0 BB BD BF 00  	DB #BA+1,#BC+1,#BE+1,0
1502++91E4
1503++91E4              PT3EMPTYORN EQU $-1
1504++91E4 01 00        	DB 1,0
1505++91E6
1506++91E6              ;first 12 values of tone tables (packed)
1507++91E6
player.asm(1508): warning: value 0xDD8 is truncated to 8bit value: 0xD8
1508++91E6 0D D8        T_PACK	DB #06EC*2/256,#06EC*2
1509++91E8 69           	DB #0755-#06EC
1510++91E9 70           	DB #07C5-#0755
1511++91EA 76           	DB #083B-#07C5
1512++91EB 7D           	DB #08B8-#083B
1513++91EC 85           	DB #093D-#08B8
1514++91ED 8D           	DB #09CA-#093D
1515++91EE 95           	DB #0A5F-#09CA
1516++91EF 9D           	DB #0AFC-#0A5F
1517++91F0 A8           	DB #0BA4-#0AFC
1518++91F1 B1           	DB #0C55-#0BA4
1519++91F2 BB           	DB #0D10-#0C55
player.asm(1520): warning: value 0xCDA is truncated to 8bit value: 0xDA
1520++91F3 0C DA        	DB #066D*2/256,#066D*2
1521++91F5 62           	DB #06CF-#066D
1522++91F6 68           	DB #0737-#06CF
1523++91F7 6D           	DB #07A4-#0737
1524++91F8 75           	DB #0819-#07A4
1525++91F9 7B           	DB #0894-#0819
1526++91FA 83           	DB #0917-#0894
1527++91FB 8A           	DB #09A1-#0917
1528++91FC 92           	DB #0A33-#09A1
1529++91FD 9C           	DB #0ACF-#0A33
1530++91FE A4           	DB #0B73-#0ACF
1531++91FF AF           	DB #0C22-#0B73
1532++9200 B8           	DB #0CDA-#0C22
player.asm(1533): warning: value 0xE08 is truncated to 8bit value: 0x08
1533++9201 0E 08        	DB #0704*2/256,#0704*2
1534++9203 6A           	DB #076E-#0704
1535++9204 72           	DB #07E0-#076E
1536++9205 78           	DB #0858-#07E0
1537++9206 7E           	DB #08D6-#0858
1538++9207 86           	DB #095C-#08D6
1539++9208 90           	DB #09EC-#095C
1540++9209 96           	DB #0A82-#09EC
1541++920A A0           	DB #0B22-#0A82
1542++920B AA           	DB #0BCC-#0B22
1543++920C B4           	DB #0C80-#0BCC
1544++920D BE           	DB #0D3E-#0C80
player.asm(1545): warning: value 0xFC0 is truncated to 8bit value: 0xC0
1545++920E 0F C0        	DB #07E0*2/256,#07E0*2
1546++9210 78           	DB #0858-#07E0
1547++9211 88           	DB #08E0-#0858
1548++9212 80           	DB #0960-#08E0
1549++9213 90           	DB #09F0-#0960
1550++9214 98           	DB #0A88-#09F0
1551++9215 A0           	DB #0B28-#0A88
1552++9216 B0           	DB #0BD8-#0B28
1553++9217 A8           	DB #0C80-#0BD8
1554++9218 E0           	DB #0D60-#0C80
1555++9219 B0           	DB #0E10-#0D60
1556++921A E8           	DB #0EF8-#0E10
1557++921B
1558++921B              ;vars from here can be stripped
1559++921B              ;you can move VARS to any other address
1560++921B
1561++921B              VARS
1562++921B
1563++921B 00           is_ts	DB 0
1564++921C
1565++921C              ;ChannelsVars
1566++921C              	STRUCT	CHP
1567++921C ~            ;reset group
1568++921C ~            PsInOr	DB 0
1569++921C ~            PsInSm	DB 0
1570++921C ~            CrAmSl	DB 0
1571++921C ~            CrNsSl	DB 0
1572++921C ~            CrEnSl	DB 0
1573++921C ~            TSlCnt	DB 0
1574++921C ~            CrTnSl	DW 0
1575++921C ~            TnAcc	DW 0
1576++921C ~            COnOff	DB 0
1577++921C ~            ;reset group
1578++921C ~
1579++921C ~            OnOffD	DB 0
1580++921C ~
1581++921C ~            ;IX for PTDECOD here (+12)
1582++921C ~            OffOnD	DB 0
1583++921C ~            OrnPtr	DW 0
1584++921C ~            SamPtr	DW 0
1585++921C ~            NNtSkp	DB 0
1586++921C ~            Note	DB 0
1587++921C ~            SlToNt	DB 0
1588++921C ~            Env_En	DB 0
1589++921C ~            Flags	DB 0
1590++921C ~             ;Enabled - 0, SimpleGliss - 2
1591++921C ~            TnSlDl	DB 0
1592++921C ~            TSlStp	DW 0
1593++921C ~            TnDelt	DW 0
1594++921C ~            NtSkCn	DB 0
1595++921C ~            Volume	DB 0
1596++921C              	ENDS
1597++921C
1598++921C              	STRUCT	VRS
1599++921C ~
1600++921C ~            ;IF not works in STRUCT in SjASM :(
1601++921C ~            ;	IF CurPosCounter
1602++921C ~            CurPos	DB 0
1603++921C ~            PosSub	DB 0
1604++921C ~            ;	ENDIF
1605++921C ~
1606++921C ~            ModNum	DB 0 ;bit0: ChipNum
1607++921C ~            	     ;bit1: 1-reversed patterns order (AlCo TS)
1608++921C ~
1609++921C ~            ChanA	DS CHP
1610++921C ~            ChanB	DS CHP
1611++921C ~            ChanC	DS CHP
1612++921C ~
1613++921C ~            ;GlobalVars
1614++921C ~            MODADDR	DW 0
1615++921C ~            OrnPtrs	DW 0
1616++921C ~            SamPtrs	DW 0
1617++921C ~            PatsPtr	DW 0
1618++921C ~            AdInPtA	DW 0
1619++921C ~            AdInPtB	DW 0
1620++921C ~            AdInPtC	DW 0
1621++921C ~            CrPsPtr	DW 0
1622++921C ~            LPosPtr	DW 0
1623++921C ~            Delay	DB 0
1624++921C ~            DelyCnt	DB 0
1625++921C ~            ESldAdd	DW 0
1626++921C ~            CurESld	DW 0
1627++921C ~            Env_Del	DB 0
1628++921C ~            CurEDel	DB 0
1629++921C ~            Ns_Base	DB 0
1630++921C ~            AddToNs	DB 0
1631++921C ~            AddToEn	DB 0
1632++921C ~            EnvBase	DW 0
1633++921C ~            AYREGS	DS 14
1634++921C              	ENDS
1635++921C
1636++921C 00 00 00...  VARS1	DS VRS
1637++92A3 00 00 00...  VARS2	DS VRS
1638++932A
1639++932A              VT_	EQU $-16
1640++932A 00 00 00...  	DS 256-16 ;CreatedVolumeTableAddress
1641++941A
1642++941A              T1_	EQU VT_+16 ;Tone tables data depacked here
1643++941A
1644++941A              T_OLD_1	EQU T1_
1645++941A              T_OLD_2	EQU T_OLD_1+24
1646++941A              T_OLD_3	EQU T_OLD_2+24
1647++941A              T_OLD_0	EQU T_OLD_3+2
1648++941A              T_NEW_0	EQU T_OLD_0
1649++941A              T_NEW_1	EQU T_OLD_1
1650++941A              T_NEW_2	EQU T_NEW_0+24
1651++941A              T_NEW_3	EQU T_OLD_3
1652++941A
1653++941A              PT2EMPTYORN EQU VT_+31 ;1,0,0 sequence
1654++941A
1655++941A 00 00 00...  NT_	DS 192 ;CreatedNoteTableAddress
1656++94DA
1657++94DA              VAR0END	EQU VT_+16 ;INIT zeroes from VARS to VAR0END-1
1658++94DA
1659++94DA              VARSEND EQU $
1660++94DA
1661++94DA              MDLADDR EQU outputBuffer
1662++94DA
1663++94DA              ;Release 0 steps:
1664++94DA              ;04/21/2007
1665++94DA              ;Works start (PTxPlay adaptation); first beta.
1666++94DA              ;04/22/2007
1667++94DA              ;Job finished; beta-testing.
1668++94DA              ;04/23/2007
1669++94DA              ;PT v3.7 TS mode corrected (after AlCo remarks).
1670++94DA              ;04/29/2007
1671++94DA              ;Added 1.XX and 2.XX special commands interpretation for PT3
1672++94DA              ;modules of v3.7+.
1673++94DA
1674++94DA              ;Size (minimal build for ZX Spectrum):
1675++94DA              ;Code block #908 bytes
1676++94DA              ;Variables #2BF bytes (can be stripped)
1677++94DA              ;Total size #908+#2BF=#BC7 (3015) bytes
1678++94DA              	ENDMODULE
# file closed: player/player.asm
  77++94DA                  ENDIF
# file closed: player/vortex-processor.asm
  39+ 94DA                      include "player/mod-processor.asm"
# file opened: player/mod-processor.asm
   1++94DA                  MODULE ModProcessor
   2++94DA                  ifdef GS
   3++94DA ~
   4++94DA ~                macro GS_WaitCommand2
   5++94DA ~            .wait
   6++94DA ~                in a, (CMD)
   7++94DA ~                rrca
   8++94DA ~                jr c, .wait
   9++94DA ~                endm
  10++94DA ~
  11++94DA ~                macro GS_SendCommand2 nn
  12++94DA ~                ld a, nn
  12++94DA ~              out (CMD), a
  13++94DA ~                endm
  14++94DA ~
  15++94DA ~            play:
  16++94DA ~                ld a, 255
  17++94DA ~                ld (oldminutes), a
  18++94DA ~
  19++94DA ~                call Console.waitForKeyUp
  20++94DA ~
  21++94DA ~                ld hl, Gopher.requestbuffer
  21++94DA ~              call DialogBox.msgNoWait
  22++94DA ~
  23++94DA ~                ;ld a, 1, (Render.play_next), a
  24++94DA ~            	xor a
  25++94DA ~            	ld (last_song_position),a
  26++94DA ~
  27++94DA ~                ld h, #00, a, 32
  28++94DA ~                call TextMode.fillLine
  29++94DA ~                ld de, #0001
  29++94DA ~              call TextMode.gotoXY
  30++94DA ~                ld hl, message
  30++94DA ~              call TextMode.printZ
  31++94DA ~                ld a, #00
  32++94DA ~                call TextMode.highlightLine
  33++94DA ~
  34++94DA ~            .loop
  35++94DA ~                halt
  36++94DA ~                xor a
  37++94DA ~                call Console.peekC
  38++94DA ~                cp Console.BACKSPACE
  39++94DA ~                jp z, .stopKey
  40++94DA ~            	cp SPACE
  41++94DA ~                jp z, .playNext
  42++94DA ~
  43++94DA ~                call printRTC
  44++94DA ~
  45++94DA ~               ;проверка что MOD начал играть сначала
  46++94DA ~                GS_SendCommand2 CMD_GET_SONG_POSITION
  47++94DA ~                GS_WaitCommand2
  48++94DA ~            	ld a,(last_song_position) ;предыдущая позиция
  49++94DA ~            	ld c,a
  50++94DA ~            	in a,(DATA) ;текущая позиция
  51++94DA ~            	ld (last_song_position),a
  52++94DA ~            	cp c
  53++94DA ~            	jr nc, .loop ;если не меньше, продолжаем играть
  54++94DA ~            .playNext
  55++94DA ~                ld a, 1, (Render.play_next), a ;флаг что надо будет играть следующий файл
  56++94DA ~            .stop
  57++94DA ~                call GeneralSound.stopModule
  58++94DA ~
  59++94DA ~                call Console.waitForKeyUp
  60++94DA ~                ret
  61++94DA ~            .stopKey
  62++94DA ~                xor a
  62++94DA ~              ld (Render.play_next), a ;флаг что не надо играть следующий файл
  63++94DA ~                jr .stop
  64++94DA ~
  65++94DA ~
  66++94DA ~            message db "Playing MODs [SPACE] for next song [BACKSPACE] for stop playing", 0
  67++94DA ~
  68++94DA ~
  69++94DA ~            CMD_GET_SONG_POSITION     = #60
  70++94DA ~            last_song_position db 0
  71++94DA ~
  72++94DA ~            ;; Control ports
  73++94DA ~            CMD  = 187
  74++94DA ~            DATA = 179
  75++94DA                  endif
  76++94DA                  ENDMODULE
  77++94DA
# file closed: player/mod-processor.asm
  40+ 94DA                      include "screen/screen.asm"
# file opened: screen/screen.asm
   1++94DA                  module ScreenViewer
   2++94DA              display:
   3++94DA CD 48 68         call Console.waitForKeyUp
   4++94DD 3E 07            ld a, 7
   4++94DF CD 79 88       call Memory.setPage
   5++94E2 21 FF 94 11      ld hl, outputBuffer, de, #c000, bc, 6912
   5++94E6 00 C0 01 00
   5++94EA 1B
   5++94EB ED B0          ldir
   6++94ED CD BE 61         call TextMode.disable
   7++94F0              .wait
   8++94F0 76           	halt
   9++94F1 AF               xor a
   9++94F2 DB FE          in a, (#fe)
   9++94F4 2F             cpl
   9++94F5 E6 1F          and 31
   9++94F7 28 F7          jr z, .wait
  10++94F9 CD 19 60         call TextMode.cls
  11++94FC C3 00 70         jp History.back
  12++94FF
  13++94FF                  endmodule
# file closed: screen/screen.asm
  41+ 94FF              start:
  42+ 94FF              outputBuffer:
  43+ 94FF F3                   di
  44+ 9500 AF                   xor a
  44+ 9501 32 6A 5C       ld (#5c6a), a  ; Thank you, Mario Prato, for feedback
  45+ 9504 32 00 5C             ld (#5c00),a
  46+ 9507 31 00 60             ld sp, asmOrg
  47+ 950A CD 6F 88             call Memory.init
  48+ 950D AF                   xor a
  48+ 950E D3 FE          out (#fe),a
  49+ 9510 FB                   ei
  50+ 9511
  51+ 9511 3E 07                ld a, 7
  51+ 9513 CD 79 88       call Memory.setPage
  52+ 9516                      ;; Logo
  53+ 9516 21 51 95 06          ld hl, logo, b, Dos.FMODE_READ
  53+ 951A 01
  53+ 951B CD EF 69       call Dos.fopen
  54+ 951E F5                   push af
  55+ 951F 21 00 C0 01          ld hl, #c000, bc, 6912
  55+ 9523 00 1B
  55+ 9525 CD DC 6A       call Dos.fread
  56+ 9528 F1                   pop af
  57+ 9529 CD C8 6A             call Dos.fclose
  58+ 952C
  59+ 952C 06 32                ld b, 50
  60+ 952E 76           1       halt
  61+ 952F 10 FD                djnz 1b
  62+ 9531                  ENDIF
  63+ 9531
  64+ 9531 CD 03 60         call TextMode.init
  65+ 9534 21 40 95     	ld hl, initing
  65+ 9537 CD 83 60       call TextMode.printZ
  66+ 953A CD 34 85       	call Wifi.init
  67+ 953D C3 6D 70         jp History.home
  68+ 9540
  69+ 9540 49 6E 69 74  initing db "Initing Wifi...", "\r", 0
  69+ 9544 69 6E 67 20
  69+ 9548 57 69 66 69
  69+ 954C 2E 2E 2E 0D
  69+ 9550 00
  70+ 9551 62 72 6F 77  logo    db "browser/logo.scr", 0
  70+ 9555 73 65 72 2F
  70+ 9559 6C 6F 67 6F
  70+ 955D 2E 73 63 72
  70+ 9561 00
  71+ 9562 62 72 6F 77  creds   db "browser/auth.pwd", 0
  71+ 9566 73 65 72 2F
  71+ 956A 61 75 74 68
  71+ 956E 2E 70 77 64
  71+ 9572 00
  72+ 9573              outputBuffer2:
  73+ 9573 41 54 45 30      db  "ATE0", 0
  73+ 9577 00
  74+ 9578
  75+ 9578                  display "ENDS: ", $
  76+ 9578                  display "Buff size", #ffff - $
  77+ 9578                  IFDEF NEDOOS
  78+ 9578 ~                    savebin "moon.com", asmOrg, $ - asmOrg
  79+ 9578                  ELSE
  80+ 9578              		IFDEF TRDOS
  81+ 9578              			SAVETRD "MOONR.TRD",|"moon.C",asmOrg, $ - asmOrg
  82+ 9578              		ELSE
  83+ 9578 ~            			savebin "moon.bin", asmOrg, $ - asmOrg
  84+ 9578              	    	ENDIF
  85+ 9578                  ENDIF
  86+ 9578
# file closed: main-all.asm
  17  9578                  ENDIF
# file closed: main.asm
