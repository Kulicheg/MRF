# file opened: main.asm
   1  0000                  DEFINE TCP_BUF_SIZE 1024
   2  0000              ; Generate version string
   3  0000                  LUA ALLPASS
   4  0000 ~                v = tostring(sj.get_define("V"))
   5  0000 ~                maj = string.sub(v, 1,1)
   6  0000 ~                min = string.sub(v, 2,2)
   7  0000 ~                sj.insert_define("VERSION_STRING", "\"" .. maj .. "." .. min .. "\"")
   8  0000 ~
   9  0000 ~                b = tostring(sj.get_define("BLD"))
  10  0000 ~                sj.insert_define("BUILD_STRING", "\"" .. b .. "\"")
  11  0000                  ENDLUA
  12  0000
  13  0000                  IFNDEF MSX
  14  0000                  device	zxspectrum128
  15  0000                  IFDEF NEDOOS
  16  0000 ~            	DEFINE CRLF "\r\n"
  17  0000 ~                    MODULE nos
  18  0000 ~                        include "../_sdk/sysdefs.asm"
  19  0000 ~                    ENDMODULE
  20  0000 ~                    org nos.PROGSTART
  21  0000                      ELSE
  22  0000              	DEFINE CRLF "\r"
  23  0000                      org 24576
  24  6000                  ENDIF
  25  6000              asmOrg:
  26  6000                  align 256
  27  6000 C3 F8 94         jp start
  28  6003                  include "vdp/index.asm"
# file opened: vdp/index.asm
   1+ 6003                  IFDEF TIMEX
   2+ 6003 ~                include "timex.asm"
   3+ 6003                  ENDIF
   4+ 6003
   5+ 6003                  IFDEF TIMEX80
   6+ 6003                  include "timex80.asm"
# file opened: vdp/timex80.asm
   1++6003              COLOR=0
   2++6003                  module TextMode
   3++6003              PORT_SELECT = #7c3b
   4++6003              init:
   5++6003 21 C8 61 06      ld hl, font_file, b, Dos.FMODE_READ
   5++6007 01
   6++6008 CD C0 69         call Dos.fopen
   7++600B F5               push af
   8++600C 01 00 08 21      ld bc, 2048, hl, font
   8++6010 00 40
   9++6012 CD AD 6A         call Dos.fread
  10++6015 F1               pop af
  11++6016 CD 99 6A         call Dos.fclose
  12++6019
  13++6019                  IFDEF UNO
  14++6019 ~                ;; Force turbo mode
  15++6019 ~                ld bc, 64571
  15++6019 ~              ld a, #0b
  15++6019 ~              out (c), a
  16++6019 ~                ld bc, 64827
  16++6019 ~              in a, (c)
  16++6019 ~              or #c0
  16++6019 ~              out (c),a
  17++6019                  ENDIF
  18++6019              cls:
  19++6019 3E 07            ld a, 7
  19++601B CD 82 88       call Memory.setPage
  20++601E
  21++601E                  IFDEF UNO
  22++601E ~                ld a, #3E
  22++601E ~              out (#ff), a
  23++601E                  ELSE
  24++601E 01 F7 EF         ld	bc, #EFF7   ;   Scorpio
  25++6021 3E 02            ld a,2
  26++6023 ED 79            out (C), a
  27++6025                  ENDIF
  28++6025
  29++6025 F3               di
  30++6026 21 00 00 54      ld	hl,0, d,h, e,h, b,h, c,b
  30++602A 5C 44 48
  31++602D 39               add	hl,sp
  32++602E 31 00 D8         ld	sp,#c000 + 6144
  33++6031              .loop
  34++6031                  dup 12
  35++6031 D5          >	push	de
  35++6032 D5          >	push	de
  35++6033 D5          >	push	de
  35++6034 D5          >	push	de
  35++6035 D5          >	push	de
  35++6036 D5          >	push	de
  35++6037 D5          >	push	de
  35++6038 D5          >	push	de
  35++6039 D5          >	push	de
  35++603A D5          >	push	de
  35++603B D5          >	push	de
  35++603C D5          >	push	de
  36++603D                  edup
  37++603D
  38++603D 10 F2            djnz	.loop
  39++603F
  40++603F 41               ld	b,c
  41++6040 31 00 F8         ld	sp,#e000 + 6144
  42++6043              .loop2:
  43++6043                  dup 12
  44++6043 D5          >	push	de
  44++6044 D5          >	push	de
  44++6045 D5          >	push	de
  44++6046 D5          >	push	de
  44++6047 D5          >	push	de
  44++6048 D5          >	push	de
  44++6049 D5          >	push	de
  44++604A D5          >	push	de
  44++604B D5          >	push	de
  44++604C D5          >	push	de
  44++604D D5          >	push	de
  44++604E D5          >	push	de
  45++604F                  edup
  46++604F
  47++604F 10 F2            djnz .loop2
  48++6051 F9               ld	sp,hl
  49++6052 21 00 00         ld hl ,0
  49++6055 22 C6 61       ld (coords), hl
  50++6058 AF               xor a
  50++6059 CD 82 88       call Memory.setPage
  51++605C
  52++605C FB               ei
  53++605D C9               ret
  54++605E
  55++605E              ; A - line
  56++605E              usualLine:
  57++605E 57              ld d, a
  58++605F 18 01           jr fill
  59++6061              ; A - line
  60++6061              highlightLine:
  61++6061 57               ld d, a
  62++6062              fill:
  63++6062 1E 00 06 40      ld e, 0, b, 64
  64++6066              .lloop
  65++6066 C5           	push bc
  66++6067 D5           	push de
  67++6068 CD 8D 61     	call findAddr
  68++606B 3E 07            ld a, 7
  68++606D CD 82 88       call Memory.setPage
  69++6070
  70++6070 06 08        	ld b, 8
  71++6072              .cloop
  72++6072 1A           	ld a, (de)
  72++6073 EE FF          xor #ff
  72++6075 12             ld (de), a
  73++6076 14           	inc d
  74++6077 10 F9        	djnz .cloop
  75++6079 D1           	pop de
  76++607A 1C           	inc e
  77++607B C1           	pop bc
  78++607C 10 E8        	djnz .lloop
  79++607E
  80++607E AF               xor a
  80++607F CD 82 88       call Memory.setPage
  81++6082 C9               ret
  82++6083
  83++6083              printZ:
  84++6083 7E               ld a, (hl)
  84++6084 A7             and a
  84++6085 C8             ret z
  85++6086 E5               push hl
  86++6087 CD 8E 60         call putC
  87++608A E1               pop hl
  88++608B 23               inc hl
  89++608C 18 F5            jr printZ
  90++608E
  91++608E
  92++608E              ; A - char
  93++608E              putC:
  94++608E 32 39 61         ld (drawC.char_tmp), a
  95++6091
  96++6091 FE 0D        	cp 13
  97++6093 CA B0 60     	jp z, .cr
  98++6096
  99++6096 ED 5B C6 61      ld de, (coords)
 100++609A 7B               ld a, e
 101++609B FE 55            cp 85
 102++609D D0               ret nc
 103++609E
 104++609E
 105++609E 3E 07            ld a, 7
 106++60A0 CD 82 88         call Memory.setPage
 107++60A3 FD E5            push iy
 108++60A5 CD C7 60         call drawC
 109++60A8 FD E1            pop iy
 110++60AA
 111++60AA 21 C6 61         ld hl, coords
 112++60AD 34               inc (hl)
 113++60AE
 114++60AE 18 12            jr .exit
 115++60B0              .cr
 116++60B0 2A C6 61     	ld hl, (coords)
 117++60B3 24           	inc h
 118++60B4 2E 00 22 C6  	ld l, 0, (coords), hl
 118++60B8 61
 119++60B9 FE 18        	cp 24
 120++60BB D8           	ret c
 121++60BC 21 00 00 22  	ld hl, 0, (coords), hl
 121++60C0 C6 61
 122++60C2              .exit
 123++60C2 AF               xor a
 123++60C3 CD 82 88       call Memory.setPage
 124++60C6 C9           	ret
 125++60C7
 126++60C7              drawC:
 127++60C7 2A C6 61         ld hl, (coords)
 128++60CA 45               ld b, l
 129++60CB CD F6 60         call .calc
 130++60CE 54               ld d, h
 131++60CF 5D               ld e, l
 132++60D0 32 3A 61         ld (.rot_tmp), a
 133++60D3 CD 8D 61         call findAddr
 134++60D6 D5               push de
 135++60D7 CD 2A 61         call .get_char
 136++60DA
 137++60DA E1               pop hl
 138++60DB              .print0
 139++60DB E5 DD E1         ld ix, hl
 140++60DE 7C               ld a, h
 141++60DF CB 6F            bit 5, a
 142++60E1 28 01            jr z, .ok
 143++60E3 2C               inc l
 144++60E4              .ok
 145++60E4 EE 20            xor #20
 145++60E6 67             ld h, a
 146++60E7 E5 FD E1         ld iy, hl
 147++60EA 3A 3A 61         ld a, (.rot_tmp)
 148++60ED CD 19 61         call .rotate_mask
 149++60F0 3A 3A 61         ld a, (.rot_tmp)
 150++60F3 C3 3B 61         jp basic_draw
 151++60F6              .calc
 152++60F6 2E 00              ld l,0
 153++60F8 78                 ld a, b
 153++60F9 A7             and a
 153++60FA C8             ret z
 154++60FB DD 21 00 00        ld ix, 0
 155++60FF 11 06 00           ld de,6
 156++6102 DD 19        1     add ix, de
 157++6104 10 FC              djnz 1b
 158++6106 11 F8 FF           ld de, -8
 159++6109 DD 7C        2     ld a, ixh
 160++610B A7                 and a
 161++610C 20 05              jr nz, 3f
 162++610E DD 7D              ld a, ixl
 163++6110 FE 08              cp 8
 164++6112 D8                 ret c
 165++6113              3
 166++6113 DD 19              add ix, de
 167++6115 2C                 inc l
 168++6116 18 F1              jr 2b
 169++6118 C9                 ret
 170++6119
 171++6119              .rotate_mask
 172++6119 21 FF 03         ld hl, #03ff
 173++611C A7               and a
 173++611D C8             ret z
 174++611E              .rot_loop
 175++611E 08               ex af, af
 176++611F 7D               ld a,l
 177++6120 0F               rrca
 178++6121 CB 1C            rr h
 179++6123 CB 1D            rr l
 180++6125 08               ex af, af
 181++6126 3D               dec a
 182++6127 20 F5            jr nz, .rot_loop
 183++6129 C9               ret
 184++612A              .get_char:
 185++612A 3A 39 61         ld a, (.char_tmp)
 186++612D 6F               ld l, a
 187++612E 26 00            ld h, 0
 188++6130 29               add hl, hl
 189++6131 29               add hl, hl
 190++6132 29               add hl, hl
 191++6133 01 00 40         ld bc, font
 192++6136 09               add hl, bc
 193++6137 EB               ex hl, de
 194++6138 C9               ret
 195++6139 00           .char_tmp db 0
 196++613A 00           .rot_tmp  db 0
 197++613B              ; A - rotation counter
 198++613B              ; DE - font PTR
 199++613B              ; HL - mask
 200++613B              ; IX - left half on screen
 201++613B              ; IY - right half on screen
 202++613B              basic_draw:
 203++613B 32 4D 61         ld (.rot_cnt),a
 204++613E
 205++613E 7D               ld a, l
 206++613F 32 60 61         ld (.mask1), a
 207++6142 7C               ld a, h
 208++6143 32 69 61         ld (.mask2), a
 209++6146 06 08            ld b, 8
 210++6148              .printIt
 211++6148 1A               ld a, (de)
 212++6149 67               ld h, a
 213++614A 2E 00            ld l, 0
 214++614C 3E 00            ld a, 0
 215++614E              .rot_cnt = $ - 1
 216++614E A7               and a
 216++614F 28 0B          jr z, .skiprot
 217++6151              .rot
 218++6151 08               ex af, af
 219++6152 7D               ld a,l
 220++6153 0F               rrca
 221++6154 CB 1C            rr h
 222++6156 CB 1D            rr l
 223++6158 08               ex af, af
 224++6159 3D               dec a
 225++615A 20 F5            jr nz, .rot
 226++615C              .skiprot
 227++615C FD 7E 00         ld a, (iy)
 228++615F E6 0F            and #0f
 229++6161              .mask1 = $ - 1
 230++6161 B5               or l
 231++6162 FD 77 00         ld (iy), a
 232++6165 DD 7E 00         ld a, (ix)
 233++6168 E6 FC            and #fc
 234++616A              .mask2 = $ -1
 235++616A B4               or h
 236++616B DD 77 00         ld (ix), a
 237++616E DD 24            inc ixh
 238++6170 FD 24            inc iyh
 239++6172 13               inc de
 240++6173 10 D3            djnz .printIt
 241++6175 C9               ret
 242++6176
 243++6176
 244++6176              ; H - line
 245++6176              ; A - char
 246++6176              fillLine:
 247++6176 54 1E 00         ld d, h, e, 0
 247++6179 CD 88 61       call gotoXY
 248++617C 06 55            ld b, 85
 249++617E              .loop
 250++617E F5 C5            push af, bc
 251++6180 CD 8E 60         call putC
 252++6183 C1 F1            pop bc, af
 253++6185 10 F7            djnz .loop
 254++6187 C9               ret
 255++6188
 256++6188
 257++6188              gotoXY:
 258++6188 ED 53 C6 61      ld (coords), de
 259++618C C9               ret
 260++618D
 261++618D              ; D - Y
 262++618D              ; E - X
 263++618D              ; OUT: de - coords
 264++618D              findAddr:
 265++618D 7B               ld a, e
 266++618E CB 3F            srl a
 267++6190 5F               ld e,a
 268++6191 06 E0            ld b, #E0
 269++6193 38 02            jr c, .proc
 270++6195 06 C0            ld b, #C0
 271++6197              .proc
 272++6197 7A               LD A,D
 273++6198 E6 07            AND 7
 274++619A 0F               RRCA
 275++619B 0F               RRCA
 276++619C 0F               RRCA
 277++619D B3               OR E
 278++619E 5F               LD E,A
 279++619F 7A               LD A,D
 280++61A0 E6 18            AND 24
 281++61A2 B0               OR b
 282++61A3 57               LD D,A
 283++61A4 C9               ret
 284++61A5
 285++61A5              toggleColor:
 286++61A5 3A BD 61         ld a,(curState)
 287++61A8 FE 07            cp 7
 288++61AA CA B5 61         jp z, sevenEleven
 289++61AD              ;zerroTolerance
 290++61AD 3E 07            ld a,7
 291++61AF 32 BD 61         ld (curState),a
 292++61B2 D3 FE            out (#fe),a
 293++61B4 C9               ret
 294++61B5              sevenEleven:
 295++61B5 3E 00            ld a,0
 296++61B7 32 BD 61         ld (curState),a
 297++61BA D3 FE            out (#fe),a
 298++61BC C9               ret
 299++61BD              curState:
 300++61BD 00               db 0
 301++61BE              disable:
 302++61BE                  IFDEF UNO
 303++61BE ~                xor a
 303++61BE ~              out (#fe), a
 303++61BE ~              out (#ff), a
 304++61BE                  ELSE
 305++61BE 01 F7 EF         ld	bc, #EFF7   ;   Scorpio
 306++61C1 3E 00            ld a,0
 307++61C3 ED 79            out (C), a
 308++61C5                  ENDIF
 309++61C5 C9               ret
 310++61C6
 311++61C6 00 00        coords dw 0
 312++61C8              font equ #4000 ; Using ZX-Spectrum screen as font buffer
 313++61C8 66 6F 6E 74  font_file db "font80.bin", 0
 313++61CC 38 30 2E 62
 313++61D0 69 6E 00
 314++61D3                  endmodule
 315++61D3
 316++61D3              exit:
 317++61D3 01 3B 7C 3E      ld bc, TextMode.PORT_SELECT, a, 1
 317++61D7 01
 318++61D8 ED 79            out (c), a
 319++61DA 04               inc b
 319++61DB AF             xor a
 320++61DC ED 79            out (c), a
 321++61DE C7               rst 0
# file closed: vdp/timex80.asm
   7+ 61DF                  ENDIF
   8+ 61DF
   9+ 61DF                  IFDEF ZXSCR
  10+ 61DF ~                include "zx.asm"
  11+ 61DF                  ENDIF
  12+ 61DF
  13+ 61DF              	IFDEF NEDOOS
  14+ 61DF ~                include "nedotext.asm"
  15+ 61DF                  ENDIF
# file closed: vdp/index.asm
  29  61DF                  include "utils/index.asm"
# file opened: utils/index.asm
   1+ 61DF                  include "atoi.asm"
# file opened: utils/atoi.asm
   1++61DF              ; DE - buffer
   2++61DF              ; HL - output
   3++61DF              atohl:
   4++61DF 21 00 00         ld hl, 0
   5++61E2              .loop
   6++61E2 1A               ld a, (de)
   7++61E3 13               inc de
   8++61E4                  ; Sepparators
   9++61E4 C5 E5            push bc, hl
  10++61E6 01 05 00             ld bc, sepparators_len
  11++61E9 21 01 62             ld hl, sepparators
  12++61EC ED B1                cpir
  13++61EE E1 C1            pop hl, bc
  14++61F0 C8               ret z
  15++61F1
  16++61F1 D6 30            sub '0'
  17++61F3
  18++61F3 C5               push bc
  19++61F4 4D                   ld c, l
  20++61F5 44                   ld b, h
  21++61F6
  22++61F6 29                   add hl, hl
  23++61F7 29                   add hl, hl
  24++61F8 09                   add hl, bc
  25++61F9 29                   add hl, hl
  26++61FA 4F                   ld c, a
  27++61FB 06 00                ld b, 0
  28++61FD 09                   add hl, bc
  29++61FE C1               pop bc
  30++61FF 18 E1            jr .loop
  31++6201
# file closed: utils/atoi.asm
   2+ 6201                  include "constants.asm"
# file opened: utils/constants.asm
   1++6201              TAB = 9
   2++6201              CR = 13
   3++6201              LF = 10
   4++6201              NULL = 0
   5++6201              SPACE = ' '
   6++6201              ESC = 27
   7++6201              BACKSPACE = 8
   8++6201
   9++6201                  IFDEF TIMEX80
  10++6201              MIME_DOWNLOAD 	= #19
  11++6201              MIME_LINK 		= #1A
  12++6201              MIME_TEXT 		= #10
  13++6201              MIME_IMAGE 		= #01
  14++6201              MIME_MUSIC 		= #0e
  15++6201              MIME_INPUT 		= #b3
  16++6201              MIME_MOD 		= #0d
  17++6201
  18++6201              BORDER_TOP = #b2
  19++6201              BORDER_BOTTOM = #b1
  20++6201                  ELSE
  21++6201 ~            	IFDEF MSX
  22++6201 ~            MIME_DOWNLOAD 	= 1
  23++6201 ~            MIME_LINK		= 2
  24++6201 ~            MIME_TEXT 		= 3
  25++6201 ~            MIME_IMAGE 		= 4
  26++6201 ~            MIME_MUSIC 		= 5
  27++6201 ~            MIME_INPUT 		= 6
  28++6201 ~            MIME_MOD      	= 7
  29++6201 ~            BORDER_TOP    = 7
  30++6201 ~            BORDER_BOTTOM = 8
  31++6201 ~            	ELSE
  32++6201 ~            MIME_DOWNLOAD = 1
  33++6201 ~            MIME_LINK     = 2
  34++6201 ~            MIME_TEXT     = 3
  35++6201 ~            MIME_IMAGE    = 6
  36++6201 ~            MIME_MUSIC    = 5
  37++6201 ~            MIME_INPUT    = 4
  38++6201 ~            MIME_MOD      = 7
  39++6201 ~
  40++6201 ~            BORDER_TOP    = 9
  41++6201 ~            BORDER_BOTTOM = 8
  42++6201 ~            	ENDIF
  43++6201 ~
  44++6201 ~
  45++6201 ~
  46++6201 ~
  47++6201              	ENDIF
  48++6201
  49++6201 0D 0A 09 00  sepparators db CR, LF, TAB, NULL, SPACE
  49++6205 20
  50++6206              sepparators_len = $ - sepparators
# file closed: utils/constants.asm
   3+ 6206                  include "strutils.asm"
# file opened: utils/strutils.asm
   1++6206              ; de - pointer
   2++6206              ; hl - count
   3++6206              strlen:
   4++6206 21 00 00         ld hl, 0
   5++6209              .loop
   6++6209 1A               ld a, (de)
   7++620A A7               and a
   7++620B 28 04          jr z, .exit
   8++620D 23               inc hl
   9++620E 13               inc de
  10++620F 18 F8            jr .loop
  11++6211              .exit
  12++6211 C9               ret
  13++6212
  14++6212                  module CompareBuff
  15++6212
  16++6212              ; Pushes A to buffer
  17++6212              push
  18++6212 F5               push af
  19++6213 06 20            ld b, 32
  19++6215 21 5E 62       ld hl, buffer + 1
  19++6218 11 5D 62       ld de, buffer
  20++621B              .loop
  21++621B 7E               ld a, (hl)
  21++621C 12             ld (de), a
  21++621D 23             inc hl
  21++621E 13             inc de
  21++621F 10 FA          djnz .loop
  22++6221 F1               pop af
  23++6222 21 7C 62         ld hl, buffer + 31
  23++6225 77             ld (hl), a
  24++6226 C9               ret
  25++6227
  26++6227              ; HL - Compare string(null terminated)
  27++6227              ; A - 0 NOT Found
  28++6227              ;     1 Found
  29++6227              search:
  30++6227 06 00            ld b, 0
  30++6229 E5             push hl
  31++622A              .loop:
  32++622A 7E               ld a, (hl)
  32++622B 23             inc hl
  32++622C 04             inc b
  32++622D A7             and a
  32++622E C2 2A 62       jp nz, .loop
  33++6231 05               dec b
  33++6232 E1             pop hl
  33++6233 C5             push bc
  33++6234 E5             push hl
  34++6235 E1               pop hl
  35++6236 11 7D 62         ld de, buffer + 32
  36++6239              .sourceLoop
  37++6239 1B               dec de
  37++623A 10 FD          djnz .sourceLoop
  38++623C C1               pop bc
  39++623D              .compare
  40++623D C5               push bc
  40++623E F5             push af
  41++623F 1A               ld a, (de)
  41++6240 47             ld b, a
  42++6241 F1               pop af
  42++6242 7E             ld a, (hl)
  42++6243 B8             cp b
  42++6244 C1             pop bc
  42++6245 3E 00          ld a, 0
  42++6247 C0             ret nz
  43++6248 13               inc de
  43++6249 23             inc hl
  44++624A 10 F1            djnz .compare
  45++624C 3E 01            ld a, 1
  46++624E C9               ret
  47++624F
  48++624F              clear:
  49++624F AF               xor a
  49++6250 21 5D 62       ld hl, buffer
  49++6253 11 5E 62       ld de, buffer + 1
  49++6256 01 20 00       ld bc, 32
  49++6259 77             ld (hl), a
  49++625A ED B0          ldir
  50++625C C9               ret
  51++625D
  52++625D 00 00 00...  buffer ds 32
  53++627D
  54++627D                  endmodule
# file closed: utils/strutils.asm
   4+ 627D                  IFDEF MSX
   5+ 627D ~            	    include "bios.asm"
   6+ 627D                  ENDIF
   7+ 627D                  include "screen.asm"
# file opened: utils/screen.asm
   1++627D              LINE_LIMIT = 63
   2++627D
   3++627D                  IFDEF NEDOOS
   4++627D ~            LINE_LIMIT = 79
   5++627D                  ENDIF
   6++627D
   7++627D                  IFDEF TIMEX80
   8++627D              LINE_LIMIT = 84
   9++627D                  ENDIF
  10++627D
  11++627D                  IFDEF MSX
  12++627D ~            LINE_LIMIT = 79
  13++627D                  ENDIF
  14++627D              ; HL - string pointer
  15++627D              print70Text:
  16++627D 06 54            ld b, LINE_LIMIT
  17++627F              .loop
  18++627F 7E               ld a, (hl)
  19++6280 A7               and a
  19++6281 C8             ret z
  20++6282 FE 0D            cp 13
  20++6284 C8             ret z
  21++6285 FE 0A            cp 10
  21++6287 C8             ret z
  22++6288 C5               push bc
  23++6289 E5               push hl
  24++628A CD 8E 60         call TextMode.putC
  25++628D E1               pop hl
  26++628E 23               inc hl
  27++628F C1               pop bc
  28++6290 05               dec b
  29++6291 78               ld a, b
  29++6292 A7             and a
  29++6293 C8             ret z
  30++6294 C3 7F 62         jp .loop
  31++6297
  32++6297              ; HL - string pointer
  33++6297              print70Goph:
  34++6297 06 54            ld b, LINE_LIMIT
  35++6299              .loop
  36++6299 7E               ld a, (hl)
  36++629A FE 09          cp 09
  36++629C C8             ret z
  37++629D A7               and a
  37++629E C8             ret z
  38++629F C5               push bc
  39++62A0 E5               push hl
  40++62A1 CD 8E 60         call TextMode.putC
  41++62A4 E1               pop hl
  42++62A5 23               inc hl
  43++62A6 C1               pop bc
  44++62A7 05               dec b
  45++62A8 78               ld a, b
  45++62A9 A7             and a
  45++62AA C8             ret z
  46++62AB C3 99 62         jp .loop
# file closed: utils/screen.asm
# file closed: utils/index.asm
  30  62AE                  include "gopher/render/index.asm"
# file opened: gopher/render/index.asm
   1+ 62AE                  MODULE Render
   2+ 62AE              PER_PAGE = 22
   3+ 62AE              CURSOR_OFFSET = 2
   4+ 62AE                  include "row.asm"
# file opened: gopher/render/row.asm
   1++62AE              ; A - row number
   2++62AE              ; HL - pointer to row
   3++62AE              renderRow:
   4++62AE C6 02            add CURSOR_OFFSET
   5++62B0 57               ld d,a
   6++62B1 1E 00            ld e,0
   7++62B3 CD 88 61         call TextMode.gotoXY
   8++62B6 7E               ld a,(hl)
   9++62B7 E5               push hl
  10++62B8 CD C3 62         call getIcon
  11++62BB CD 8E 60         call TextMode.putC
  12++62BE E1               pop hl
  13++62BF 23               inc hl
  14++62C0 C3 97 62         jp print70Goph
  15++62C3
  16++62C3              ; A - gopher id char
  17++62C3              getIcon:
  18++62C3 FE 69            cp 'i'
  18++62C5 CA DF 62       jp z, .info
  19++62C8 FE 39            cp '9'
  19++62CA CA E2 62       jp z, .down
  20++62CD FE 31            cp '1'
  20++62CF CA 48 63       jp z, .page
  21++62D2 FE 30            cp '0'
  21++62D4 CA 4B 63       jp z, .text
  22++62D7 FE 37            cp '7'
  22++62D9 CA 4E 63       jp z, .input
  23++62DC 3E 20            ld a, ' '
  24++62DE C9               ret
  25++62DF              .info
  26++62DF 3E 20            ld a, SPACE
  26++62E1 C9             ret
  27++62E2              .down
  28++62E2 54 5D            ld de, hl
  29++62E4 01 FF 00 3E      ld bc, #ff, a, TAB
  29++62E8 09
  29++62E9 ED B1          cpir
  30++62EB 78               ld a, b
  30++62EC B1             or c
  30++62ED 28 56          jr z, .downExit
  31++62EF D5               push de
  32++62F0              .nameLoop
  33++62F0 7E               ld a, (hl)
  33++62F1 A7             and a
  33++62F2 28 10          jr z, .check
  34++62F4 FE 09            cp TAB
  34++62F6 28 0C          jr z, .check
  35++62F8 FE 0D            cp CR
  35++62FA 28 08          jr z, .check
  36++62FC E5               push hl
  37++62FD CD 12 62         call CompareBuff.push
  38++6300 E1               pop hl
  39++6301 23               inc hl
  40++6302 18 EC            jr .nameLoop
  41++6304              .check
  42++6304 21 5D 63         ld hl, scrExt1
  42++6307 CD 27 62       call CompareBuff.search
  42++630A A7             and a
  42++630B 20 44          jr nz, .image
  43++630D 21 62 63         ld hl, scrExt2
  43++6310 CD 27 62       call CompareBuff.search
  43++6313 A7             and a
  43++6314 20 3B          jr nz, .image
  44++6316 3E 03            ld a, 3
  44++6318 32 E7 88       ld (VTPL.SETUP), a ; 0 bit - looping, 1 bit - pt2 file
  45++631B 21 71 63         ld hl, pt2Ext1
  45++631E CD 27 62       call CompareBuff.search
  45++6321 A7             and a
  45++6322 20 31          jr nz, .music
  46++6324 21 76 63         ld hl, pt2Ext2
  46++6327 CD 27 62       call CompareBuff.search
  46++632A A7             and a
  46++632B 20 28          jr nz, .music
  47++632D 3E 01            ld a, 1
  47++632F 32 E7 88       ld (VTPL.SETUP), a
  48++6332 21 67 63         ld hl, pt3Ext1
  48++6335 CD 27 62       call CompareBuff.search
  48++6338 A7             and a
  48++6339 20 1A          jr nz, .music
  49++633B 21 6C 63         ld hl, pt3Ext2
  49++633E CD 27 62       call CompareBuff.search
  49++6341 A7             and a
  49++6342 20 11          jr nz, .music
  50++6344
  51++6344                  ; General Sound support
  52++6344                  ifdef GS
  53++6344 ~                ld hl, modExt1
  53++6344 ~              call CompareBuff.search
  53++6344 ~              and a
  53++6344 ~              jr nz, .mod
  54++6344 ~                ld hl, modExt2
  54++6344 ~              call CompareBuff.search
  54++6344 ~              and a
  54++6344 ~              jr nz, .mod
  55++6344                  endif
  56++6344
  57++6344              .checkExit
  58++6344 E1               pop hl
  59++6345              .downExit
  60++6345 3E 19            ld a, MIME_DOWNLOAD
  60++6347 C9             ret
  61++6348              .page
  62++6348 3E 1A            ld a, MIME_LINK
  62++634A C9             ret
  63++634B              .text
  64++634B 3E 10            ld a, MIME_TEXT
  64++634D C9             ret
  65++634E              .input
  66++634E 3E B3            ld a, MIME_INPUT
  66++6350 C9             ret
  67++6351              .image
  68++6351 E1               pop hl
  68++6352 3E 01          ld a, MIME_IMAGE
  68++6354 C9             ret
  69++6355              .music
  70++6355 E1               pop hl
  70++6356 3E 0E          ld a, MIME_MUSIC
  70++6358 C9             ret
  71++6359              .mod
  72++6359 E1               pop hl
  72++635A 3E 0D          ld a, MIME_MOD
  72++635C C9             ret
  73++635D
  74++635D 2E 73 63 72  scrExt1 db ".scr", 0
  74++6361 00
  75++6362 2E 53 43 52  scrExt2 db ".SCR", 0
  75++6366 00
  76++6367
  77++6367 2E 70 74 33  pt3Ext1 db ".pt3", 0
  77++636B 00
  78++636C 2E 50 54 33  pt3Ext2 db ".PT3", 0
  78++6370 00
  79++6371 2E 70 74 32  pt2Ext1 db ".pt2", 0
  79++6375 00
  80++6376 2E 50 54 32  pt2Ext2 db ".PT2", 0
  80++637A 00
  81++637B 2E 6D 6F 64  modExt1 db ".mod", 0
  81++637F 00
  82++6380 2E 4D 4F 44  modExt2 db ".MOD", 0
  82++6384 00
# file closed: gopher/render/row.asm
   5+ 6385                  include "buffer.asm"
# file opened: gopher/render/buffer.asm
   1++6385              ; BC - line count
   2++6385              findLine:
   3++6385 21 F8 94         ld hl, outputBuffer
   4++6388 78               ld a,b
   5++6389 B1               or c
   6++638A CA B8 63         jp z, .checkEmpty
   7++638D              .preloop
   8++638D 16 0D            ld d,13
   9++638F              .loop
  10++638F 7E               ld a, (hl)
  10++6390 A7             and a
  10++6391 CA BB 63       jp z, .nope
  11++6394 BA               cp d
  11++6395 23             inc hl
  11++6396 CA AE 63       jp z, .checkLF  ;13
  12++6399 FE 0A            cp 10
  12++639B CA A1 63       jp z, .nextCheck     ;10
  13++639E C3 8F 63         jp .loop
  14++63A1              .nextCheck
  15++63A1 A7               and a
  15++63A2 CA BB 63       jp z, .nope
  16++63A5 0B               dec bc
  17++63A6 5F               ld e,a
  18++63A7 78               ld a,b
  19++63A8 B1               or c
  20++63A9 7B               ld a,e
  21++63AA C2 8F 63         jp nz, .loop
  22++63AD C9               ret
  23++63AE              .checkLF
  24++63AE 7E               ld a, (hl)
  25++63AF FE 0A            cp 10
  25++63B1 C2 A1 63       jp nz, .nextCheck    ;10
  26++63B4 23               inc hl
  27++63B5 C3 A1 63         jp  .nextCheck
  28++63B8              .checkEmpty
  29++63B8 7E               ld a, (hl)
  29++63B9 A7             and a
  29++63BA C0             ret nz
  30++63BB              .nope
  31++63BB 21 00 00         ld hl, 0
  31++63BE C9             ret
  32++63BF
# file closed: gopher/render/buffer.asm
   6+ 63BF                  include "ui.asm"
# file opened: gopher/render/ui.asm
   1++63BF                  IFDEF ZXSCR
   2++63BF ~                DEFINE LEFT_TAB "[D]omain:                                  "
   3++63BF                  ENDIF
   4++63BF
   5++63BF                  IFDEF TIMEX     ;UNKNOWM fallback to 64
   6++63BF ~                DEFINE LEFT_TAB "[D]omain:                                  "
   7++63BF                  ENDIF
   8++63BF
   9++63BF                  IFDEF TIMEX80
  10++63BF                  DEFINE LEFT_TAB "[D]omain:                                                      "
  11++63BF                  ENDIF
  12++63BF
  13++63BF                  IFDEF NEDOOS
  14++63BF ~                DEFINE LEFT_TAB "[D]omain:                                                  "
  15++63BF                  ENDIF
  16++63BF
  17++63BF                  IFDEF MSX
  18++63BF ~                DEFINE LEFT_TAB "[D]omain:                                              "
  19++63BF                  ENDIF
  20++63BF              prepareScreen:
  21++63BF CD 19 60         call TextMode.cls
  22++63C2 21 92 64         ld hl, header
  22++63C5 CD 83 60       call TextMode.printZ
  23++63C8 11 0A 00         ld de, #000A
  23++63CB CD 88 61       call TextMode.gotoXY
  24++63CE 21 A0 80         ld hl, hostName
  24++63D1 CD 83 60       call TextMode.printZ
  25++63D4 AF               xor a
  25++63D5 CD 61 60       call TextMode.highlightLine
  26++63D8 C9               ret
  27++63D9
  28++63D9              inputHost:
  29++63D9 CD 19 68         	call Console.waitForKeyUp
  30++63DC              .loop
  31++63DC 11 0A 00         ld de, #000A
  31++63DF CD 88 61       call TextMode.gotoXY
  31++63E2 21 A0 80       ld hl, hostName
  31++63E5 CD 83 60       call TextMode.printZ
  32++63E8 3E B3            ld a, MIME_INPUT
  32++63EA CD 8E 60       call TextMode.putC
  33++63ED 3E 20            ld a, ' '
  33++63EF CD 8E 60       call TextMode.putC
  34++63F2              .wait
  35++63F2 CD 26 68         call Console.getC
  36++63F5 5F               ld e, a
  37++63F6 FE 0C            cp Console.BACKSPACE
  37++63F8 28 17          jr z, .removeChar
  38++63FA FE 0D            cp CR
  38++63FC CA 1F 64       jp z, inputNavigate
  39++63FF FE 20            cp 32
  39++6401 38 EF          jr c, .wait
  40++6403              .putC
  41++6403 AF               xor a
  41++6404 21 A0 80 01    ld hl, hostName, bc, 48
  41++6408 30 00
  41++640A ED B1          cpir
  42++640C 77               ld (hl), a
  42++640D 2B             dec hl
  42++640E 73             ld (hl), e
  43++640F 18 CB            jr .loop
  44++6411              .removeChar
  45++6411 AF               xor a
  46++6412 21 A0 80 01      ld hl, hostName, bc, 48
  46++6416 30 00
  46++6418 ED B1          cpir
  47++641A 2B               dec hl
  47++641B 2B             dec hl
  47++641C 77             ld (hl), a
  48++641D 18 BD            jr .loop
  49++641F
  50++641F              inputNavigate:
  51++641F 21 A0 80 11      ld hl, hostName, de, domain
  51++6423 52 64
  52++6425 7E               ld a,(hl)
  53++6426 A7               and a
  54++6427 CA 17 70         jp z, History.load
  55++642A              .loop
  56++642A 7E               ld a, (hl)
  56++642B A7             and a
  56++642C 28 05          jr z, .complete
  57++642E 12               ld (de), a
  57++642F 23 13          inc hl, de
  58++6431 18 F7            jr .loop
  59++6433              .complete
  60++6433 3E 09            ld a, TAB
  60++6435 12             ld (de), a
  60++6436 13             inc de
  61++6437 3E 37            ld a, '7'
  61++6439 12             ld (de), a
  61++643A 13             inc de
  62++643B 3E 30            ld a, '0'
  62++643D 12             ld (de), a
  62++643E 13             inc de
  63++643F 3E 0D            ld a, CR
  63++6441 12             ld (de), a
  63++6442 13             inc de
  64++6443 3E 0A            ld a, LF
  64++6445 12             ld (de), a
  64++6446 13             inc de
  65++6447 21 4D 64         ld hl, navRow
  65++644A C3 70 70       jp History.navigate
  66++644D
  67++644D 31 20 09 2F  navRow db "1 ", TAB, "/", TAB
  67++6451 09
  68++6452 6E 69 68 69  domain db "nihirash.net"
  68++6456 72 61 73 68
  68++645A 2E 6E 65 74
  69++645E 00 00 00...      ds 64 - ($ - domain)
  70++6492
  71++6492 5B 44 5D 6F  header db "[D]omain:                                                      ", "MRF "
  71++6496 6D 61 69 6E
  71++649A 3A 20 20 20
  71++649E 20 20 20 20
  71++64A2 20 20 20 20
  71++64A6 20 20 20 20
  71++64AA 20 20 20 20
  71++64AE 20 20 20 20
  71++64B2 20 20 20 20
  71++64B6 20 20 20 20
  71++64BA 20 20 20 20
  71++64BE 20 20 20 20
  71++64C2 20 20 20 20
  71++64C6 20 20 20 20
  71++64CA 20 20 20 20
  71++64CE 20 20 20 4D
  71++64D2 52 46 20
  72++64D5 31 2E 37            db "1.7"
  73++64D8 2E                  db "."
  74++64D9 38                  db "8"
  75++64DA              	IFDEF MSX
  76++64DA ~                   db " [MSX UNAPI]",13, 0
  77++64DA              	ENDIF
  78++64DA
  79++64DA                  IFDEF MB03
  80++64DA ~                   db " [MB03+]",13, 0
  81++64DA                     ENDIF
  82++64DA
  83++64DA                  IFDEF UNO
  84++64DA ~                   db " [UNO UART]",13, 0
  85++64DA                  ENDIF
  86++64DA
  87++64DA                  IFDEF AY
  88++64DA ~                   db " [AYWIFI]",13, 0
  89++64DA              	ENDIF
  90++64DA
  91++64DA                  IFDEF ZW
  92++64DA 20 5B 5A 58         db " [ZXWiFi]",13, 0
  92++64DE 57 69 46 69
  92++64E2 5D 0D 00
  93++64E5                  ENDIF
  94++64E5
  95++64E5                   IFDEF NEDOOSATM
  96++64E5 ~                   db " [ATM UART]",13, 0
  97++64E5                  ENDIF
  98++64E5
  99++64E5                  IFDEF NEDOOSEVO
 100++64E5 ~                   db " [EVO UART]",13, 0
 101++64E5                  ENDIF
 102++64E5
 103++64E5                  IFDEF UNOUART
 104++64E5 ~                   db " [UNO UART]",13, 0
 105++64E5                  ENDIF
 106++64E5
 107++64E5                  IFDEF NEDOOS
 108++64E5 ~            	IFNDEF NEDOOSATM
 109++64E5 ~            	IFNDEF NEDOOSEVO
 110++64E5 ~                   db " [nedoNET]",13, 0
 111++64E5 ~
 112++64E5 ~                ENDIF
 113++64E5 ~            	ENDIF
 114++64E5              	ENDIF
 115++64E5
# file closed: gopher/render/ui.asm
   7+ 64E5                  include "gopher-page.asm"
# file opened: gopher/render/gopher-page.asm
   1++64E5              renderGopherScreen:
   2++64E5 CD BF 63         call Render.prepareScreen
   3++64E8 06 16            ld b, PER_PAGE
   4++64EA              .loop
   5++64EA C5               push bc
   6++64EB 3E 16            ld a, PER_PAGE
   7++64ED 90               sub b
   8++64EE 47               ld b,a
   9++64EF 5F               ld e,a
  10++64F0
  11++64F0 48                   ld c,b
  12++64F1 06 00                ld b,0
  13++64F3
  14++64F3 2A 8E 73             ld hl, (page_offset)
  15++64F6 09                   add hl,bc
  16++64F7 44 4D                ld bc,hl
  17++64F9 D5                   push de
  18++64FA CD 85 63         call Render.findLine
  19++64FD D1               pop de
  20++64FE
  21++64FE 7C               ld a, h
  22++64FF B5               or l
  23++6500 28 04            jr z, .exit
  24++6502 7B               ld a, e
  25++6503 CD AE 62         call renderRow
  26++6506              .exit
  27++6506 C1               pop bc
  28++6507 10 E1            djnz .loop
  29++6509 CD 06 66         call showCursor
  30++650C C9               ret
  31++650D
  32++650D              checkBorder:
  33++650D 3A 8C 73         ld a, (cursor_position)
  33++6510 FE FF          cp #ff
  33++6512 CA 2A 66       jp z, pageUp
  34++6515 3A 8C 73         ld a, (cursor_position)
  34++6518 FE 16          cp PER_PAGE
  34++651A CA 5D 66       jp z, pageDn
  35++651D CD 06 66         call showCursor
  36++6520 C3 23 65         jp workLoop
  37++6523
  38++6523              workLoop:
  39++6523 3A 35 67         ld a, (play_next)
  39++6526 A7             and a
  39++6527 C2 BB 65       jp nz, navigate
  40++652A
  41++652A                  dup 5
  42++652A 76          >    halt
  42++652B 76          >    halt
  42++652C 76          >    halt
  42++652D 76          >    halt
  42++652E 76          >    halt
  43++652F                  edup
  44++652F              .nothing
  45++652F CD 37 68         call Console.peekC
  46++6532 A7               and a
  46++6533 CA 2F 65       jp z, .nothing
  47++6536
  48++6536 FE 31            cp '1'
  48++6538 CA 00 70       jp z, History.back
  49++653B FE 32            cp '2'
  49++653D CA BB 65       jp z, navigate
  50++6540 FE 33            cp '3'
  50++6542 CA 16 66       jp z, cursorDown
  51++6545 FE 34            cp '4'
  51++6547 CA 20 66       jp z, cursorUp
  52++654A FE 35            cp '5'
  52++654C CA 2A 66       jp z, pageUp
  53++654F FE 38            cp '8'
  53++6551 CA 5D 66       jp z, pageDn
  54++6554 FE 36            cp '6'
  54++6556 CA 16 66       jp z, cursorDown
  55++6559 FE 37            cp '7'
  55++655B CA 20 66       jp z, cursorUp
  56++655E
  57++655E FE 0A            cp Console.KEY_DN
  57++6560 CA 16 66       jp z, cursorDown
  58++6563 FE 61            cp 'a'
  58++6565 CA 16 66       jp z, cursorDown
  59++6568 FE 0B            cp Console.KEY_UP
  59++656A CA 20 66       jp z, cursorUp
  60++656D FE 71            cp 'q'
  60++656F CA 20 66       jp z, cursorUp
  61++6572 FE 08            cp Console.KEY_LT
  61++6574 CA 2A 66       jp z, pageUp
  62++6577 FE 6F            cp 'o'
  62++6579 CA 2A 66       jp z, pageUp
  63++657C FE 09            cp Console.KEY_RT
  63++657E CA 5D 66       jp z, pageDn
  64++6581 FE 70            cp 'p'
  64++6583 CA 5D 66       jp z, pageDn
  65++6586
  66++6586 FE 68            cp 'h'
  66++6588 CA 6D 70       jp z, History.home
  67++658B FE 48            cp 'H'
  67++658D CA 6D 70       jp z, History.home
  68++6590
  69++6590 FE 62            cp 'b'
  69++6592 CA 00 70       jp z, History.back
  70++6595 FE 42            cp 'B'
  70++6597 CA 00 70       jp z, History.back
  71++659A FE 0C            cp Console.BACKSPACE
  71++659C CA 00 70       jp z, History.back
  72++659F
  73++659F FE 64            cp 'd'
  73++65A1 CA D9 63       jp z, inputHost
  74++65A4 FE 44            cp 'D'
  74++65A6 CA D9 63       jp z, inputHost
  75++65A9
  76++65A9 FE 0D            cp CR
  76++65AB CA BB 65       jp z, navigate
  77++65AE
  78++65AE                  IFDEF MSX
  79++65AE ~                	cp ESC
  79++65AE ~              jp z, exit
  80++65AE                  ENDIF
  81++65AE
  82++65AE                  IFDEF GS
  83++65AE ~                cp 'M'
  83++65AE ~              call z, GeneralSound.toggleModule
  84++65AE ~                cp 'm'
  84++65AE ~              call z, GeneralSound.toggleModule
  85++65AE ~                cp 'g'
  85++65AE ~              call z, GeneralSound.toggleDownload
  86++65AE ~                cp 'G'
  86++65AE ~              call z, GeneralSound.toggleDownload
  87++65AE                  ENDIF
  88++65AE
  89++65AE                  IFDEF TIMEX80
  90++65AE FE 54            cp 'T'
  90++65B0 CC A5 61       call z, TextMode.toggleColor
  91++65B3 FE 74            cp 't'
  91++65B5 CC A5 61       call z, TextMode.toggleColor
  92++65B8                  ENDIF
  93++65B8
  94++65B8 C3 23 65         jp workLoop
  95++65BB
  96++65BB              navigate:
  97++65BB CD 19 68         call Console.waitForKeyUp
  98++65BE AF               xor a
  98++65BF 32 35 67       ld (play_next), a
  99++65C2 CD 0E 66         call hideCursor
 100++65C5 ED 4B 8E 73      ld bc, (page_offset)
 101++65C9 2A 8C 73         ld hl, (cursor_position)
 102++65CC 09               add hl,bc
 103++65CD 44               ld b, h ;HHHHH
 104++65CE 4D               ld c, l ;LLLLL
 105++65CF D5               push de
 106++65D0 CD 85 63         call Render.findLine
 107++65D3 D1               pop de
 108++65D4 7E               ld a, (hl)
 109++65D5 FE 31            cp '1'
 109++65D7 CA EF 65       jp z, .load
 110++65DA FE 30            cp '0'
 110++65DC CA EF 65       jp z, .load
 111++65DF FE 39            cp '9'
 111++65E1 CA EF 65       jp z, .load
 112++65E4 FE 37            cp '7'
 112++65E6 CA F7 65       jp z, .input
 113++65E9 CD 06 66         call showCursor
 114++65EC C3 23 65         jp workLoop
 115++65EF              .load
 116++65EF E5               push hl
 117++65F0 CD C3 62         call getIcon
 118++65F3 E1               pop hl
 119++65F4 C3 70 70         jp History.navigate
 120++65F7              .input
 121++65F7 E5               push hl
 122++65F8 CD 36 67         call DialogBox.inputBox
 123++65FB E1               pop hl
 124++65FC 3A 91 67         ld a, (DialogBox.inputBuffer)
 124++65FF A7             and a
 124++6600 CA 17 70       jp z, History.load
 125++6603 C3 EF 65         jp .load
 126++6606
 127++6606              showCursor:
 128++6606 3A 8C 73         ld a, (cursor_position)
 128++6609 C6 02          add CURSOR_OFFSET
 129++660B C3 61 60         jp TextMode.highlightLine
 130++660E
 131++660E              hideCursor:
 132++660E 3A 8C 73         ld a, (cursor_position)
 132++6611 C6 02          add CURSOR_OFFSET
 133++6613 C3 5E 60         jp TextMode.usualLine
 134++6616
 135++6616              cursorDown:
 136++6616 CD 0E 66         call hideCursor
 137++6619 21 8C 73         ld hl, cursor_position
 138++661C 34               inc (hl)
 139++661D C3 0D 65         jp checkBorder
 140++6620
 141++6620              cursorUp:
 142++6620 CD 0E 66         call hideCursor
 143++6623 21 8C 73         ld hl, cursor_position
 144++6626 35               dec (hl)
 145++6627 C3 0D 65         jp checkBorder
 146++662A
 147++662A              pageUp:
 148++662A 3A 8E 73         ld a, (page_offset)
 148++662D FE 00          cp 0
 148++662F C2 3D 66       jp nz, .pageUp2
 149++6632 3A 8F 73         ld a, (page_offset + 1)
 149++6635 FE 00          cp 0
 149++6637 C2 3D 66       jp nz, .pageUp2
 150++663A C3 53 66         jp .skip
 151++663D              .pageUp2:
 152++663D 3E 15            ld a, PER_PAGE - 1
 152++663F 32 8C 73       ld (cursor_position), a
 153++6642 2A 8E 73         ld hl, (page_offset)
 154++6645 11 16 00         ld de,PER_PAGE
 155++6648 ED 52            sbc hl,de
 156++664A 22 8E 73         ld (page_offset), hl
 157++664D              .exit
 158++664D CD E5 64         call renderGopherScreen
 159++6650 C3 23 65         jp workLoop
 160++6653              .skip
 161++6653 AF               xor a
 161++6654 32 8C 73       ld (cursor_position), a
 161++6657 CD E5 64       call renderGopherScreen
 161++665A C3 23 65       jp workLoop
 162++665D
 163++665D              pageDn:
 164++665D AF                xor a
 164++665E 32 8C 73       ld (cursor_position), a
 165++6661 2A 8E 73         ld hl,(page_offset)
 166++6664 11 16 00         ld de,PER_PAGE
 167++6667 19               add hl,de
 168++6668 22 8E 73         ld (page_offset), hl
 169++666B C3 4D 66         jp pageUp.exit
 170++666E
 171++666E
 172++666E
# file closed: gopher/render/gopher-page.asm
   8+ 666E                  include "plaintext.asm"
# file opened: gopher/render/plaintext.asm
   1++666E              renderPlainTextScreen:
   2++666E CD BF 63         call prepareScreen
   3++6671 06 16            ld b, PER_PAGE
   4++6673              .loop
   5++6673 C5               push bc
   6++6674 3E 16            ld a, PER_PAGE
   7++6676 90               sub b
   8++6677 47               ld b,a
   9++6678 5F               ld e,a
  10++6679 48               ld c,b
  11++667A 06 00            ld b,0
  12++667C 2A 8E 73         ld hl, (page_offset)
  13++667F 09               add hl,bc
  14++6680 44 4D            ld bc,hl
  15++6682 D5               push de
  16++6683 CD 85 63         call Render.findLine
  17++6686 D1               pop de
  18++6687 7C               ld a, h
  18++6688 B5             or l
  18++6689 CA 9C 66       jp z, .exit
  19++668C 7B               ld a, e
  20++668D C6 02            add CURSOR_OFFSET
  20++668F 57 1E 01       ld d, a, e, 1
  20++6692 CD 88 61       call TextMode.gotoXY
  21++6695 CD 7D 62         call print70Text
  22++6698 C1               pop bc
  23++6699 10 D8            djnz .loop
  24++669B C9               ret
  25++669C              .exit
  26++669C C1               pop bc
  27++669D C9               ret
  28++669E
  29++669E              plainTextLoop:
  30++669E CD 26 68         call Console.getC
  31++66A1
  32++66A1 FE 31            cp '1'
  32++66A3 CA 00 70       jp z, History.back
  33++66A6 FE 32            cp '2'
  33++66A8 CA BB 65       jp z, navigate
  34++66AB FE 35            cp '5'
  34++66AD CA 13 67       jp z, textUp
  35++66B0 FE 38            cp '8'
  35++66B2 CA 03 67       jp z, textDown
  36++66B5 FE 08            cp Console.KEY_LT
  36++66B7 CA 13 67       jp z, textUp
  37++66BA FE 09            cp Console.KEY_RT
  37++66BC CA 03 67       jp z, textDown
  38++66BF
  39++66BF FE 0A            cp Console.KEY_DN
  39++66C1 CA 03 67       jp z, textDown
  40++66C4 FE 61            cp 'a'
  40++66C6 CA 03 67       jp z, textDown
  41++66C9
  42++66C9 FE 0B            cp Console.KEY_UP
  42++66CB CA 13 67       jp z, textUp
  43++66CE FE 71            cp 'q'
  43++66D0 CA 13 67       jp z, textUp
  44++66D3
  45++66D3 FE 68            cp 'h'
  45++66D5 CA 6D 70       jp z, History.home
  46++66D8 FE 48            cp 'H'
  46++66DA CA 6D 70       jp z, History.home
  47++66DD
  48++66DD FE 62            cp 'b'
  48++66DF CA 00 70       jp z, History.back
  49++66E2 FE 42            cp 'B'
  49++66E4 CA 00 70       jp z, History.back
  50++66E7
  51++66E7 FE 64            cp 'd'
  51++66E9 CA D9 63       jp z, inputHost
  52++66EC FE 44            cp 'D'
  52++66EE CA D9 63       jp z, inputHost
  53++66F1
  54++66F1 FE 0C            cp Console.BACKSPACE
  54++66F3 CA 00 70       jp z, History.back
  55++66F6
  56++66F6                  IFDEF MSX
  57++66F6 ~                	cp ESC
  57++66F6 ~              jp z, exit
  58++66F6                  ENDIF
  59++66F6
  60++66F6                  IFDEF GS
  61++66F6 ~                cp 'M'
  61++66F6 ~              call z, GeneralSound.toggleModule
  62++66F6 ~                cp 'm'
  62++66F6 ~              call z, GeneralSound.toggleModule
  63++66F6                  ENDIF
  64++66F6
  65++66F6                  IFDEF TIMEX80
  66++66F6 FE 54            cp 'T'
  66++66F8 CC A5 61       call z, TextMode.toggleColor
  67++66FB FE 74            cp 't'
  67++66FD CC A5 61       call z, TextMode.toggleColor
  68++6700                  ENDIF
  69++6700
  70++6700 C3 9E 66         jp plainTextLoop
  71++6703
  72++6703
  73++6703              textDown:
  74++6703 2A 8E 73         ld hl,(page_offset)
  75++6706 11 16 00         ld de,PER_PAGE
  76++6709 19               add hl,de
  77++670A 22 8E 73         ld (page_offset), hl
  78++670D CD 6E 66         call renderPlainTextScreen
  79++6710 C3 9E 66         jp plainTextLoop
  80++6713
  81++6713              textUp:
  82++6713 3A 8E 73         ld a, (page_offset)
  82++6716 FE 00          cp 0
  82++6718 20 0A          jr nz, .textUp2
  83++671A 3A 8F 73         ld a, (page_offset + 1)
  83++671D FE 00          cp 0
  83++671F 20 03          jr nz, .textUp2
  84++6721 C3 9E 66         jp plainTextLoop
  85++6724
  86++6724              .textUp2:
  87++6724 2A 8E 73         ld hl,(page_offset)
  88++6727 11 16 00         ld de,PER_PAGE
  89++672A ED 52            sbc hl,de
  90++672C 22 8E 73         ld (page_offset), hl
  91++672F CD 6E 66         call renderPlainTextScreen
  92++6732 C3 9E 66         jp plainTextLoop
  93++6735
# file closed: gopher/render/plaintext.asm
   9+ 6735
  10+ 6735 00           play_next       db  0
  11+ 6736              position        EQU historyBlock.position
  12+ 6736              cursor_position EQU position + 2
  13+ 6736              page_offset     EQU position + 4
  14+ 6736
  15+ 6736                  ENDMODULE
  16+ 6736
  17+ 6736                  include "dialogbox.asm"
# file opened: gopher/render/dialogbox.asm
   1++6736                  module DialogBox
   2++6736
   3++6736              inputBox:
   4++6736 AF               xor a
   4++6737 32 91 67       ld (inputBuffer), a
   5++673A              .noclear
   6++673A CD F2 67         call drawBox
   7++673D              .loop
   8++673D 11 05 0B         ld de, #0B05
   8++6740 CD 88 61       call TextMode.gotoXY
   9++6743 21 91 67         ld hl, inputBuffer
   9++6746 CD 83 60       call TextMode.printZ
  10++6749 3E B3            ld a, MIME_INPUT
  10++674B CD 8E 60       call TextMode.putC
  10++674E 3E 20          ld a, ' '
  10++6750 CD 8E 60       call TextMode.putC
  11++6753              .checkkey
  12++6753 CD 26 68         call Console.getC
  13++6756 FE 0C            cp Console.BACKSPACE
  13++6758 28 16          jr z, .removeChar
  14++675A FE 0D        	cp CR
  14++675C C8             ret z
  15++675D FE 20            cp SPACE
  15++675F 38 F2          jr c, .checkkey
  16++6761              .putC
  17++6761 5F               ld e, a
  18++6762 AF               xor a
  18++6763 21 91 67 01    ld hl, inputBuffer, bc, #ff
  18++6767 FF 00
  18++6769 ED B1          cpir
  19++676B 77               ld (hl), a
  19++676C 2B             dec hl
  19++676D 73             ld (hl), e
  20++676E 18 CD            jr .loop
  21++6770              .removeChar
  22++6770 AF               xor a
  23++6771 21 91 67 01      ld hl, inputBuffer, bc, #ff
  23++6775 FF 00
  23++6777 ED B1          cpir
  24++6779 E5               push hl
  25++677A 11 92 67             ld de, inputBuffer + 1
  26++677D B7                   or a
  26++677E ED 52          sbc hl, de
  27++6780 7C                   ld a, h
  27++6781 B5             or l
  28++6782 E1               pop hl
  29++6783 28 B8            jr z, .loop
  30++6785 AF               xor a
  31++6786 2B               dec hl
  31++6787 2B             dec hl
  31++6788 77             ld (hl), a
  32++6789 18 B2            jr .loop
  33++678B
  34++678B              	IFNDEF MSX
  35++678B              delayinput:
  36++678B 06 32           ld b, 50
  37++678D              .loop2
  38++678D 76               halt
  39++678E 10 FD            djnz .loop2
  40++6790 C9               ret
  41++6791              namedownload
  42++6791                  IFDEF NEDOOS
  43++6791 ~            		db "..",92,"downloads",92
  44++6791                  ENDIF
  45++6791                  ENDIF
  46++6791 00 00 00...  inputBuffer ds 80
  47++67E1
  48++67E1              msgBox:
  49++67E1 CD EA 67         call msgNoWait
  50++67E4 06 96            ld b, 150
  51++67E6              .loop
  52++67E6 76               halt
  53++67E7 10 FD            djnz .loop
  54++67E9 C9               ret
  55++67EA
  56++67EA              msgNoWait:
  57++67EA E5               push hl
  58++67EB CD F2 67         call drawBox
  59++67EE E1               pop hl
  60++67EF C3 83 60         jp TextMode.printZ
  61++67F2
  62++67F2              drawBox:
  63++67F2 26 0A 3E B2      ld h, #0a, a, BORDER_TOP
  64++67F6 CD 76 61         call TextMode.fillLine
  65++67F9 26 0B 3E 20      ld h, #0b, a, ' '
  66++67FD CD 76 61         call TextMode.fillLine
  67++6800 26 0C 3E B1      ld h, #0c, a, BORDER_BOTTOM
  68++6804 CD 76 61         call TextMode.fillLine
  69++6807 3E 0A            ld a, #0a
  70++6809 CD 61 60         call TextMode.highlightLine
  71++680C 3E 0C            ld a, #0c
  72++680E CD 61 60         call TextMode.highlightLine
  73++6811 11 03 0B         ld de,#0B03
  74++6814 CD 88 61         call TextMode.gotoXY
  75++6817 C9               ret
  76++6818                  endmodule
  77++6818
# file closed: gopher/render/dialogbox.asm
# file closed: gopher/render/index.asm
  31  6818                  include "dos/index.asm"
# file opened: dos/index.asm
   1+ 6818              	IFDEF NEDOOS
   2+ 6818 ~            	    include "nedoconsole.asm"
   3+ 6818 ~            		include "nedoos.asm"
   4+ 6818              	ENDIF
   5+ 6818
   6+ 6818              	IFDEF TRDOS
   7+ 6818                  	include "console.asm"
# file opened: dos/console.asm
   1++6818                  module Console
   2++6818              KEY_UP = 11
   3++6818              KEY_DN = 10
   4++6818              KEY_LT = 8
   5++6818              KEY_RT = 9
   6++6818              BACKSPACE = 12
   7++6818 00           keyCode db 0
   8++6819
   9++6819              BASIC_KEY = #5C08
  10++6819
  11++6819              waitForKeyUp:
  12++6819 76           	halt
  13++681A AF              xor a
  13++681B DB FE          in a, (#fe)
  13++681D 2F             cpl
  13++681E E6 1F          and 31
  13++6820 20 F7          jr nz, waitForKeyUp
  14++6822 32 08 5C        ld (BASIC_KEY), a
  15++6825 C9              ret
  16++6826
  17++6826              getC:
  18++6826 AF              xor a
  19++6827 32 08 5C        ld (BASIC_KEY),a
  20++682A              getC2:
  21++682A 3A 08 5C        ld a,(BASIC_KEY)
  22++682D A7              and a
  22++682E 28 FA          jr z, getC2
  23++6830 47              ld b,a
  24++6831 AF              xor a
  24++6832 32 08 5C       ld (BASIC_KEY), a
  25++6835 78              ld a, b
  26++6836 C9              ret
  27++6837
  28++6837              peekC:
  29++6837 AF               xor a
  29++6838 32 08 5C       ld (BASIC_KEY),a
  30++683B CD 3F 68         call inkey
  31++683E C9               ret
  32++683F
  33++683F              inkey:
  34++683F 11 00 00        ld de,0
  35++6842 01 FE FE        ld bc,$fefe
  36++6845 ED 78           in a,(c)
  37++6847 F6 E1           or $e1
  38++6849 FE FF           cp $ff
  39++684B 20 57           jr nz, .keyhitA
  40++684D
  41++684D 1E 05           ld e,5
  42++684F 06 FD           ld b,$fd
  43++6851 ED 78           in a,(c)
  44++6853 F6 E0           or $e0
  45++6855 FE FF           cp $ff
  46++6857 20 4B           jr nz, .keyhitA
  47++6859
  48++6859 1E 0A           ld e,10
  49++685B 06 FB           ld b,$fb
  50++685D ED 78           in a,(c)
  51++685F F6 E0           or $e0
  52++6861 FE FF           cp $ff
  53++6863 20 3F           jr nz, .keyhitA
  54++6865
  55++6865 1E 0F           ld e,15
  56++6867 06 F7           ld b,$f7
  57++6869 ED 78           in a,(c)
  58++686B F6 E0           or $e0
  59++686D FE FF           cp $ff
  60++686F 20 33           jr nz, .keyhitA
  61++6871
  62++6871 1E 14           ld e,20
  63++6873 06 EF           ld b,$ef
  64++6875 ED 78           in a,(c)
  65++6877 F6 E0           or $e0
  66++6879 FE FF           cp $ff
  67++687B 20 27           jr nz, .keyhitA
  68++687D
  69++687D 1E 19           ld e,25
  70++687F 06 DF           ld b,$df
  71++6881 ED 78           in a,(c)
  72++6883 F6 E0           or $e0
  73++6885 FE FF           cp $ff
  74++6887 20 1B           jr nz, .keyhitA
  75++6889
  76++6889 1E 1E           ld e,30
  77++688B 06 BF           ld b,$bf
  78++688D ED 78           in a,(c)
  79++688F F6 E0           or $e0
  80++6891 FE FF           cp $ff
  81++6893 20 0F           jr nz, .keyhitA
  82++6895
  83++6895 1E 23           ld e,35
  84++6897 06 7F           ld b,$7f
  85++6899 ED 78           in a,(c)
  86++689B F6 E2           or $e2
  87++689D FE FF           cp $ff
  88++689F 4F              ld c,a
  89++68A0 20 19           jr nz, .keyhitB
  90++68A2
  91++68A2              .nokey
  92++68A2 AF              xor a
  93++68A3 C9              ret
  94++68A4
  95++68A4              .keyhitA
  96++68A4
  97++68A4 4F              ld c,a
  98++68A5
  99++68A5 78              ld a,b
 100++68A6 2F              cpl
 101++68A7 F6 81           or $81
 102++68A9 DB FE           in a,($fe)
 103++68AB F6 E0           or $e0
 104++68AD FE FF           cp $ff
 105++68AF 20 F1           jr nz, .nokey
 106++68B1
 107++68B1 3E 7F           ld a,$7f
 108++68B3 DB FE           in a,($fe)
 109++68B5 F6 E2           or $e2
 110++68B7 FE FF           cp $ff
 111++68B9 20 E7           jr nz, .nokey
 112++68BB
 113++68BB              .keyhitB
 114++68BB
 115++68BB 06 00           ld b,0
 116++68BD 21 04 68        ld hl,.rowtbl-$e0
 117++68C0 09              add hl,bc
 118++68C1 7E              ld a,(hl)
 119++68C2 FE 05           cp 5
 120++68C4 30 DC           jr nc, .nokey
 121++68C6 83              add a,e
 122++68C7 5F              ld e,a
 123++68C8
 124++68C8 21 04 69        ld hl,.table
 125++68CB 19              add hl,de
 126++68CC
 127++68CC 3E FE           ld a,$fe
 128++68CE DB FE           in a,($fe)
 129++68D0 E6 01           and $01
 130++68D2 20 03           jr nz, .nocaps
 131++68D4 1E 28           ld e,40
 132++68D6 19              add hl,de
 133++68D7
 134++68D7              .nocaps
 135++68D7
 136++68D7 3E 7F           ld a,$7f
 137++68D9 DB FE           in a,($fe)
 138++68DB E6 02           and $02
 139++68DD 20 03           jr nz, .nosym
 140++68DF 1E 50           ld e,80
 141++68E1 19              add hl,de
 142++68E2
 143++68E2              .nosym
 144++68E2
 145++68E2 7E              ld a,(hl)
 146++68E3 C9              ret
 147++68E4
 148++68E4              .rowtbl
 149++68E4 FF FF FF FF     defb 255,255,255,255,255,255,255
 149++68E8 FF FF FF
 150++68EB FF FF FF FF     defb 255,255,255,255,255,255,255,255
 150++68EF FF FF FF FF
 151++68F3 04 FF FF FF     defb 4,255,255,255,255,255,255
 151++68F7 FF FF FF
 152++68FA FF 03 FF FF     defb 255,3,255,255,255,2,255,1
 152++68FE FF 02 FF 01
 153++6902 00 FF           defb 0,255
 154++6904
 155++6904              .table
 156++6904 00 7A 78 63     db 0,'z','x','c','v'      ; CAPS SHIFT, Z, X, C, V
 156++6908 76
 157++6909 61 73 64 66     db 'a','s','d','f','g'      ; A, S, D, F, G
 157++690D 67
 158++690E 71 77 65 72     db 'q','w','e','r','t'      ; Q, W, E, R, T
 158++6912 74
 159++6913 31 32 33 34     db '1','2','3','4','5'      ; 1, 2, 3, 4, 5
 159++6917 35
 160++6918 30 39 38 37     db '0','9','8','7','6'      ; 0, 9, 8, 7, 6
 160++691C 36
 161++691D 70 6F 69 75     db 'p','o','i','u','y'      ; P, O, I, U, Y
 161++6921 79
 162++6922 0D 6C 6B 6A     db 13,'l','k','j','h'       ; ENTER, L, K, J, H
 162++6926 68
 163++6927 20 00 6D 6E     db ' ',0,'m','n','b'      ; SPACE, SYM SHIFT, M, N, B
 163++692B 62
 164++692C
 165++692C                 ; the following are CAPS SHIFTed
 166++692C
 167++692C 00 5A 58 43     db 0,'Z','X','C','V'      ; CAPS SHIFT, Z, X, C, V
 167++6930 56
 168++6931 41 53 44 46     db 'A','S','D','F','G'      ; A, S, D, F, G
 168++6935 47
 169++6936 51 57 45 52     db 'Q','W','E','R','T'      ; Q, W, E, R, T
 169++693A 54
 170++693B 07 06 80 81     db 7,6,128,129,8            ; 1, 2, 3, 4, 5
 170++693F 08
 171++6940 0C 00 09 0B     db 12,0,9,11,10             ; 0, 9, 8, 7, 6
 171++6944 0A
 172++6945 50 4F 49 55     db 'P','O','I','U','Y'      ; P, O, I, U, Y
 172++6949 59
 173++694A 0D 4C 4B 4A     db 13,'L','K','J','H'       ; ENTER, L, K, J, H
 173++694E 48
 174++694F 20 00 4D 4E     db ' ',0,'M','N','B'      ; SPACE, SYM SHIFT, M, N, B
 174++6953 42
 175++6954
 176++6954                 ; the following are SYM SHIFTed
 177++6954
 178++6954 00 3A 60 3F     db 0,':',96,'?','/'       ; CAPS SHIFT, Z, X, C, V
 178++6958 2F
 179++6959 7E 7C 5C 7B     db '~','|',92,'{','}'       ; A, S, D, F, G
 179++695D 7D
 180++695E 83 84 85 3C     db 131,132,133,'<','>'      ; Q, W, E, R, T
 180++6962 3E
 181++6963 21 40 23 24     db '!','@','#','$','%'      ; 1, 2, 3, 4, 5
 181++6967 25
 182++6968 5F 29 28 27     db '_',')','(',39,'&'       ; 0, 9, 8, 7, 6
 182++696C 26
 183++696D 22 3B 82 5D     db 34,';',130,']','['       ; P, O, I, U, Y
 183++6971 5B
 184++6972 0D 3D 2B 2D     db 13,'=','+','-','^'       ; ENTER, L, K, J, H
 184++6976 5E
 185++6977 20 00 2E 2C     db ' ',0,'.',',','*'      ; SPACE, SYM SHIFT, M, N, B
 185++697B 2A
 186++697C
 187++697C                 ; the following are CAPS SHIFTed and SYM SHIFTed ("CTRL" key)
 188++697C
 189++697C 00 1A 18 03     db 0,26,24,3,22           ; CAPS SHIFT, Z, X, C, V
 189++6980 16
 190++6981 01 13 04 06     db 1,19,4,6,7               ; A, S, D, F, G
 190++6985 07
 191++6986 11 17 05 12     db 17,23,5,18,20            ; Q, W, E, R, T
 191++698A 14
 192++698B 1B 1C 1D 1E     db 27,28,29,30,31           ; 1, 2, 3, 4, 5
 192++698F 1F
 193++6990 7F 00 86 60     db 127,0,134,'`',135      ; 0, 9, 8, 7, 6
 193++6994 87
 194++6995 10 0F 09 15     db 16,15,9,21,25            ; P, O, I, U, Y
 194++6999 19
 195++699A 0D 0C 0B 0A     db 13,12,11,10,8            ; ENTER, L, K, J, H
 195++699E 08
 196++699F 20 00 0D 0E     db ' ',0,13,14,2          ; SPACE, SYM SHIFT, M, N, B
 196++69A3 02
 197++69A4
 198++69A4                  endmodule
# file closed: dos/console.asm
   8+ 69A4              		include "trdos.asm"
# file opened: dos/trdos.asm
   1++69A4              ;trdos driver (izzx)
   2++69A4                  MODULE Dos
   3++69A4              ; API methods
   4++69A4              ESX_GETSETDRV = #89
   5++69A4              ESX_FOPEN = #9A
   6++69A4              ESX_FCLOSE = #9B
   7++69A4              ESX_FSYNC = #9C
   8++69A4              ESX_FREAD = #9D
   9++69A4              ESX_FWRITE = #9E
  10++69A4
  11++69A4              ; File modes
  12++69A4              FMODE_READ = #01
  13++69A4              FMODE_WRITE = #06
  14++69A4              FMODE_CREATE = #0E
  15++69A4
  16++69A4                  ; MACRO esxCall func
  17++69A4                  ; rst #8 : db func
  18++69A4                  ; ENDM
  19++69A4
  20++69A4              ;id = 0 файл не открыт
  21++69A4              ;id = 1 файл для чтения
  22++69A4              ;id = 2 файл для записи
  23++69A4              ;id = 3 файл для записи тип TRD
  24++69A4              ;id = 4 файл для записи тип SCL
  25++69A4
  26++69A4              ; HL - filename in ASCIIZ
  27++69A4              loadBuffer:
  28++69A4 06 01            ld b, Dos.FMODE_READ
  28++69A6 CD C0 69       call Dos.fopen
  29++69A9 F5               push af
  30++69AA 21 F8 94 01          ld hl, outputBuffer, bc, #ffff - outputBuffer
  30++69AE 07 6B
  30++69B0 CD AD 6A       call Dos.fread
  31++69B3 21 F8 94             ld hl, outputBuffer
  31++69B6 09             add hl, bc
  31++69B7 AF             xor a
  31++69B8 77             ld (hl), a
  31++69B9 23             inc hl
  31++69BA 77             ld (hl), a
  32++69BB F1               pop af
  33++69BC CD 99 6A         call Dos.fclose
  34++69BF C9               ret
  35++69C0
  36++69C0
  37++69C0              ; Returns:
  38++69C0              ;  A - current drive
  39++69C0              ; getDefaultDrive: ;нигде не используется
  40++69C0                  ; ld a, 0 : esxCall ESX_GETSETDRV
  41++69C0                  ; ret
  42++69C0
  43++69C0
  44++69C0
  45++69C0              ; Opens file on default drive
  46++69C0              ; B - File mode
  47++69C0              ; HL - File name
  48++69C0              ; Returns:
  49++69C0              ;  A - file stream id
  50++69C0              fopen:
  51++69C0                  ; push bc : push hl
  52++69C0                  ; call getDefaultDrive
  53++69C0                  ; pop ix : pop bc
  54++69C0                  ; esxCall ESX_FOPEN
  55++69C0                  ; ret
  56++69C0 78           	ld a,b
  57++69C1 FE 01        	cp FMODE_READ ;если режим открытие файла
  58++69C3 28 06        	jr z,fopen_r
  59++69C5 FE 0E        	cp FMODE_CREATE
  60++69C7 28 39        	jr z,fopen_c ;если режим создание файла
  61++69C9 18 34        	jr fopen_err ;иначе выход
  62++69CB
  63++69CB              fopen_r	;открытие существующего файла на чтение (id=1)
  64++69CB CD 30 6E     			call format_name ;
  65++69CE 0E 13        			ld      c,#13 ;move file info to syst var
  66++69D0 CD 13 3D                 call    #3d13
  67++69D3 0E 0A                    ld      c,#0a ;find file
  68++69D5 CD 13 3D                 call    #3d13
  69++69D8 79                       ld      a,c
  70++69D9 FE FF        			cp 		#ff
  71++69DB 28 22        			jr 		z,fopen_err ;если не нашли файла
  72++69DD 0E 08                    ld      c,#08 ;read file title
  73++69DF CD 13 3D                 call    #3d13
  74++69E2                          ;ld      hl,loadadr ;куда
  75++69E2 ED 5B EB 5C              ld      de,(#5ceb) ;начало файла сектор дорожка
  76++69E6 ED 53 DC 6E              ld      (f_r_cur_trk),de
  77++69EA
  78++69EA 3A EA 5C                 ld      a,(#5cea)
  79++69ED 32 DE 6E                 ld      (f_r_len_sec),a ;длина в секторах
  80++69F0                          ;or      a
  81++69F0                          ;ret     z    ;выход если пустой
  82++69F0
  83++69F0 ED 5B E8 5C  			ld de,(#5CE8) ; длина файла или программной части для BASIC
  84++69F4 ED 53 DF 6E  			ld      (f_r_len),de
  85++69F8
  86++69F8                          ; ld      de,(fcurtrk) ;текущие сектор дорожка
  87++69F8                          ; ld      (#5cf4),de ;восстановим
  88++69F8 AF           			xor a
  89++69F9 3E 01        			ld 		a,1
  90++69FB 32 E1 6E     			ld (f_r_flag),a ;флаг что файл для чтения открыт
  91++69FE              			;id канала будет 1
  92++69FE C9           	ret
  93++69FF
  94++69FF              fopen_err
  95++69FF AF           	xor a ;если никакой файл не открыли, то id = 0
  96++6A00 37           	scf ;флаг ошибки
  97++6A01 C9           	ret
  98++6A02
  99++6A02
 100++6A02              fopen_c	;создание нового файла (id=2-4)
 101++6A02 CD 30 6E     	call format_name ;
 102++6A05              	;выясним, не образ ли это для разворачивания
 103++6A05 21 BF 6E         ld hl, trdExt1
 103++6A08 CD 27 62       call CompareBuff.search
 103++6A0B A7             and a
 103++6A0C 20 1D          jr nz, fopen_c_trd
 104++6A0E 21 C4 6E         ld hl, trdExt2
 104++6A11 CD 27 62       call CompareBuff.search
 104++6A14 A7             and a
 104++6A15 20 14          jr nz, fopen_c_trd
 105++6A17 21 C9 6E     	ld hl, sclExt1
 105++6A1A CD 27 62       call CompareBuff.search
 105++6A1D A7             and a
 105++6A1E 20 3A          jr nz, fopen_c_scl
 106++6A20 21 CE 6E         ld hl, sclExt2
 106++6A23 CD 27 62       call CompareBuff.search
 106++6A26 A7             and a
 106++6A27 20 31          jr nz, fopen_c_scl
 107++6A29
 108++6A29
 109++6A29              fopen_c_2	;создание произвольного файла
 110++6A29 18 D4        	jr 		fopen_err ;пока отключено
 111++6A2B
 112++6A2B              	; ld      c,#13 ;move file info to syst var
 113++6A2B                  ; call    #3d13
 114++6A2B              	; ld de,256 ;запишем пока 1 сектор
 115++6A2B              	; ld hl,#4000 ;возьмём случайные данные из экрана
 116++6A2B                  ; ld      c,#0b ;запись файла CODE
 117++6A2B                  ; call    #3d13
 118++6A2B                  ; ld      a,c
 119++6A2B              	; cp 		#ff
 120++6A2B              	; jr 		z,fopen_err ;если ошибка
 121++6A2B
 122++6A2B                  ; ld      de,(#5ceb) ;начало файла сектор дорожка
 123++6A2B                  ; ld      (f_w_cur_trk),de
 124++6A2B                  ; ld      a,(#5cea)
 125++6A2B                  ; ld      (f_w_len_sec),a ;длина в секторах
 126++6A2B              	; xor a ;id канала будет 2
 127++6A2B              	; ld a,2
 128++6A2B              	; ld (f_w_flag),a ;флаг что файл для записи открыт
 129++6A2B              	; ret
 130++6A2B
 131++6A2B
 132++6A2B
 133++6A2B
 134++6A2B
 135++6A2B              fopen_c_trd	;открытие файла для разворачивания образа trd (id=3)
 136++6A2B 3A 19 5D     	ld a,(#5D19) ;номер дисковода по умолчанию
 137++6A2E C6 41        	add a,"A"
 138++6A30 32 A5 6E     	ld (write_ima_d),a ;подставим букву в запросе
 139++6A33 21 90 6E         ld hl, write_ima
 140++6A36 CD E1 67         call DialogBox.msgBox ;предуреждение
 141++6A39              WAITKEY_trd
 142++6A39 3A 04 5C     	ld 		a,(23556)
 143++6A3C FE FF        	cp 255
 144++6A3E 28 F9        	JR Z,WAITKEY_trd	;ждём любую клавишу
 145++6A40
 146++6A40 11 00 00     	ld      de,0 ;начало сектор дорожка
 147++6A43 ED 53 F4 5C      ld      (#5cf4),de
 148++6A47 AF           	xor a
 149++6A48 32 F1 6E     	ld (sec_shift),a ;переменная
 150++6A4B 21 00 00     	ld hl,0
 151++6A4E 22 E6 6E     	ld (f_w_len+0),hl
 152++6A51 22 E8 6E     	ld (f_w_len+2),hl
 153++6A54 3E 03        	ld a,3 ;id канала
 154++6A56 32 E5 6E     	ld (f_w_flag),a ;флаг что trd для записи открыт
 155++6A59 C9           	ret
 156++6A5A
 157++6A5A
 158++6A5A
 159++6A5A
 160++6A5A              fopen_c_scl	;открытие файла для разворачивания образа scl (id=4)
 161++6A5A 3A 19 5D     	ld a,(#5D19) ;номер дисковода по умолчанию
 162++6A5D C6 41        	add a,"A"
 163++6A5F 32 A5 6E     	ld (write_ima_d),a ;подставим букву в запросе
 164++6A62 21 90 6E         ld hl, write_ima
 165++6A65 CD E1 67         call DialogBox.msgBox ;предуреждение
 166++6A68              WAITKEY_scl
 167++6A68 3A 04 5C     	ld 		a,(23556)
 168++6A6B FE FF        	cp 255
 169++6A6D 28 F9        	JR Z,WAITKEY_scl	;ждём любую клавишу
 170++6A6F
 171++6A6F 11 00 00     	ld      de,0 ;начало сектор дорожка
 172++6A72 ED 53 F4 5C      ld      (#5cf4),de
 173++6A76
 174++6A76 21 00 48     	ld hl,cat_buf ;очистить место для каталога дискеты
 175++6A79 11 01 48     	ld de,cat_buf+1
 176++6A7C 36 00        	ld (hl),0
 177++6A7E 01 FF 08     	ld bc,9*256-1
 178++6A81 ED B0        	ldir
 179++6A83
 180++6A83 CD A5 6C     	call scl_parse ;запуск цикла сборки образа
 181++6A86
 182++6A86 AF           	xor a
 183++6A87 32 F1 6E     	ld (sec_shift),a ;переменная
 184++6A8A              	;ld (scl_que),a
 185++6A8A 21 00 00     	ld hl,0
 186++6A8D 22 E6 6E     	ld (f_w_len+0),hl
 187++6A90 22 E8 6E     	ld (f_w_len+2),hl
 188++6A93 3E 04        	ld a,4 ;id канала
 189++6A95 32 E5 6E     	ld (f_w_flag),a ;флаг что scl для записи открыт
 190++6A98 C9           	ret
 191++6A99
 192++6A99
 193++6A99
 194++6A99              ; A - file stream id
 195++6A99              fclose:
 196++6A99                  ;esxCall ESX_FCLOSE
 197++6A99              	; push af
 198++6A99              ; WAITKEY2	XOR A:IN A,(#FE):CPL:AND #1F:JR Z,WAITKEY2
 199++6A99              	; pop af
 200++6A99 FE 04        	cp 4 ;если scl
 201++6A9B 20 08        	jr nz,fclose2
 202++6A9D 21 00 51     	ld hl,sec_buf ;
 203++6AA0 06 01        	ld b,1
 204++6AA2 CD 84 6C     	call scl_write_buf ;допишем остаток scl, если есть
 205++6AA5
 206++6AA5              fclose2
 207++6AA5 AF           	xor a ;как бы закрываем все файлы
 208++6AA6 32 E1 6E     	ld (f_r_flag),a
 209++6AA9 32 E5 6E     	ld (f_w_flag),a
 210++6AAC C9               ret
 211++6AAD
 212++6AAD
 213++6AAD
 214++6AAD
 215++6AAD              ; A - file stream id
 216++6AAD              ; BC - length
 217++6AAD              ; HL - buffer
 218++6AAD              ; Returns
 219++6AAD              ;  BC - length(how much was actually read)
 220++6AAD              fread: ;(id=1)
 221++6AAD                  ; push hl : pop ix
 222++6AAD                  ; esxCall ESX_FREAD
 223++6AAD              	; push af
 224++6AAD              	; ld a,4
 225++6AAD              	; out (254),a
 226++6AAD              ; WAITKEY	XOR A:IN A,(#FE):CPL:AND #1F:JR Z,WAITKEY
 227++6AAD              	; xor a
 228++6AAD              	; out (254),a
 229++6AAD              	; pop af
 230++6AAD
 231++6AAD FE 01        	cp 1 ;id = 1?
 232++6AAF 20 06        	jr nz,fread_no_chek ;выход если номер потока не = 1
 233++6AB1 3A E1 6E     	ld a,(f_r_flag)
 234++6AB4 B7           	or a
 235++6AB5 20 06        	jr nz,fread_chek ;файл уже открыт?
 236++6AB7              fread_no_chek ;выход с ошибкой
 237++6AB7 AF           	xor a
 238++6AB8 37           	scf ;флаг ошибки
 239++6AB9 01 00 00     	ld bc,0 ;ничего мы не считали
 240++6ABC C9           	ret
 241++6ABD
 242++6ABD              fread_chek
 243++6ABD ED 4B DD 6E  	ld bc,(f_r_len_sec-1) ;загружаем файл целиком, не смотря на то, сколько байт было запрошено
 244++6AC1 0E 05            ld      c,5 ;read читаем целыми секторами
 245++6AC3 ED 5B DC 6E  	ld de,(f_r_cur_trk)
 246++6AC7 CD 13 3D         call    #3d13
 247++6ACA ED 4B DF 6E  	ld bc,(f_r_len) ;возвратим сколько считали байт (длину файла)
 248++6ACE AF           	xor a ;флаги сбросим
 249++6ACF C9               ret
 250++6AD0
 251++6AD0              ; A - file stream id
 252++6AD0              ; BC - length
 253++6AD0              ; HL - buffer
 254++6AD0              ; Returns:
 255++6AD0              ;   BC - actually written bytes
 256++6AD0              fwrite: ;
 257++6AD0                  ; push hl : pop ix
 258++6AD0                  ; esxCall ESX_FWRITE
 259++6AD0
 260++6AD0              	; push af
 261++6AD0              	; ld a,2
 262++6AD0              	; out (254),a
 263++6AD0              ; WAITKEY1	XOR A:IN A,(#FE):CPL:AND #1F:JR Z,WAITKEY1
 264++6AD0              	; xor a
 265++6AD0              	; out (254),a
 266++6AD0              	; pop af
 267++6AD0
 268++6AD0 FE 02        	cp 2 ;id = 2?
 269++6AD2 28 0F        	jr z,fwrite_chek ;проверка id потока
 270++6AD4 FE 03        	cp 3 ;id = 3?
 271++6AD6 28 0D        	jr z,fwrite_chek_trd ;проверка id потока
 272++6AD8 FE 04        	cp 4 ;id = 4?
 273++6ADA CA BF 6B     	jp z,fwrite_chek_scl ;проверка id потока
 274++6ADD
 275++6ADD
 276++6ADD              fwrite_no_chek ;выход с ошибкой
 277++6ADD AF           	xor a
 278++6ADE 37           	scf ;флаг ошибки
 279++6ADF 01 00 00     	ld bc,0 ;ничего мы не записали
 280++6AE2 C9           	ret
 281++6AE3
 282++6AE3              fwrite_chek ;запись произвольного типа файла
 283++6AE3 18 F8        	jr fwrite_no_chek ;пока отключено
 284++6AE5              	; ld a,(f_w_flag)
 285++6AE5              	; or a
 286++6AE5              	; jr z,fwrite_no_chek ;файл уже открыт?
 287++6AE5              	; ld (temp_bc),bc
 288++6AE5              	; ;ld bc,(f_r_len_sec-1) ;
 289++6AE5                  ; ld      c,6 ;пишем целыми секторами
 290++6AE5              	; ld de,(f_w_cur_trk)
 291++6AE5                  ; call    #3d13
 292++6AE5              	; ld bc,(temp_bc) ;возвратим, что сколько запрашивали, столько и считали байт
 293++6AE5              	; xor a ;флаги сбросим
 294++6AE5                  ; ret
 295++6AE5
 296++6AE5
 297++6AE5
 298++6AE5
 299++6AE5
 300++6AE5              fwrite_chek_trd ;запись trd файла (разворачивание образа)
 301++6AE5              	; ld a,2
 302++6AE5              	; out (254),a
 303++6AE5              ; WAITKEY_t	XOR A:IN A,(#FE):CPL:AND #1F:JR Z,WAITKEY_t
 304++6AE5              	; xor a
 305++6AE5              	; out (254),a
 306++6AE5 3A E5 6E     	ld a,(f_w_flag)
 307++6AE8 B7           	or a
 308++6AE9 28 F2        	jr z,fwrite_no_chek ;файл уже открыт?
 309++6AEB ED 43 EB 6E  	ld (temp_bc),bc ;длина
 310++6AEF 22 ED 6E     	ld (temp_hl),hl ;адрес данных
 311++6AF2 78           	ld a,b
 312++6AF3 B1           	or c
 313++6AF4 28 E7        	jr z,fwrite_no_chek ; если длина 0, то выход
 314++6AF6
 315++6AF6              	; ld a,b
 316++6AF6              	; or a
 317++6AF6              	; jr nz,testt1
 318++6AF6              	; nop
 319++6AF6
 320++6AF6              ; testt1
 321++6AF6
 322++6AF6 AF           	xor a
 323++6AF7 32 F3 6E     	ld (sec_part),a ;обнулить переменные
 324++6AFA 32 F2 6E     	ld (sec_shift2),a
 325++6AFD 32 F3 6E     	ld (sec_shift2+1),a
 326++6B00 32 F4 6E     	ld (sec_shift_flag),a
 327++6B03 32 EA 6E     	ld (write_end_flag),a ;
 328++6B06
 329++6B06
 330++6B06 3A F1 6E     	ld a,(sec_shift)
 331++6B09 B7           	or a
 332++6B0A 28 43        	jr z,fwrite_trd3 ;если смещения нет, то первую часть пропустим
 333++6B0C
 334++6B0C
 335++6B0C 4F           	ld c,a
 336++6B0D 06 00        	ld b,0
 337++6B0F 2A EB 6E     	ld hl,(temp_bc) ;проверка заполнится ли целый сектор
 338++6B12 09           	add hl,bc
 339++6B13
 340++6B13 3E 01        	ld a,1
 341++6B15 32 EA 6E     	ld (write_end_flag),a ;флаг что не нужно дописывать остаток
 342++6B18
 343++6B18 7C           	ld a,h
 344++6B19 B7           	or a
 345++6B1A 20 05        	jr nz,fwrite_trd4
 346++6B1C 3E 01        	ld a,1
 347++6B1E 32 F4 6E     	ld (sec_shift_flag),a ;флаг что не заполнен сектор
 348++6B21
 349++6B21              fwrite_trd4
 350++6B21 21 00 51     	ld hl,sec_buf ;буфер последнего сектора
 351++6B24 09           	add hl,bc ;на этой точке остановились
 352++6B25 EB           	ex de,hl
 353++6B26 2A ED 6E     	ld hl,(temp_hl) ;присоединим начало данных в конец предыдущих
 354++6B29              	; ld a,c
 355++6B29              	; or a
 356++6B29              	; jr nz,fwrite_trd2
 357++6B29              	; inc b ;коррекция
 358++6B29              ; fwrite_trd2
 359++6B29              	; ld c,a
 360++6B29 AF           	xor a
 361++6B2A 91           	sub c
 362++6B2B 4F           	ld c,a ;сколько осталось перенести до заполнения сектора
 363++6B2C ED 43 F2 6E  	ld (sec_shift2),bc ;сохраним сколько добавили байт
 364++6B30 ED B0        	ldir
 365++6B32
 366++6B32 3A F4 6E     	ld a,(sec_shift_flag)
 367++6B35 B7           	or a
 368++6B36 20 17        	jr nz,fwrite_trd3 ;если сектор ещё не заполнен писать не будем
 369++6B38
 370++6B38 21 00 51     	ld hl,sec_buf
 371++6B3B ED 5B F4 5C  	ld de,(#5cf4)
 372++6B3F              	;ld (f_w_cur_trk),de	;запомним позицию
 373++6B3F 01 06 01         ld      bc,#0106 ;пишем 1 сектор из буфера
 374++6B42 CD 13 3D         call    #3d13
 375++6B45 79           	ld a,c
 376++6B46 FE FF        	cp 255
 377++6B48 CA DD 6A     	jp z,fwrite_no_chek ;выход если ошибка
 378++6B4B
 379++6B4B AF           	xor a
 380++6B4C 32 EA 6E     	ld (write_end_flag),a ;флаг что нужно дописывать остаток
 381++6B4F              	; ld de,(f_w_cur_trk) ;если сектор ещё не заполнен, останемся на старой позиции
 382++6B4F              	; ld (#5cf4),de
 383++6B4F              	; ld b,1 ;на сектор вперёд
 384++6B4F              	; ld de,(f_w_cur_trk)
 385++6B4F              	; call calc_next_pos
 386++6B4F              	; ld (f_w_cur_trk),de
 387++6B4F
 388++6B4F              fwrite_trd3
 389++6B4F 2A ED 6E     	ld hl,(temp_hl) ;запишем остаток данных
 390++6B52              	;ld a,(sec_shift)
 391++6B52              	;ld c,a
 392++6B52              	;ld b,0
 393++6B52 ED 4B F2 6E  	ld bc,(sec_shift2)
 394++6B56 09           	add hl,bc ;с этой точки пишем
 395++6B57 22 EF 6E     	ld (temp_hl2),hl ;сохраним начало записи второго сектора
 396++6B5A
 397++6B5A 2A EB 6E     	ld hl,(temp_bc) ;вычисление на чём остановимся в этот раз
 398++6B5D A7           	and a
 399++6B5E ED 42        	sbc hl,bc ;вычтем то, что добавили к первому сектору
 400++6B60 4D           	ld c,l
 401++6B61 44           	ld b,h
 402++6B62 30 02        	jr nc,fwrite_trd5
 403++6B64 06 00        	ld b,0 ;коррекция если вышел минус
 404++6B66              fwrite_trd5
 405++6B66 2A ED 6E     	ld hl,(temp_hl)
 406++6B69 09           	add hl,bc
 407++6B6A
 408++6B6A 11 F8 94     	ld de,outputBuffer
 409++6B6D A7           	and a
 410++6B6E ED 52        	sbc hl,de
 411++6B70
 412++6B70 7D           	ld a,l
 413++6B71 32 F1 6E     	ld (sec_shift),a ;смещение на следующий раз
 414++6B74              	;ld hl,(temp_hl)
 415++6B74
 416++6B74
 417++6B74              	; or a
 418++6B74              	; jr z,fwrite_trd1
 419++6B74              	; inc b  ;коррекция количества секторов
 420++6B74
 421++6B74 78           	ld a,b ;нужна проверка на количество секторов!!!
 422++6B75 32 F3 6E     	ld (sec_part),a ;запомним сколько секторов во второй части
 423++6B78
 424++6B78              	;ld a,b
 425++6B78 B7           	or a
 426++6B79 28 16        	jr z,fwrite_trd1 ;если размер данных меньше сектора, то пропустим запись
 427++6B7B
 428++6B7B 2A EF 6E     	ld hl,(temp_hl2)
 429++6B7E              	;push bc
 430++6B7E ED 5B F4 5C  	ld de,(#5cf4)
 431++6B82 0E 06            ld      c,6 ;пишем целыми секторами
 432++6B84 CD 13 3D         call    #3d13
 433++6B87 79           	ld a,c
 434++6B88              	;pop bc
 435++6B88 FE FF        	cp 255
 436++6B8A CA DD 6A     	jp z,fwrite_no_chek ;выход если ошибка
 437++6B8D              	; ld de,(f_w_cur_trk)
 438++6B8D              	; call calc_next_pos
 439++6B8D              	; ld (f_w_cur_trk),de
 440++6B8D
 441++6B8D AF           	xor a
 442++6B8E 32 EA 6E     	ld (write_end_flag),a ;флаг что нужно дописывать остаток
 443++6B91
 444++6B91              fwrite_trd1
 445++6B91 3A EA 6E     	ld a,(write_end_flag) ;нужно записывать остаток?
 446++6B94 B7           	or a
 447++6B95 20 12        	jr nz,fwrite_trd_ex ;не нужно
 448++6B97
 449++6B97 2A EF 6E     	ld hl,(temp_hl2) ;сохраним незаписанный остаток
 450++6B9A 3A F3 6E     	ld a,(sec_part)
 451++6B9D 47           	ld b,a
 452++6B9E 0E 00        	ld c,0
 453++6BA0 09           	add hl,bc
 454++6BA1 11 00 51     	ld de,sec_buf
 455++6BA4 01 00 01     	ld bc,256
 456++6BA7 ED B0        	ldir
 457++6BA9              ;fwrite_trd2
 458++6BA9
 459++6BA9
 460++6BA9              fwrite_trd_ex
 461++6BA9 ED 4B EB 6E  	ld bc,(temp_bc) ;возвратим, что сколько запрашивали, столько и записали байт
 462++6BAD              	;посчитаем общую длину записанного
 463++6BAD 2A E6 6E     	ld hl,(f_w_len)
 464++6BB0 09           	add hl,bc
 465++6BB1 22 E6 6E     	ld (f_w_len),hl
 466++6BB4 30 07        	jr nc,fwrite_trd_ex1
 467++6BB6 2A E8 6E     	ld hl,(f_w_len+2)
 468++6BB9 23           	inc hl
 469++6BBA 22 E8 6E     	ld (f_w_len+2),hl
 470++6BBD
 471++6BBD              fwrite_trd_ex1
 472++6BBD AF           	xor a ;флаги сбросим
 473++6BBE C9               ret
 474++6BBF
 475++6BBF
 476++6BBF
 477++6BBF
 478++6BBF
 479++6BBF              ;------------------scl----------------------
 480++6BBF              fwrite_chek_scl ;запись scl файла (разворачивание образа)
 481++6BBF              	; ld a,2
 482++6BBF              	; out (254),a
 483++6BBF              ; WAITKEY_t	XOR A:IN A,(#FE):CPL:AND #1F:JR Z,WAITKEY_t
 484++6BBF              	; xor a
 485++6BBF              	; out (254),a
 486++6BBF 3A E5 6E     	ld a,(f_w_flag)
 487++6BC2 B7           	or a
 488++6BC3 CA DD 6A     	jp z,fwrite_no_chek ;файл уже открыт?
 489++6BC6 ED 43 EB 6E  	ld (temp_bc),bc ;длина
 490++6BCA 22 ED 6E     	ld (temp_hl),hl ;адрес данных
 491++6BCD 78           	ld a,b
 492++6BCE B1           	or c
 493++6BCF CA DD 6A     	jp z,fwrite_no_chek ; если длина 0, то выход
 494++6BD2
 495++6BD2              	; ld a,b
 496++6BD2              	; or a
 497++6BD2              	; jr nz,testt1
 498++6BD2              	; nop
 499++6BD2
 500++6BD2              ; testt1
 501++6BD2
 502++6BD2 AF           	xor a
 503++6BD3 32 F3 6E     	ld (sec_part),a ;обнулить переменные
 504++6BD6 32 F2 6E     	ld (sec_shift2),a
 505++6BD9 32 F3 6E     	ld (sec_shift2+1),a
 506++6BDC 32 F4 6E     	ld (sec_shift_flag),a
 507++6BDF 32 EA 6E     	ld (write_end_flag),a ;
 508++6BE2
 509++6BE2
 510++6BE2 3A F1 6E     	ld a,(sec_shift)
 511++6BE5 B7           	or a
 512++6BE6 28 38        	jr z,fwrite_scl3 ;если смещения нет, то первую часть пропустим
 513++6BE8
 514++6BE8
 515++6BE8 4F           	ld c,a
 516++6BE9 06 00        	ld b,0
 517++6BEB 2A EB 6E     	ld hl,(temp_bc) ;проверка заполнится ли целый сектор
 518++6BEE 09           	add hl,bc
 519++6BEF
 520++6BEF 3E 01        	ld a,1
 521++6BF1 32 EA 6E     	ld (write_end_flag),a ;флаг что не нужно дописывать остаток
 522++6BF4
 523++6BF4 7C           	ld a,h
 524++6BF5 B7           	or a
 525++6BF6 20 05        	jr nz,fwrite_scl4
 526++6BF8 3E 01        	ld a,1
 527++6BFA 32 F4 6E     	ld (sec_shift_flag),a ;флаг что не заполнен сектор
 528++6BFD
 529++6BFD              fwrite_scl4
 530++6BFD 21 00 51     	ld hl,sec_buf ;буфер последнего сектора
 531++6C00 09           	add hl,bc ;на этой точке остановились
 532++6C01 EB           	ex de,hl
 533++6C02 2A ED 6E     	ld hl,(temp_hl) ;присоединим начало данных в конец предыдущих
 534++6C05              	; ld a,c
 535++6C05              	; or a
 536++6C05              	; jr nz,fwrite_scl2
 537++6C05              	; inc b ;коррекция
 538++6C05              ; fwrite_scl2
 539++6C05              	; ld c,a
 540++6C05 AF           	xor a
 541++6C06 91           	sub c
 542++6C07 4F           	ld c,a ;сколько осталось перенести до заполнения сектора
 543++6C08 ED 43 F2 6E  	ld (sec_shift2),bc ;сохраним сколько добавили байт
 544++6C0C ED B0        	ldir
 545++6C0E
 546++6C0E 3A F4 6E     	ld a,(sec_shift_flag)
 547++6C11 B7           	or a
 548++6C12 20 0C        	jr nz,fwrite_scl3 ;если сектор ещё не заполнен писать не будем
 549++6C14
 550++6C14 21 00 51     	ld hl,sec_buf
 551++6C17              	;ld de,(#5cf4)
 552++6C17              	;ld (f_w_cur_trk),de	;запомним позицию
 553++6C17 06 01            ld      b,#01 ;пишем 1 сектор из буфера
 554++6C19 CD 84 6C         call    scl_write_buf
 555++6C1C              	; ld a,c
 556++6C1C              	; cp 255
 557++6C1C              	; jp z,fwrite_no_chek ;выход если ошибка
 558++6C1C
 559++6C1C AF           	xor a
 560++6C1D 32 EA 6E     	ld (write_end_flag),a ;флаг что нужно дописывать остаток
 561++6C20              	; ld de,(f_w_cur_trk) ;если сектор ещё не заполнен, останемся на старой позиции
 562++6C20              	; ld (#5cf4),de
 563++6C20              	; ld b,1 ;на сектор вперёд
 564++6C20              	; ld de,(f_w_cur_trk)
 565++6C20              	; call calc_next_pos
 566++6C20              	; ld (f_w_cur_trk),de
 567++6C20
 568++6C20              fwrite_scl3
 569++6C20 2A ED 6E     	ld hl,(temp_hl) ;запишем остаток данных
 570++6C23              	;ld a,(sec_shift)
 571++6C23              	;ld c,a
 572++6C23              	;ld b,0
 573++6C23 ED 4B F2 6E  	ld bc,(sec_shift2)
 574++6C27 09           	add hl,bc ;с этой точки пишем
 575++6C28 22 EF 6E     	ld (temp_hl2),hl ;сохраним начало записи второго сектора
 576++6C2B
 577++6C2B 2A EB 6E     	ld hl,(temp_bc) ;вычисление на чём остановимся в этот раз
 578++6C2E A7           	and a
 579++6C2F ED 42        	sbc hl,bc ;вычтем то, что добавили к первому сектору
 580++6C31 4D           	ld c,l
 581++6C32 44           	ld b,h
 582++6C33 30 02        	jr nc,fwrite_scl5
 583++6C35 06 00        	ld b,0 ;коррекция если вышел минус
 584++6C37              fwrite_scl5
 585++6C37 2A ED 6E     	ld hl,(temp_hl)
 586++6C3A 09           	add hl,bc
 587++6C3B
 588++6C3B 11 F8 94     	ld de,outputBuffer
 589++6C3E A7           	and a
 590++6C3F ED 52        	sbc hl,de
 591++6C41
 592++6C41 7D           	ld a,l
 593++6C42 32 F1 6E     	ld (sec_shift),a ;смещение на следующий раз
 594++6C45              	;ld hl,(temp_hl)
 595++6C45
 596++6C45
 597++6C45              	; or a
 598++6C45              	; jr z,fwrite_scl1
 599++6C45              	; inc b  ;коррекция количества секторов
 600++6C45
 601++6C45 78           	ld a,b ;нужна проверка на количество секторов!!!
 602++6C46 32 F3 6E     	ld (sec_part),a ;запомним сколько секторов во второй части
 603++6C49
 604++6C49              	;ld a,b
 605++6C49 B7           	or a
 606++6C4A 28 0A        	jr z,fwrite_scl1 ;если размер данных меньше сектора, то пропустим запись
 607++6C4C
 608++6C4C 2A EF 6E     	ld hl,(temp_hl2)
 609++6C4F              	;push bc
 610++6C4F              	;ld de,(#5cf4)
 611++6C4F                  ;ld      c,6 ;пишем целыми секторами
 612++6C4F CD 84 6C         call    scl_write_buf
 613++6C52              	;ld a,c
 614++6C52              	;pop bc
 615++6C52              	; cp 255
 616++6C52              	; jp z,fwrite_no_chek ;выход если ошибка
 617++6C52              	; ld de,(f_w_cur_trk)
 618++6C52              	; call calc_next_pos
 619++6C52              	; ld (f_w_cur_trk),de
 620++6C52
 621++6C52 AF           	xor a
 622++6C53 32 EA 6E     	ld (write_end_flag),a ;флаг что нужно дописывать остаток
 623++6C56
 624++6C56              fwrite_scl1
 625++6C56 3A EA 6E     	ld a,(write_end_flag) ;нужно записывать остаток?
 626++6C59 B7           	or a
 627++6C5A 20 12        	jr nz,fwrite_scl_ex ;не нужно
 628++6C5C
 629++6C5C 2A EF 6E     	ld hl,(temp_hl2) ;сохраним незаписанный остаток
 630++6C5F 3A F3 6E     	ld a,(sec_part)
 631++6C62 47           	ld b,a
 632++6C63 0E 00        	ld c,0
 633++6C65 09           	add hl,bc
 634++6C66 11 00 51     	ld de,sec_buf
 635++6C69 01 00 01     	ld bc,256
 636++6C6C ED B0        	ldir
 637++6C6E              ;fwrite_scl2
 638++6C6E
 639++6C6E
 640++6C6E              fwrite_scl_ex
 641++6C6E ED 4B EB 6E  	ld bc,(temp_bc) ;возвратим, что сколько запрашивали, столько и записали байт
 642++6C72              	;посчитаем общую длину записанного
 643++6C72 2A E6 6E     	ld hl,(f_w_len)
 644++6C75 09           	add hl,bc
 645++6C76 22 E6 6E     	ld (f_w_len),hl
 646++6C79 30 07        	jr nc,fwrite_scl_ex1
 647++6C7B 2A E8 6E     	ld hl,(f_w_len+2)
 648++6C7E 23           	inc hl
 649++6C7F 22 E8 6E     	ld (f_w_len+2),hl
 650++6C82
 651++6C82              fwrite_scl_ex1
 652++6C82 AF           	xor a ;флаги сбросим
 653++6C83 C9               ret
 654++6C84
 655++6C84
 656++6C84
 657++6C84
 658++6C84
 659++6C84
 660++6C84              scl_write_buf ;заполнение промежуточного буфера
 661++6C84 C5           	push bc ;сколько пакетов указано в b
 662++6C85 11 00 53     	ld de,scl_buf ;перенесём сектор во временный буфер
 663++6C88 01 00 01     	ld bc,256
 664++6C8B ED B0        	ldir
 665++6C8D 22 15 6F     	ld (scl_temp_hl2),hl ;сохраним адрес данных
 666++6C90 3A FD 6E     	ld a,(scl_que) ;проверим флаг что нужны данные
 667++6C93 B7           	or a
 668++6C94 28 08        	jr z,scl_write_buf_ret ;не будем вызывать парсер если не нужны
 669++6C96 21 9E 6C     	ld hl,scl_write_buf_ret ;адрес возврата
 670++6C99 E5           	push hl
 671++6C9A 2A 0F 6F     	ld hl,(scl_parse_ret_adr) ;адрес для продолжения основного цикла сборки
 672++6C9D E9           	jp (hl) ;отдадим пакет 256 байт парсеру
 673++6C9E              scl_write_buf_ret
 674++6C9E 2A 15 6F     	ld hl,(scl_temp_hl2)
 675++6CA1 C1           	pop bc
 676++6CA2 10 E0        	djnz scl_write_buf
 677++6CA4
 678++6CA4 C9           	ret
 679++6CA5
 680++6CA5
 681++6CA5
 682++6CA5              scl_parse ;разбор образа scl в trd, основной цикл
 683++6CA5              	;получить первый сектор
 684++6CA5              ;запрос порции данных по 256 байт
 685++6CA5 22 13 6F     	ld (scl_temp_hl),hl
 686++6CA8 ED 53 17 6F  	ld (scl_temp_de),de
 687++6CAC ED 43 19 6F  	ld (scl_temp_bc),bc
 688++6CB0 3E 01        	ld a,1
 689++6CB2 32 FD 6E     	ld (scl_que),a ;включим флаг что нужны данные
 690++6CB5 21 BC 6C     	ld hl,scl_parse_ret ;сохраним адрес возврата
 691++6CB8 22 0F 6F     	ld (scl_parse_ret_adr),hl
 692++6CBB C9           	ret ;вернёмся для ожидания данных
 693++6CBC              scl_parse_ret
 694++6CBC AF           	xor a
 695++6CBD 32 FD 6E     	ld (scl_que),a
 696++6CC0 2A 13 6F     	ld hl,(scl_temp_hl)
 697++6CC3 ED 5B 17 6F  	ld de,(scl_temp_de)
 698++6CC7 ED 4B 19 6F  	ld bc,(scl_temp_bc)
 699++6CCB
 700++6CCB 11 00 53     	ld de,scl_buf ;проверка метки образа
 701++6CCE 21 F5 6E     	ld hl,scl_sign
 702++6CD1 06 08        	ld b,8
 703++6CD3              scl_parse_chk
 704++6CD3 1A           	ld a,(de)
 705++6CD4 BE           	cp (hl)
 706++6CD5 20 06        	jr nz,scl_parse_chk_no
 707++6CD7 23           	inc hl
 708++6CD8 13           	inc de
 709++6CD9 10 F8        	djnz scl_parse_chk
 710++6CDB 18 10        	jr scl_parse_chk_ok
 711++6CDD              scl_parse_chk_no ;если не совпало, значит плохой образ
 712++6CDD 21 FE 6E         ld hl, scl_err
 713++6CE0 CD E1 67         call DialogBox.msgBox ;предуреждение
 714++6CE3 AF           	xor a
 715++6CE4 32 FD 6E     	ld (scl_que),a ;выключим флаг что нужны данные
 716++6CE7 3E 04        	ld a,4 ;закроем файл
 717++6CE9 CD 99 6A     	call fclose
 718++6CEC C9           	ret
 719++6CED              scl_parse_chk_ok ;сигнатура правильная
 720++6CED
 721++6CED              ;формирование каталога
 722++6CED 3A 08 53     	ld a,(scl_buf+8)
 723++6CF0 32 12 6F     	ld (scl_files),a ;всего файлов
 724++6CF3 32 11 6F     	ld (scl_cat_cycl),a ;цикл
 725++6CF6 21 09 53     	ld hl,scl_buf+9 ;адрес первого заголовка
 726++6CF9 11 00 48     	ld de,cat_buf ;адрес формируемого каталога trd
 727++6CFC              scl_parse_cat2
 728++6CFC 06 0E        	ld b,14 ;14 байт одна запись
 729++6CFE              scl_parse_cat
 730++6CFE 7E           	ld a,(hl)
 731++6CFF 12           	ld (de),a
 732++6D00 13           	inc de
 733++6D01 2C           	inc l ;адрес увеличиваем только в пределах младшего регистра
 734++6D02 20 26        	jr nz,scl_parse_cat1
 735++6D04              	;тут пора запросить следующий сектор
 736++6D04              ;запрос порции данных по 256 байт
 737++6D04 22 13 6F     	ld (scl_temp_hl),hl
 738++6D07 ED 53 17 6F  	ld (scl_temp_de),de
 739++6D0B ED 43 19 6F  	ld (scl_temp_bc),bc
 740++6D0F 3E 01        	ld a,1
 741++6D11 32 FD 6E     	ld (scl_que),a ;включим флаг что нужны данные
 742++6D14 21 1B 6D     	ld hl,scl_parse_ret1 ;сохраним адрес возврата
 743++6D17 22 0F 6F     	ld (scl_parse_ret_adr),hl
 744++6D1A C9           	ret ;вернёмся для ожидания данных
 745++6D1B              scl_parse_ret1
 746++6D1B AF           	xor a
 747++6D1C 32 FD 6E     	ld (scl_que),a
 748++6D1F 2A 13 6F     	ld hl,(scl_temp_hl)
 749++6D22 ED 5B 17 6F  	ld de,(scl_temp_de)
 750++6D26 ED 4B 19 6F  	ld bc,(scl_temp_bc)
 751++6D2A
 752++6D2A              scl_parse_cat1
 753++6D2A 10 D2        	djnz scl_parse_cat
 754++6D2C 13           	inc de
 755++6D2D 13           	inc de
 756++6D2E 3A 11 6F     	ld a,(scl_cat_cycl)
 757++6D31 3D           	dec a
 758++6D32 32 11 6F     	ld (scl_cat_cycl),a
 759++6D35 20 C5        	jr nz,scl_parse_cat2
 760++6D37
 761++6D37 22 13 6F     	ld (scl_temp_hl),hl ;запомнить где остановились
 762++6D3A
 763++6D3A              ;подсчёт секторов и дорожек
 764++6D3A DD E5        	push ix
 765++6D3C 3A 12 6F     	ld a,(scl_files)
 766++6D3F 11 00 01     	ld de,#0100 ;данные с первой дорожки
 767++6D42 DD 21 00 48  	ld ix,cat_buf
 768++6D46 DD 73 0E     	ld (ix+14),e
 769++6D49 DD 72 0F     	ld (ix+15),d
 770++6D4C 21 00 00     	ld hl,0 ;общее количество секторов
 771++6D4F              scl_cacl
 772++6D4F 32 11 6F     	ld (scl_cat_cycl),a ;цикл
 773++6D52 DD 7E 0D     	ld a,(ix+13) ;длина файла в секторах
 774++6D55 4F           	ld c,a
 775++6D56 06 00        	ld b,0
 776++6D58 09           	add hl,bc ;секторов
 777++6D59
 778++6D59 01 10 00     	ld bc,16
 779++6D5C DD 09        	add ix,bc
 780++6D5E 47           	ld b,a
 781++6D5F CD 84 6E     	call calc_next_pos
 782++6D62 3A 11 6F     	ld a,(scl_cat_cycl)
 783++6D65 FE 01        	cp 1
 784++6D67 28 06        	jr z,scl_cacl2 ;в последний раз пропусим
 785++6D69 DD 73 0E     	ld (ix+14),e
 786++6D6C DD 72 0F     	ld (ix+15),d
 787++6D6F              scl_cacl2
 788++6D6F 3D           	dec a
 789++6D70 20 DD        	jr nz,scl_cacl
 790++6D72              	;теперь узнаем первый свободный сектор
 791++6D72 DD 7E 0D     	ld a,(ix+13) ;длина файла в секторах
 792++6D75 4F           	ld c,a
 793++6D76 06 00        	ld b,0
 794++6D78 09           	add hl,bc
 795++6D79              	; ld b,a
 796++6D79              	; call calc_next_pos
 797++6D79 ED 53 E1 50  	ld (cat_buf+8*256+#e1),de ;Первый свободный сектор и дорожка на дискете
 798++6D7D 11 F0 09     	ld de,16*159
 799++6D80 EB           	ex de,hl
 800++6D81 A7           	and a
 801++6D82 ED 52        	sbc hl,de
 802++6D84 22 E5 50     	ld (cat_buf+8*256+#e5),hl ;Число свободных секторов на диске
 803++6D87 DD E1        	pop ix
 804++6D89
 805++6D89
 806++6D89
 807++6D89              ;запись содержимого файлов
 808++6D89 3A 12 6F     	ld a,(scl_files) ;всего файлов
 809++6D8C 32 11 6F     	ld (scl_cat_cycl),a ;цикл
 810++6D8F 21 0D 48     	ld hl,cat_buf+13 ;адрес размер секторов файла
 811++6D92 22 1B 6F     	ld (cat_cur_adr),hl
 812++6D95
 813++6D95 21 00 01     	ld hl,#0100 ;начиная с первой дорожки
 814++6D98 22 F4 5C     	ld (#5cf4),hl
 815++6D9B              scl_parse_file2
 816++6D9B 2A 13 6F     	ld hl,(scl_temp_hl) ;адрес данных
 817++6D9E ED 5B 1B 6F  	ld de,(cat_cur_adr) ;адрес сектор дорожка файла
 818++6DA2              	;dec de
 819++6DA2 1A           	ld a,(de) ;количество секторов, цикл
 820++6DA3 4F           	ld c,a
 821++6DA4              scl_parse_file3
 822++6DA4 11 00 55     	ld de,scl_buf2 ;адрес ещё одного буфера
 823++6DA7 06 00        	ld b,0 ;256 байт один сектор, цикл
 824++6DA9              scl_parse_file
 825++6DA9 7E           	ld a,(hl)
 826++6DAA 12           	ld (de),a
 827++6DAB 13           	inc de
 828++6DAC 2C           	inc l ;адрес увеличиваем только в пределах младшего регистра
 829++6DAD 20 26        	jr nz,scl_parse_file1
 830++6DAF              	;тут пора запросить следующий сектор
 831++6DAF              ;запрос порции данных по 256 байт
 832++6DAF 22 13 6F     	ld (scl_temp_hl),hl
 833++6DB2 ED 53 17 6F  	ld (scl_temp_de),de
 834++6DB6 ED 43 19 6F  	ld (scl_temp_bc),bc
 835++6DBA 3E 01        	ld a,1
 836++6DBC 32 FD 6E     	ld (scl_que),a ;включим флаг что нужны данные
 837++6DBF 21 C6 6D     	ld hl,scl_parse_ret2 ;сохраним адрес возврата
 838++6DC2 22 0F 6F     	ld (scl_parse_ret_adr),hl
 839++6DC5 C9           	ret ;вернёмся для ожидания данных
 840++6DC6              scl_parse_ret2
 841++6DC6 AF           	xor a
 842++6DC7 32 FD 6E     	ld (scl_que),a
 843++6DCA 2A 13 6F     	ld hl,(scl_temp_hl)
 844++6DCD ED 5B 17 6F  	ld de,(scl_temp_de)
 845++6DD1 ED 4B 19 6F  	ld bc,(scl_temp_bc)
 846++6DD5
 847++6DD5              scl_parse_file1
 848++6DD5 10 D2        	djnz scl_parse_file
 849++6DD7 22 13 6F     	ld (scl_temp_hl),hl
 850++6DDA ED 43 19 6F  	ld (scl_temp_bc),bc
 851++6DDE
 852++6DDE 21 00 55     	ld hl,scl_buf2 ;;запишем один сектор
 853++6DE1 ED 5B F4 5C  	ld  de,(#5cf4)
 854++6DE5 01 06 01         ld      bc,#0106 ;
 855++6DE8 CD 13 3D         call    #3d13
 856++6DEB              	; ld a,c
 857++6DEB              	; cp 255
 858++6DEB              	; jp z,fwrite_no_chek ;выход если ошибка
 859++6DEB 2A 13 6F     	ld hl,(scl_temp_hl)
 860++6DEE ED 4B 19 6F  	ld bc,(scl_temp_bc)
 861++6DF2
 862++6DF2 0D           	dec c
 863++6DF3 20 AF        	jr nz,scl_parse_file3
 864++6DF5
 865++6DF5 2A 1B 6F     	ld hl,(cat_cur_adr) ;адрес сектор дорожка файла
 866++6DF8              	; ld e,(hl)
 867++6DF8              	; inc hl
 868++6DF8              	; ld d,(hl)
 869++6DF8 01 10 00     	ld bc,16
 870++6DFB 09           	add hl,bc ;на следующий файл
 871++6DFC 22 1B 6F     	ld (cat_cur_adr),hl
 872++6DFF
 873++6DFF
 874++6DFF 3A 11 6F     	ld a,(scl_cat_cycl)
 875++6E02 3D           	dec a
 876++6E03 32 11 6F     	ld (scl_cat_cycl),a
 877++6E06 20 93        	jr nz,scl_parse_file2	;на следующий файл
 878++6E08
 879++6E08
 880++6E08
 881++6E08              ;формирование системного сектора №9 (8)
 882++6E08              	;
 883++6E08              	;ld (cat_buf+8*256+#e1),a ;// #E1 Первый свободный сектор на дискете
 884++6E08              	;
 885++6E08              	;ld (cat_buf+8*256+#e2),a ;// #E2 Первый свободный трек
 886++6E08 3E 16        	ld a,#16
 887++6E0A 32 E3 50     	ld (cat_buf+8*256+#e3),a ;// #E3 16 80 дорожек, 2 стороны
 888++6E0D 3A 12 6F     	ld a,(scl_files)
 889++6E10 32 E4 50     	ld (cat_buf+8*256+#e4),a ;// #E4 Общее количество файлов записанных на диск
 890++6E13              	;
 891++6E13              	;ld (cat_buf+8*256+#e5),a ;// #Е5,Е6 Число свободных секторов на диске
 892++6E13              	;ld (cat_buf+8*256+#e6),a
 893++6E13 3E 10        	ld a,#10
 894++6E15 32 E7 50     	ld (cat_buf+8*256+#e7),a ;// #E7 Код  #10,определяющий принадлежность к TR-DOS
 895++6E18
 896++6E18 21 D3 6E     	ld hl,f_name ;запишем имя диска, взяв для этого имя файла
 897++6E1B 11 F5 50     	ld de,cat_buf+8*256+#f5 ;// #F5-#FC Имя диска в ASCII формате
 898++6E1E 01 08 00     	ld bc,8
 899++6E21 ED B0        	ldir
 900++6E23
 901++6E23 21 00 48     	ld hl,cat_buf ;запишем каталог на диск
 902++6E26 11 00 00     	ld de,0
 903++6E29 01 06 09         ld      bc,#0906 ;
 904++6E2C CD 13 3D         call    #3d13
 905++6E2F              	; ld a,c
 906++6E2F              	; cp 255
 907++6E2F              	; jp z,fwrite_no_chek ;выход если ошибка
 908++6E2F C9           	ret
 909++6E30
 910++6E30
 911++6E30              ;-----------scl end --------------------
 912++6E30
 913++6E30
 914++6E30
 915++6E30
 916++6E30
 917++6E30
 918++6E30
 919++6E30
 920++6E30
 921++6E30
 922++6E30              ; A - file stream id
 923++6E30              ; fsync:
 924++6E30              ;     esxCall ESX_FSYNC
 925++6E30                  ; ret
 926++6E30
 927++6E30
 928++6E30              ; HL - name (name.ext)
 929++6E30              ; Returns:
 930++6E30              ; HL - name (name    e)
 931++6E30              format_name ;подгоняет имя файла под стандарт trdos (8+1)
 932++6E30
 933++6E30              	;сначала попробуем убрать из пути подпапку, если она есть
 934++6E30 22 ED 6E     	ld (temp_hl),hl ;сохраним адрес исходного имени
 935++6E33 06 00        	ld b,#00 ;не больше 255 символов
 936++6E35              format_name5
 937++6E35 7E           	ld a,(hl)
 938++6E36 FE 2F        	cp "/" ;если есть подпапка
 939++6E38 28 0D        	jr z,format_name_path_yep
 940++6E3A 7E           	ld a,(hl)
 941++6E3B FE 2E        	cp "." ;если ещё не дошли до расширения
 942++6E3D 20 05        	jr nz,format_name6
 943++6E3F 2A ED 6E     	ld hl,(temp_hl) ;если дошли до расширения, то путей нет, вернёмся на начало имени
 944++6E42 18 04        	jr format_name_7 ;на выход
 945++6E44              format_name6
 946++6E44 23           	inc hl
 947++6E45 10 EE        	djnz format_name5
 948++6E47
 949++6E47              format_name_path_yep ;нашли
 950++6E47 23           	inc hl ;пропустим знак "/"
 951++6E48
 952++6E48              format_name_7
 953++6E48
 954++6E48
 955++6E48 E5           	push hl ;очистим место для нового имени
 956++6E49 21 D3 6E     	ld hl,f_name
 957++6E4C 11 D4 6E     	ld de,f_name+1
 958++6E4F 36 20        	ld (hl)," "
 959++6E51 01 08 00     	ld bc,8
 960++6E54 ED B0        	ldir
 961++6E56 E1           	pop hl
 962++6E57
 963++6E57 01 FF 09     	ld bc,#09ff ;длина имени 9 символов
 964++6E5A 11 D3 6E     	ld de,f_name ;куда
 965++6E5D              format_name2
 966++6E5D 7E           	ld a,(hl)
 967++6E5E FE 2E        	cp "."
 968++6E60 20 08        	jr nz,format_name1
 969++6E62 23           	inc hl
 970++6E63 7E           	ld a,(hl)
 971++6E64 32 DB 6E     	ld (f_name+8),a ; и в конце первую букву расширения
 972++6E67 EB           	ex de,hl ;сохраним адрес исходного расширения
 973++6E68 18 16        	jr format_name_e
 974++6E6A              format_name1
 975++6E6A ED A0        	ldi
 976++6E6C 10 EF        	djnz format_name2
 977++6E6E
 978++6E6E              	;если имя длинное, пропустим лишнее до расширения
 979++6E6E 06 00        	ld b,#00 ;не больше 255 символов
 980++6E70              format_name3
 981++6E70 7E           	ld a,(hl)
 982++6E71 FE 2E        	cp "."
 983++6E73 20 08        	jr nz,format_name4
 984++6E75 23           	inc hl
 985++6E76 7E           	ld a,(hl)
 986++6E77 32 DB 6E     	ld (f_name+8),a ; и в конце первую букву расширения
 987++6E7A EB           	ex de,hl ;сохраним адрес исходного расширения
 988++6E7B 18 03        	jr format_name_e
 989++6E7D              format_name4
 990++6E7D 23           	inc hl
 991++6E7E 10 F0        	djnz format_name3
 992++6E80
 993++6E80              format_name_e ;выход
 994++6E80 21 D3 6E     	ld hl,f_name ;вернём результат
 995++6E83 C9           	ret
 996++6E84
 997++6E84              ; DE - trk/sec
 998++6E84              ; B - sectors step
 999++6E84              ; Returns:
1000++6E84              ; DE - trk/sec
1001++6E84              calc_next_pos		;вперёд на N секторов
1002++6E84              			;ld b,4
1003++6E84              			;ld  de,(#5ceb)
1004++6E84              calc_next_pos2
1005++6E84 1C           			inc e
1006++6E85 7B           			ld a,e
1007++6E86 FE 10        			cp 16
1008++6E88 38 03        			jr c,calc_next_pos1
1009++6E8A 14           			inc d
1010++6E8B 1E 00        			ld e,0
1011++6E8D              calc_next_pos1
1012++6E8D              			;ld (#5ceb),de
1013++6E8D 10 F5        			djnz calc_next_pos2
1014++6E8F C9           			ret
1015++6E90
1016++6E90
1017++6E90              ;testt db "123.trd"
1018++6E90 49 6E 73 65  write_ima db "Insert disk to drive "
1018++6E94 72 74 20 64
1018++6E98 69 73 6B 20
1018++6E9C 74 6F 20 64
1018++6EA0 72 69 76 65
1018++6EA4 20
1019++6EA5 41 2E 20     write_ima_d db "A. "
1020++6EA8 41 6C 6C 20  		db "All data will be lost!",0
1020++6EAC 64 61 74 61
1020++6EB0 20 77 69 6C
1020++6EB4 6C 20 62 65
1020++6EB8 20 6C 6F 73
1020++6EBC 74 21 00
1021++6EBF
1022++6EBF 2E 74 72 64  trdExt1 db ".trd", 0
1022++6EC3 00
1023++6EC4 2E 54 52 44  trdExt2 db ".TRD", 0
1023++6EC8 00
1024++6EC9
1025++6EC9 2E 73 63 6C  sclExt1 db ".scl", 0
1025++6ECD 00
1026++6ECE 2E 53 43 4C  sclExt2 db ".SCL", 0
1026++6ED2 00
1027++6ED3
1028++6ED3 00 00 00...  f_name ds 9 ;имя файла
1029++6EDC 00 00        f_r_cur_trk dw 	 0 ;текущие сектор-дорожка файла на чтение
1030++6EDE 00           f_r_len_sec db 0 ;длина файла на чтение в секторах
1031++6EDF 00 00        f_r_len dw 0;длина файла в байтах
1032++6EE1 00           f_r_flag db 0 ;флаг что открыт файл на чтение
1033++6EE2
1034++6EE2 00 00        f_w_cur_trk dw 	 0 ;текущие сектор-дорожка файла на запись
1035++6EE4 00           f_w_len_sec db 0 ;длина файла на запись в секторах
1036++6EE5 00           f_w_flag db 0 ;флаг что открыт файл на запись
1037++6EE6 00 00 00 00  f_w_len ds 4 ;длина записанных данных
1038++6EEA 00           write_end_flag db 0 ;флаг что нужно записать остаток
1039++6EEB
1040++6EEB 00 00        temp_bc dw 0 ;хранение регистра
1041++6EED 00 00        temp_hl dw 0 ;хранение регистра
1042++6EEF 00 00        temp_hl2 dw 0 ;хранение регистра
1043++6EF1
1044++6EF1 00           sec_shift db 0 ;указатель на каком байте остановлена запись
1045++6EF2 00           sec_shift2 db 0 ;указатель на каком байте остановлена запись (остаток)
1046++6EF3 00           sec_part db 0 ;сколько секторов во второй порции для записи
1047++6EF4 00           sec_shift_flag db 0 ;флаг что буфер сектора не заполнен
1048++6EF5
1049++6EF5              ;секция scl
1050++6EF5 53 49 4E 43  scl_sign db "SINCLAIR" ;метка
1050++6EF9 4C 41 49 52
1051++6EFD 00           scl_que db 0 ;флаг запроса порции данных
1052++6EFE 53 43 4C 20  scl_err db "SCL image error!",0
1052++6F02 69 6D 61 67
1052++6F06 65 20 65 72
1052++6F0A 72 6F 72 21
1052++6F0E 00
1053++6F0F 00 00        scl_parse_ret_adr dw 0; адрес возврата в цикл
1054++6F11 00           scl_cat_cycl db 0 ;переменная цикла
1055++6F12 00           scl_files db 0 ;всего файлов
1056++6F13 00 00        scl_temp_hl dw 0;;хранение регистра
1057++6F15 00 00        scl_temp_hl2 dw 0;
1058++6F17 00 00        scl_temp_de dw 0;
1059++6F19 00 00        scl_temp_bc dw 0;
1060++6F1B 00 00        cat_cur_adr dw 0;
1061++6F1D              ;scl end
1062++6F1D 00 00 00...  	align 256 ;временно
1063++7000              	;по адресу #4000 шрифт
1064++7000              cat_buf equ #4800 ;буфер для кататога диска 9*256
1065++7000              sec_buf equ cat_buf + 9*256 ;буфер сектора для записи 256
1066++7000              scl_buf equ sec_buf + 512 ;промежуточный буфер 256
1067++7000              scl_buf2 equ scl_buf + 512 ;промежуточный буфер 256
1068++7000
1069++7000                  ENDMODULE
# file closed: dos/trdos.asm
   9+ 7000              	ENDIF
  10+ 7000
  11+ 7000              	IFDEF ESXDOS
  12+ 7000 ~               		include "console.asm"
  13+ 7000 ~               		include "esxdos.asm"
  14+ 7000              	ENDIF
  15+ 7000
  16+ 7000              	IFDEF P3DOS
  17+ 7000 ~               		include "console.asm"
  18+ 7000 ~               		include "p3dos.asm"
  19+ 7000              	ENDIF
  20+ 7000
# file closed: dos/index.asm
  32  7000                  include "gopher/engine/history/index.asm"
# file opened: gopher/engine/history/index.asm
   1+ 7000                  include "controler.asm"
# file opened: gopher/engine/history/controler.asm
   1++7000                  module History
   2++7000              back:
   3++7000 3A 43 71         ld a, (depth)
   3++7003 FE 01          cp 1
   3++7005 CA 17 70       jp z, load
   4++7008 21 92 73 11      ld hl, historyBlock + HistoryRecord, de, historyBlock, bc, (total - 1) * HistoryRecord
   4++700C 44 71 01 38
   4++7010 09
   4++7011 ED B0          ldir ; Move history up
   5++7013 21 43 71         ld hl, depth
   5++7016 35             dec (hl)
   6++7017              ; Loads current resource
   7++7017              load:
   8++7017 21 34 70         ld hl, .msg
   8++701A CD EA 67       call DialogBox.msgNoWait
   9++701D AF               xor a
   9++701E 21 F8 94 11    ld hl, outputBuffer, de, outputBuffer + 1
   9++7022 F9 94
  10++7024              	IFDEF MSX
  11++7024 ~                	ld bc, (ramtop)
  12++7024 ~                	dec bc
  13++7024              	ELSE
  14++7024 01 06 6B         	ld bc, #ffff - outputBuffer - 1
  15++7027              	ENDIF
  16++7027
  17++7027 77               ld (hl), a
  18++7028 ED B0            ldir
  19++702A
  20++702A 3A 44 71         ld a, (historyBlock.isFile)
  20++702D A7             and a
  20++702E C2 2D 81       jp nz, Fetcher.fetchFromFS
  21++7031 C3 E0 80         jp Fetcher.fetchFromNet
  22++7034
  23++7034 20 20 20 20  .msg db "    Loading resource! Please wait! It will be here soon!", 0
  23++7038 4C 6F 61 64
  23++703C 69 6E 67 20
  23++7040 72 65 73 6F
  23++7044 75 72 63 65
  23++7048 21 20 50 6C
  23++704C 65 61 73 65
  23++7050 20 77 61 69
  23++7054 74 21 20 49
  23++7058 74 20 77 69
  23++705C 6C 6C 20 62
  23++7060 65 20 68 65
  23++7064 72 65 20 73
  23++7068 6F 6F 6E 21
  23++706C 00
  24++706D
  25++706D              home:
  26++706D 21 21 71         ld hl, homePage
  27++7070              ; HL - gopher row
  28++7070              navigate:
  29++7070 54 5D            ld de, hl
  30++7072 CD 59 7F         call UrlEncoder.isValidGopherRow
  31++7075 30 A0            jr nc, load ; Not valid - reload last
  32++7077 62 6B            ld hl, de
  33++7079 E5               push hl
  34++707A
  35++707A E5               push hl
  36++707B 21 C9 7C 11      ld hl, HistoryEnd - HistoryRecord, de, HistoryEnd, bc,  HistoryRecord * total
  36++707F 17 7F 01 86
  36++7083 0B
  36++7084 ED B8          lddr
  37++7086
  38++7086 ED 5B 8A 73      ld de, (Render.position), (historyBlock.position + HistoryRecord), de
  38++708A ED 53 D8 75
  39++708E                  ; Clean up struct
  40++708E AF               xor a
  40++708F 21 44 71 11    ld hl, historyBlock, de, historyBlock + 1, bc, historyBlockSize - 1, (hl), a
  40++7093 45 71 01 4D
  40++7097 02 77
  40++7099 ED B0          ldir
  41++709B E1               pop hl
  42++709C
  43++709C                  ; Fill record
  44++709C 54 5D            ld de, hl
  45++709E CD 18 7F         call UrlEncoder.isFile
  46++70A1 EB               ex hl, de
  47++70A2 11 44 71         ld de, historyBlock
  48++70A5 12               ld (de), a
  48++70A6 13             inc de
  49++70A7 7E               ld a, (hl)
  49++70A8 E5 D5          push hl, de
  49++70AA CD C3 62       call Render.getIcon
  49++70AD D1 E1          pop de, hl
  50++70AF 12               ld (de), a
  50++70B0 13             inc de
  51++70B1 3E 09            ld a, 9
  52++70B3
  53++70B3                  IFDEF MSX
  54++70B3 ~                	ld bc, #ff
  55++70B3                  ELSE
  56++70B3 01 FF 0F         	ld bc, #fff
  57++70B6                  ENDIF
  58++70B6
  59++70B6 ED B1            cpir
  60++70B8              .locatorCopy
  61++70B8 7E               ld a, (hl)
  61++70B9 FE 09          cp 9
  61++70BB 28 05          jr z, 1f
  62++70BD 12               ld (de), a
  62++70BE 23 13          inc hl, de
  63++70C0 18 F6            jr .locatorCopy
  64++70C2              1
  65++70C2 23               inc hl
  65++70C3 AF             xor a
  65++70C4 12             ld (de), a
  66++70C5 11 45 72         ld de, historyBlock.host
  67++70C8              .hostCopy
  68++70C8 7E               ld a, (hl)
  68++70C9 FE 09          cp 9
  68++70CB 28 05          jr z, 1f
  69++70CD 12               ld (de), a
  69++70CE 23 13          inc hl, de
  70++70D0 18 F6            jr .hostCopy
  71++70D2              1
  72++70D2 23               inc hl
  72++70D3 AF             xor a
  72++70D4 12             ld (de), a
  73++70D5 11 85 72         ld de, historyBlock.port
  74++70D8              .portCopy
  75++70D8 7E               ld a, (hl)
  76++70D9 FE 09            cp 9
  76++70DB 28 11          jr z, 1f
  77++70DD FE 0D            cp 13
  77++70DF 28 0D          jr z, 1f
  78++70E1 FE 0A            cp 10
  78++70E3 28 09          jr z, 1f
  79++70E5 FE 00            cp 0
  79++70E7 28 05          jr z, 1f
  80++70E9 12               ld (de), a
  80++70EA 23 13          inc hl, de
  81++70EC 18 EA            jr .portCopy
  82++70EE AF           1   xor a
  82++70EF 12             ld (de), a
  83++70F0 21 91 67 11      ld hl, DialogBox.inputBuffer, de, historyBlock.search, bc, #ff
  83++70F4 8B 72 01 FF
  83++70F8 00
  83++70F9 ED B0          ldir
  84++70FB 11 00 00 ED      ld de, 0, (historyBlock.position), de
  84++70FF 53 8A 73
  85++7102 E1               pop hl
  86++7103 3A 43 71         ld a, (depth)
  86++7106 FE 05          cp total
  86++7108 30 04          jr nc, 1f
  87++710A 3C               inc a
  87++710B 32 43 71       ld (depth), a
  88++710E              1
  89++710E 3A 45 71         ld a,(historyBlock.mediaType)
  89++7111 FE 19          cp MIME_DOWNLOAD
  89++7113 CA C8 81       jp z, Gopher.download
  90++7116
  91++7116                  ifdef GS
  92++7116 ~                ld a,(historyBlock.mediaType)
  93++7116 ~                cp MIME_MOD
  94++7116 ~                jp nz,load
  95++7116 ~                ld a,(GeneralSound.GSdownType)
  96++7116 ~                xor 1
  97++7116 ~                jp z, downMod2file
  98++7116 ~
  99++7116 ~            downMod2GS
 100++7116 ~                jp Gopher.loadMod
 101++7116 ~            downMod2file
 102++7116 ~                jp Gopher.download
 103++7116                  else
 104++7116 3A 45 71         ld a,(historyBlock.mediaType)
 104++7119 FE 0D          cp MIME_MOD
 104++711B CA C8 81       jp z, Gopher.download
 105++711E                  endif
 106++711E
 107++711E C3 17 70         jp load
 108++7121
 109++7121              homePage:
 110++7121              	IFDEF MSX
 111++7121 ~                	db "1Home", TAB, "index.gph"
 112++7121 ~                	db TAB, "file", TAB, "70", CR, LF, 0
 113++7121                  ELSE
 114++7121 31 48 6F 6D      	db "1Home", TAB, "browser/index.gph"
 114++7125 65 09 62 72
 114++7129 6F 77 73 65
 114++712D 72 2F 69 6E
 114++7131 64 65 78 2E
 114++7135 67 70 68
 115++7138 09 66 69 6C      	db TAB, "file", TAB, "70", CR, LF, 0
 115++713C 65 09 37 30
 115++7140 0D 0A 00
 116++7143                  ENDIF
 117++7143                  endmodule
# file closed: gopher/engine/history/controler.asm
   2+ 7143                  include "model.asm"
# file opened: gopher/engine/history/model.asm
   1++7143              total   equ 5
   2++7143 00           depth   db 0
   3++7144
   4++7144              historyBlock:
   5++7144 00           .isFile    db  0
   6++7145 00           .mediaType db  0
   7++7146 00 00 00...  .locator   ds  #ff
   8++7245 00 00 00...  .host      ds  64
   9++7285 00 00 00...  .port      ds  6
  10++728B 00 00 00...  .search    ds  #ff
  11++738A 00 00        .position  dw  #0000    ;position
  12++738C
  13++738C 00 00 00 00      db 0,0,0,0,0,0  ;cursor_position page_offset
  13++7390 00 00
  14++7392
  15++7392              historyBlockSize = $ - historyBlock
  16++7392
  17++7392              HistoryRecord EQU $ - historyBlock
  18++7392                  dup total
  19++7392 00 00 00... >    ds HistoryRecord
  19++75E0 00 00 00... >    ds HistoryRecord
  19++782E 00 00 00... >    ds HistoryRecord
  19++7A7C 00 00 00... >    ds HistoryRecord
  19++7CCA 00 00 00... >    ds HistoryRecord
  20++7F18                  edup
  21++7F18              HistoryEnd equ $ - 1
  22++7F18
# file closed: gopher/engine/history/model.asm
# file closed: gopher/engine/history/index.asm
  33  7F18                  include "gopher/engine/urlencoder.asm"
# file opened: gopher/engine/urlencoder.asm
   1+ 7F18                  MODULE UrlEncoder
   2+ 7F18              ; HL - pointer to line in gopher page
   3+ 7F18              ; C - flag set when it's file
   4+ 7F18              isFile:
   5+ 7F18              .findServerLoop
   6+ 7F18 7E               ld a, (hl)
   6+ 7F19 A7             and a
   6+ 7F1A 28 3B          jr z, .notFile
   6+ 7F1C 23             inc hl
   7+ 7F1D FE 0D            cp 13
   7+ 7F1F 28 36          jr z, .notFile
   8+ 7F21 FE 09            cp 9
   8+ 7F23 28 02          jr z, .skipPath
   9+ 7F25 18 F1            jr .findServerLoop
  10+ 7F27              .skipPath
  11+ 7F27 7E               ld a, (hl)
  11+ 7F28 A7             and a
  11+ 7F29 28 2C          jr z, .notFile
  11+ 7F2B 23             inc hl
  12+ 7F2C FE 0D            cp 13
  12+ 7F2E 28 27          jr z, .notFile
  13+ 7F30 FE 09            cp 9
  13+ 7F32 28 02          jr z, .compareServer
  14+ 7F34 18 F1            jr .skipPath
  15+ 7F36              .compareServer
  16+ 7F36 7E               ld a, (hl)
  16+ 7F37 FE 66          cp "f"
  16+ 7F39 20 1C          jr nz, .notFile
  16+ 7F3B 23             inc hl
  17+ 7F3C 7E               ld a, (hl)
  17+ 7F3D FE 69          cp "i"
  17+ 7F3F 20 16          jr nz, .notFile
  17+ 7F41 23             inc hl
  18+ 7F42 7E               ld a, (hl)
  18+ 7F43 FE 6C          cp "l"
  18+ 7F45 20 10          jr nz, .notFile
  18+ 7F47 23             inc hl
  19+ 7F48 7E               ld a, (hl)
  19+ 7F49 FE 65          cp "e"
  19+ 7F4B 20 0A          jr nz, .notFile
  19+ 7F4D 23             inc hl
  20+ 7F4E 7E               ld a, (hl)
  20+ 7F4F FE 09          cp 9
  20+ 7F51 20 04          jr nz, .notFile
  20+ 7F53 23             inc hl
  21+ 7F54 3E 01            ld a, 1
  22+ 7F56 C9               ret
  23+ 7F57              .notFile
  24+ 7F57 AF               xor a
  25+ 7F58 C9               ret
  26+ 7F59
  27+ 7F59              ; Is enough fields to encode
  28+ 7F59              ; HL - pointer to line in gopher page
  29+ 7F59              ; C - flag set when there is enough fields
  30+ 7F59              isValidGopherRow:
  31+ 7F59 7E               ld a, (hl)
  31+ 7F5A A7             and a
  31+ 7F5B 28 FA          jr z, isFile.notFile
  31+ 7F5D 23             inc hl
  32+ 7F5E FE 0D            cp 13
  32+ 7F60 28 F5          jr z, isFile.notFile
  33+ 7F62 FE 09            cp 9
  33+ 7F64 28 02          jr z, .skipPath
  34+ 7F66 18 F1            jr isValidGopherRow
  35+ 7F68              .skipPath
  36+ 7F68 7E               ld a, (hl)
  36+ 7F69 A7             and a
  36+ 7F6A 28 EB          jr z, isFile.notFile
  36+ 7F6C 23             inc hl
  37+ 7F6D FE 0D            cp 13
  37+ 7F6F 28 E6          jr z, isFile.notFile
  38+ 7F71 FE 09            cp 9
  38+ 7F73 28 02          jr z, .skipHost
  39+ 7F75 18 F1            jr .skipPath
  40+ 7F77              .skipHost
  41+ 7F77 7E               ld a, (hl)
  41+ 7F78 A7             and a
  41+ 7F79 28 DC          jr z, isFile.notFile
  41+ 7F7B 23             inc hl
  42+ 7F7C FE 0D            cp 13
  42+ 7F7E 28 D7          jr z, isFile.notFile
  43+ 7F80 FE 09            cp 9
  43+ 7F82 28 02           jr z, .isValid
  44+ 7F84 18 F1            jr .skipHost
  45+ 7F86              .isValid:
  46+ 7F86 37               scf
  47+ 7F87 C9               ret
  48+ 7F88
  49+ 7F88              extractPath:
  50+ 7F88 21 46 71 11      ld hl, historyBlock.locator, de, nameBuffer, bc, #ff
  50+ 7F8C A0 7F 01 FF
  50+ 7F90 00
  50+ 7F91 ED B0          ldir
  51+ 7F93 C9               ret
  52+ 7F94
  53+ 7F94              extractHostName:
  54+ 7F94 21 45 72 11      ld hl, historyBlock.host, de, hostName, bc, 64
  54+ 7F98 A0 80 01 40
  54+ 7F9C 00
  54+ 7F9D ED B0          ldir
  55+ 7F9F C9               ret
  56+ 7FA0
  57+ 7FA0                  ENDMODULE
  58+ 7FA0
  59+ 7FA0 00 00 00...  nameBuffer ds #ff, 0
  60+ 809F
  61+ 809F 00                    db 0
  62+ 80A0 00 00 00...  hostName ds 64
# file closed: gopher/engine/urlencoder.asm
  34  80E0                  include "gopher/engine/fetcher.asm"
# file opened: gopher/engine/fetcher.asm
   1+ 80E0                  MODULE Fetcher
   2+ 80E0
   3+ 80E0              fetchFromNet:
   4+ 80E0
   5+ 80E0              	IFDEF MSX
   6+ 80E0 ~                	call Gopher.makeRequest
   6+ 80E0 ~              jr nz, .error
   7+ 80E0                  ELSE
   8+ 80E0 CD 9D 81         	call Gopher.makeRequest
   8+ 80E3 38 06          jr c, .error
   9+ 80E5                  ENDIF
  10+ 80E5
  11+ 80E5 CD B5 81         call Gopher.loadBuffer
  12+ 80E8 C3 39 81         jp MediaProcessor.processResource
  13+ 80EB              .error
  14+ 80EB 21 F4 80         ld hl, .err
  14+ 80EE CD E1 67       call DialogBox.msgBox
  15+ 80F1 C3 00 70         jp History.back
  16+ 80F4
  17+ 80F4 44 6F 63 75  .err db "Document fetch error! Check your connection or hostname!", 0
  17+ 80F8 6D 65 6E 74
  17+ 80FC 20 66 65 74
  17+ 8100 63 68 20 65
  17+ 8104 72 72 6F 72
  17+ 8108 21 20 43 68
  17+ 810C 65 63 6B 20
  17+ 8110 79 6F 75 72
  17+ 8114 20 63 6F 6E
  17+ 8118 6E 65 63 74
  17+ 811C 69 6F 6E 20
  17+ 8120 6F 72 20 68
  17+ 8124 6F 73 74 6E
  17+ 8128 61 6D 65 21
  17+ 812C 00
  18+ 812D
  19+ 812D
  20+ 812D              fetchFromFS:
  21+ 812D CD 88 7F         call UrlEncoder.extractPath
  22+ 8130              loadFile
  23+ 8130              	IFDEF MSX
  24+ 8130 ~                ld de, nameBuffer, a, FMODE_NO_WRITE
  25+ 8130 ~                call Dos.fopen
  26+ 8130 ~                ld a, b, (.fp), a
  27+ 8130 ~                ld de, outputBuffer, hl, (ramtop)
  28+ 8130 ~                call Dos.fread
  29+ 8130 ~                ld a, (.fp), b, a
  30+ 8130 ~                call Dos.fclose
  31+ 8130 ~                jp MediaProcessor.processResource
  32+ 8130 ~            .fp db 0
  33+ 8130              	ELSE
  34+ 8130 21 A0 7F         ld hl, nameBuffer
  35+ 8133 CD A4 69         call Dos.loadBuffer
  36+ 8136 C3 39 81         jp MediaProcessor.processResource
  37+ 8139              	ENDIF
  38+ 8139                  ENDMODULE
# file closed: gopher/engine/fetcher.asm
  35  8139                  include "gopher/engine/media-processor.asm"
# file opened: gopher/engine/media-processor.asm
   1+ 8139                  MODULE MediaProcessor
   2+ 8139              processResource:
   3+ 8139 CD 94 7F         call UrlEncoder.extractHostName
   4+ 813C 3A 45 71         ld a, (historyBlock.mediaType)
   5+ 813F FE 0E            cp MIME_MUSIC
   5+ 8141 28 13          jr z, processPT
   6+ 8143 FE 1A            cp MIME_LINK
   6+ 8145 28 15          jr z, processPage
   7+ 8147 FE B3            cp MIME_INPUT
   7+ 8149 28 11          jr z, processPage
   8+ 814B FE 01            cp MIME_IMAGE
   8+ 814D CA D3 94       jp z, ScreenViewer.display
   9+ 8150              	ifdef GS
  10+ 8150 ~                cp MIME_MOD
  10+ 8150 ~              jr z, processMOD
  11+ 8150              	endif
  12+ 8150              ; Fallback to plain text
  13+ 8150              processText:
  14+ 8150 CD 6E 66         call Render.renderPlainTextScreen
  15+ 8153 C3 9E 66         jp   Render.plainTextLoop
  16+ 8156
  17+ 8156              processPT:
  18+ 8156 CD 8D 88         call VortexProcessor.play
  19+ 8159 C3 00 70         jp History.back
  20+ 815C
  21+ 815C                  ifdef GS
  22+ 815C ~            processMOD:
  23+ 815C ~                call ModProcessor.play
  24+ 815C ~                jp History.back
  25+ 815C              	endif
  26+ 815C
  27+ 815C              processPage:
  28+ 815C 3A 35 67         ld a, (Render.play_next)
  28+ 815F A7             and a
  28+ 8160 20 06          jr nz, .playNext
  29+ 8162 CD E5 64         call Render.renderGopherScreen
  30+ 8165 C3 23 65         jp   Render.workLoop
  31+ 8168              .playNext
  32+ 8168 CD E5 64             call Render.renderGopherScreen
  33+ 816B 21 8C 73         ld hl, Render.cursor_position
  34+ 816E 34               inc (hl)
  35+ 816F C3 0D 65         jp Render.checkBorder
  36+ 8172
  37+ 8172                  ENDMODULE
# file closed: gopher/engine/media-processor.asm
  36  8172                  include "gopher/gopher.asm"
# file opened: gopher/gopher.asm
   1+ 8172                  module Gopher
   2+ 8172              ; HL - gopher row
   3+ 8172              extractRequest:
   4+ 8172 21 46 71         ld hl, historyBlock.locator
   5+ 8175 11 C5 82         ld de, requestbuffer
   6+ 8178              .loop
   7+ 8178 7E               ld a, (hl)
   8+ 8179 12               ld (de), a
   9+ 817A 23               inc hl
  10+ 817B 13               inc de
  11+ 817C FE 00            cp 0
  12+ 817E 28 02            jr z, .search
  13+ 8180 18 F6            jr .loop
  14+ 8182              .search
  15+ 8182 1B               dec de
  16+ 8183 3A 45 71         ld a, (historyBlock.mediaType)
  17+ 8186 FE B3            cp MIME_INPUT
  18+ 8188 20 10            jr nz, .exit
  19+ 818A 21 8B 72         ld hl, historyBlock.search
  20+ 818D 3E 09            ld a, TAB
  21+ 818F 12               ld (de), a
  22+ 8190 13               inc de
  23+ 8191              .searchCopy
  24+ 8191 7E               ld a, (hl)
  25+ 8192 A7               and a
  25+ 8193 28 05          jr z, .exit
  26+ 8195 12               ld (de), a
  27+ 8196 23               inc hl
  27+ 8197 13             inc de
  28+ 8198 18 F7            jr .searchCopy
  29+ 819A              .exit
  30+ 819A AF               xor a
  31+ 819B 12               ld (de), a
  32+ 819C C9               ret
  33+ 819D
  34+ 819D
  35+ 819D              makeRequest:
  36+ 819D CD 72 81         call extractRequest
  37+ 81A0
  38+ 81A0 21 45 72         ld hl, historyBlock.host
  39+ 81A3 11 85 72         ld de, historyBlock.port
  40+ 81A6 CD 6B 86         call Wifi.openTCP
  41+ 81A9 D8               ret c
  42+ 81AA
  43+ 81AA 21 C5 82         ld hl, requestbuffer
  44+ 81AD CD 5C 87         call Wifi.tcpSendZ
  45+ 81B0 AF               xor a
  45+ 81B1 32 3D 85       ld (Wifi.closed), a
  46+ 81B4 C9               ret
  47+ 81B5
  48+ 81B5
  49+ 81B5              loadBuffer:
  50+ 81B5 21 F8 94         ld hl, outputBuffer
  51+ 81B8 22 3B 85         ld (Wifi.buffer_pointer), hl
  52+ 81BB              .loop
  53+ 81BB CD AC 87         call Wifi.getPacket
  54+ 81BE 3A 3D 85         ld a, (Wifi.closed)
  54+ 81C1 A7             and a
  54+ 81C2 C0             ret nz
  55+ 81C3 CD C9 86         call Wifi.continue
  56+ 81C6 18 F3            jr .loop
  57+ 81C8
  58+ 81C8                  ifdef GS
  59+ 81C8 ~            loadMod:
  60+ 81C8 ~                xor a
  60+ 81C8 ~              call GeneralSound.init
  61+ 81C8 ~                ld hl, .progress
  61+ 81C8 ~              call DialogBox.msgNoWait
  62+ 81C8 ~                call makeRequest
  62+ 81C8 ~              jp c, Fetcher.fetchFromNet.error
  63+ 81C8 ~                call GeneralSound.loadModule
  64+ 81C8 ~            .loop
  65+ 81C8 ~                ld hl, outputBuffer, (Wifi.buffer_pointer), hl
  66+ 81C8 ~                call Wifi.getPacket
  67+ 81C8 ~                ld a, (Wifi.closed)
  67+ 81C8 ~              and a
  67+ 81C8 ~              jr nz, .exit
  68+ 81C8 ~                ld hl, outputBuffer, bc, (Wifi.bytes_avail)
  69+ 81C8 ~            .loadLoop
  70+ 81C8 ~                ld a, b
  70+ 81C8 ~              or c
  70+ 81C8 ~              and a
  70+ 81C8 ~              jr z, .nextFrame
  71+ 81C8 ~                ld a, (hl)
  71+ 81C8 ~              call GeneralSound.sendByte
  72+ 81C8 ~                dec bc
  73+ 81C8 ~                inc hl
  74+ 81C8 ~                jr .loadLoop
  75+ 81C8 ~            .nextFrame
  76+ 81C8 ~                call pulsing
  77+ 81C8 ~                call Wifi.continue
  78+ 81C8 ~                jr .loop
  79+ 81C8 ~            .exit
  80+ 81C8 ~                call GeneralSound.finishLoadingModule
  81+ 81C8 ~                ;jp History.back
  82+ 81C8 ~            	jp MediaProcessor.processResource
  83+ 81C8 ~            .progress db "MOD downloading directly to GS!", 0
  84+ 81C8                  endif
  85+ 81C8
  86+ 81C8              download:
  87+ 81C8 11 46 71         ld de, historyBlock.locator
  88+ 81CB 62 6B            ld hl, de
  89+ 81CD              .findFileName
  90+ 81CD 1A               ld a, (de)
  90+ 81CE 13             inc de
  91+ 81CF FE 2F            cp '/'
  91+ 81D1 20 02          jr nz, .skip
  92+ 81D3 62 6B            ld hl, de
  93+ 81D5              .skip
  94+ 81D5 A7               and a
  94+ 81D6 20 F5          jr nz, .findFileName
  95+ 81D8              .copy
  96+ 81D8                  ;; HL - filename pointer
  97+ 81D8 11 91 67         ld de, DialogBox.inputBuffer
  98+ 81DB              .copyFileName
  99+ 81DB 7E               ld a, (hl)
  99+ 81DC A7             and a
  99+ 81DD 28 05          jr z, .finishCopy
 100+ 81DF
 101+ 81DF 12               ld (de), a
 101+ 81E0 23 13          inc hl, de
 102+ 81E2 18 F7            jr .copyFileName
 103+ 81E4              .finishCopy
 104+ 81E4 12               ld (de), a
 105+ 81E5 CD 3A 67         call DialogBox.inputBox.noclear
 106+ 81E8 3A 91 67         ld a, (DialogBox.namedownload)
 106+ 81EB A7             and a
 106+ 81EC CA 00 70       jp z, History.back
 107+ 81EF
 108+ 81EF CD 9D 81         call makeRequest
 108+ 81F2 DA EB 80       jp c, Fetcher.fetchFromNet.error
 109+ 81F5
 110+ 81F5 06 0E 21 91      ld b, Dos.FMODE_CREATE, hl, DialogBox.namedownload
 110+ 81F9 67
 111+ 81FA CD C0 69         call Dos.fopen
 112+ 81FD 32 9E 82         ld (.fp), a
 113+ 8200
 114+ 8200 21 79 82         ld hl, .progress
 114+ 8203 CD EA 67       call DialogBox.msgNoWait
 115+ 8206              .loop
 116+ 8206 21 F8 94 22      ld hl, outputBuffer, (Wifi.buffer_pointer), hl
 116+ 820A 3B 85
 117+ 820C CD AC 87         call Wifi.getPacket
 118+ 820F 3A 3D 85         ld a, (Wifi.closed)
 118+ 8212 A7             and a
 118+ 8213 20 15          jr nz, .exit
 119+ 8215
 120+ 8215 3A 9E 82 21      ld a, (.fp), hl, outputBuffer, bc, (Wifi.bytes_avail)
 120+ 8219 F8 94 ED 4B
 120+ 821D 39 85
 121+ 821F CD D0 6A         call Dos.fwrite
 122+ 8222 CD A1 82         call pulsing
 123+ 8225 CD C9 86         call Wifi.continue
 124+ 8228 18 DC            jr .loop
 125+ 822A              .exit
 126+ 822A 3A 9E 82         ld a, (.fp)
 127+ 822D CD 99 6A         call Dos.fclose
 128+ 8230 C3 00 70         jp History.back
 129+ 8233              .error
 130+ 8233 3A 9E 82         ld a, (.fp)
 131+ 8236 CD 99 6A         call Dos.fclose
 132+ 8239 21 42 82         ld hl, .err
 133+ 823C CD E1 67         call DialogBox.msgBox
 134+ 823F C3 00 70         jp History.back
 135+ 8242
 136+ 8242 4F 70 65 72  .err db "Operation failed! Sorry! Check filename or disk space!",0
 136+ 8246 61 74 69 6F
 136+ 824A 6E 20 66 61
 136+ 824E 69 6C 65 64
 136+ 8252 21 20 53 6F
 136+ 8256 72 72 79 21
 136+ 825A 20 43 68 65
 136+ 825E 63 6B 20 66
 136+ 8262 69 6C 65 6E
 136+ 8266 61 6D 65 20
 136+ 826A 6F 72 20 64
 136+ 826E 69 73 6B 20
 136+ 8272 73 70 61 63
 136+ 8276 65 21 00
 137+ 8279 44 6F 77 6E  .progress db "Downloading in progress! Wait a bit!", 0
 137+ 827D 6C 6F 61 64
 137+ 8281 69 6E 67 20
 137+ 8285 69 6E 20 70
 137+ 8289 72 6F 67 72
 137+ 828D 65 73 73 21
 137+ 8291 20 57 61 69
 137+ 8295 74 20 61 20
 137+ 8299 62 69 74 21
 137+ 829D 00
 138+ 829E 00           .fp db 0
 139+ 829F 00           socket db 0
 140+ 82A0 20           pulsator db " "
 141+ 82A1              pulsing
 142+ 82A1 11 01 0B         ld de, #0B01
 142+ 82A4 CD 88 61       call TextMode.gotoXY
 143+ 82A7 3A A0 82         ld a, (pulsator)
 144+ 82AA FE 2A            cp '*'
 145+ 82AC CA BA 82         jp z, printasterix
 146+ 82AF 3E 2A            ld a, '*'
 147+ 82B1 32 A0 82         ld (pulsator),a
 148+ 82B4 3E 20            ld a,' '
 149+ 82B6 CD 8E 60         call TextMode.putC
 150+ 82B9 C9               ret
 151+ 82BA              printasterix
 152+ 82BA 3E 20            ld a, ' '
 153+ 82BC 32 A0 82         ld (pulsator),a
 154+ 82BF 3E 2A            ld a,'*'
 155+ 82C1 CD 8E 60         call TextMode.putC
 156+ 82C4 C9               ret
 157+ 82C5
 158+ 82C5 00 00 00...  requestbuffer ds #1ff
 159+ 84C4                  endmodule
 160+ 84C4
# file closed: gopher/gopher.asm
  37  84C4                  include "drivers/index.asm"
# file opened: drivers/index.asm
   1+ 84C4                  IFDEF UNO
   2+ 84C4 ~                	include "uno-uart.asm"
   3+ 84C4                  ENDIF
   4+ 84C4
   5+ 84C4                  IFDEF UNOUART
   6+ 84C4 ~                	include "uno-uart.asm"
   7+ 84C4                  ENDIF
   8+ 84C4
   9+ 84C4                  IFDEF MB03
  10+ 84C4 ~                	include "mb03-uart.asm"
  11+ 84C4                  ENDIF
  12+ 84C4
  13+ 84C4                  IFDEF AY
  14+ 84C4 ~                	include "ay-uart.asm"
  15+ 84C4                  ENDIF
  16+ 84C4
  17+ 84C4                  IFDEF ZW
  18+ 84C4                  	include "zx-wifi.asm"
# file opened: drivers/zx-wifi.asm
   1++84C4              ; This driver works with 16c550 uart that's support AFE
   2++84C4                  module Uart
   3++84C4              ; Make init shorter and readable:-)
   4++84C4                  macro outp port, value
   5++84C4 ~            	ld b, port
   6++84C4 ~            	ld c, #EF
   7++84C4 ~                ld a, value
   8++84C4 ~                out (c), a
   9++84C4                  endm
  10++84C4
  11++84C4              ; Internal port constants
  12++84C4              RBR_THR = #F8
  13++84C4              IER     = RBR_THR + 1
  14++84C4              IIR_FCR = RBR_THR + 2
  15++84C4              LCR     = RBR_THR + 3
  16++84C4              MCR     = RBR_THR + 4
  17++84C4              LSR     = RBR_THR + 5
  18++84C4              MSR     = RBR_THR + 6
  19++84C4              SR      = RBR_THR + 7
  20++84C4
  21++84C4
  22++84C4              init:
  23++84C4                  IFDEF GZ
  24++84C4                  outp MCR,     #0d  // Assert RTS
  24++84C4 06 FC       >	ld b, MCR
  24++84C6 0E EF       >	ld c, #EF
  24++84C8 3E 0D       >    ld a, #0d
  24++84CA ED 79       >    out (c), a
  25++84CC                  outp IIR_FCR, #87  // Enable fifo 8 level, and clear it
  25++84CC 06 FA       >	ld b, IIR_FCR
  25++84CE 0E EF       >	ld c, #EF
  25++84D0 3E 87       >    ld a, #87
  25++84D2 ED 79       >    out (c), a
  26++84D4                  outp LCR,     #83  // 8n1, DLAB=1
  26++84D4 06 FB       >	ld b, LCR
  26++84D6 0E EF       >	ld c, #EF
  26++84D8 3E 83       >    ld a, #83
  26++84DA ED 79       >    out (c), a
  27++84DC                  outp RBR_THR, 12  //(divider 12)
  27++84DC 06 F8       >	ld b, RBR_THR
  27++84DE 0E EF       >	ld c, #EF
  27++84E0 3E 0C       >    ld a, 12
  27++84E2 ED 79       >    out (c), a
  28++84E4                  outp IER,     #00  // (divider 0). Divider is 16 bit, so we get (#0002 divider)
  28++84E4 06 F9       >	ld b, IER
  28++84E6 0E EF       >	ld c, #EF
  28++84E8 3E 00       >    ld a, #00
  28++84EA ED 79       >    out (c), a
  29++84EC
  30++84EC                  outp LCR,     #03 // 8n1, DLAB=0
  30++84EC 06 FB       >	ld b, LCR
  30++84EE 0E EF       >	ld c, #EF
  30++84F0 3E 03       >    ld a, #03
  30++84F2 ED 79       >    out (c), a
  31++84F4                  outp IER,     #00 // Disable int
  31++84F4 06 F9       >	ld b, IER
  31++84F6 0E EF       >	ld c, #EF
  31++84F8 3E 00       >    ld a, #00
  31++84FA ED 79       >    out (c), a
  32++84FC                  outp MCR,     #2f // Enable AFE
  32++84FC 06 FC       >	ld b, MCR
  32++84FE 0E EF       >	ld c, #EF
  32++8500 3E 2F       >    ld a, #2f
  32++8502 ED 79       >    out (c), a
  33++8504 C9               ret
  34++8505                  ELSE
  35++8505 ~                outp MCR,     #0d  // Assert RTS
  36++8505 ~                outp IIR_FCR, #87  // Enable fifo 8 level, and clear it
  37++8505 ~                outp LCR,     #83  // 8n1, DLAB=1
  38++8505 ~                outp RBR_THR, 1  // 115200 (divider 1)
  39++8505 ~                outp IER,     #00  // (divider 0). Divider is 16 bit, so we get (#0002 divider)
  40++8505 ~
  41++8505 ~                outp LCR,     #03 // 8n1, DLAB=0
  42++8505 ~                outp IER,     #00 // Disable int
  43++8505 ~                outp MCR,     #2f // Enable AFE
  44++8505 ~                ret
  45++8505                  ENDIF
  46++8505              retry_rec_count_max equ 50 ;ждать 1 байт максимум столько прерываний
  47++8505
  48++8505              ; Flag C <- Data available
  49++8505              ; isAvailable:
  50++8505                  ; ld a, LSR
  51++8505                  ; in a, (#EF)
  52++8505                  ; rrca
  53++8505                  ; ret
  54++8505
  55++8505              ; Non-blocking read
  56++8505              ; Flag C <- is byte was readen
  57++8505              ; A <- byte
  58++8505              ; read1:
  59++8505                  ; ld a, LSR
  60++8505                  ; in a, (#EF)
  61++8505                  ; rrca
  62++8505                  ; ret nc
  63++8505                  ; ld a, RBR_THR
  64++8505                  ; in a, (#EF)
  65++8505                  ; scf
  66++8505                  ; ret
  67++8505
  68++8505              ; Tries read byte with timeout
  69++8505              ; Flag C <- is byte read
  70++8505              ; A <- byte
  71++8505              read:
  72++8505 AF           	xor a ;4
  73++8506 32 78 5C     	ld (#5C78),a ;обнулить счётчик ожидания ;13
  74++8509              .wait
  75++8509 3E FD            ld a, LSR
  76++850B DB EF            in a, (#EF)
  77++850D 0F               rrca
  78++850E 30 05        	jr nc, .readW
  79++8510 3E F8            ld a, RBR_THR
  80++8512 DB EF            in a, (#EF)
  81++8514 C9           	ret
  82++8515              .readW
  83++8515 3A 78 5C     	ld a,(#5C78)
  84++8518 FE 32        	cp retry_rec_count_max
  85++851A 38 ED        	jr c, .wait ;ещё попытка
  86++851C AF           	xor a ;выключим флаг переноса если время вышло
  87++851D C9           	ret
  88++851E
  89++851E
  90++851E
  91++851E
  92++851E              ; Blocking read
  93++851E              ; A <- Byte
  94++851E              ; readB:
  95++851E                  ; ld a, LSR
  96++851E                  ; in a, (#EF)
  97++851E                  ; rrca
  98++851E                  ; jr nc, readB
  99++851E              	; ld a, RBR_THR
 100++851E                  ; in a, (#EF)
 101++851E                  ; ret
 102++851E
 103++851E              ; A -> byte to send
 104++851E              write:
 105++851E F5               push af
 106++851F              .wait
 107++851F 3E FD        	ld a, LSR
 108++8521 DB EF            in a, (#EF)
 109++8523 E6 20            and #20
 110++8525 28 F8            jr z, .wait
 111++8527 F1               pop af
 112++8528 06 F8        	ld b, RBR_THR
 113++852A 0E EF        	ld c, #EF
 114++852C ED 79            out (c), a
 115++852E C9               ret
 116++852F
 117++852F                  endmodule
# file closed: drivers/zx-wifi.asm
  19+ 852F                  ENDIF
  20+ 852F
  21+ 852F              	include "utils.asm"
# file opened: drivers/utils.asm
   1++852F              ;;; Macroses!!!!
   2++852F                  MACRO EspSend Text
   3++852F ~                ld hl, .txtB
   4++852F ~                ld e, (.txtE - .txtB)
   5++852F ~                call espSend
   6++852F ~                jr .txtE
   7++852F ~            .txtB
   8++852F ~                db Text
   9++852F ~            .txtE
  10++852F                  ENDM
  11++852F
  12++852F                  MACRO EspCmd Text
  13++852F ~                ld hl, .txtB
  14++852F ~                ld e, (.txtE - .txtB)
  15++852F ~                call espSend
  16++852F ~                jr .txtE
  17++852F ~            .txtB
  18++852F ~                db Text
  19++852F ~                db 13, 10
  20++852F ~            .txtE
  21++852F                  ENDM
  22++852F
  23++852F                  MACRO EspCmdOkErr text
  24++852F ~                EspCmd text
  25++852F ~                call checkOkErr
  26++852F                  ENDM
  27++852F
  28++852F              ; IN DE - string pointer
  29++852F              ; OUT HL - string len
  30++852F              strLen:
  31++852F 21 00 00         ld hl, 0
  32++8532              .loop
  33++8532 1A               ld a, (de)
  33++8533 A7             and a
  33++8534 C8             ret z
  34++8535 13 23            inc de, hl
  35++8537 18 F9            jr .loop
# file closed: drivers/utils.asm
  22+ 8539
  23+ 8539              	IFDEF NEDOOSATM
  24+ 8539 ~            		include "atm-uart.asm"
  25+ 8539              	ENDIF
  26+ 8539
  27+ 8539              	IFDEF NEDOOSEVO
  28+ 8539 ~            		include "evo-uart.asm"
  29+ 8539                     	ENDIF
  30+ 8539
  31+ 8539              	IFDEF NEDONET
  32+ 8539 ~            		include "nedowifi.asm"
  33+ 8539              	ELSE
  34+ 8539              		include "wifi.asm"
# file opened: drivers/wifi.asm
   1++8539                  MODULE Wifi
   2++8539 00 00        bytes_avail dw 0
   3++853B 00 00        buffer_pointer dw 0
   4++853D 01           closed db 1
   5++853E              ; Initialize Wifi chip to work
   6++853E              init:
   7++853E
   8++853E 21 30 86         ld hl, .uartIniting
   8++8541 CD 83 60       call TextMode.printZ
   9++8544 CD C4 84         call Uart.init
  10++8547 21 41 86         ld hl, .chipIniting
  10++854A CD 83 60       call TextMode.printZ
  11++854D
  12++854D                  EspCmdOkErr "ATE0"
  12++854D             >    EspCmd "ATE0"
  12++854D 21 57 85    >    ld hl, .txtB
  12++8550 1E 06       >    ld e, (.txtE - .txtB)
  12++8552 CD 3F 87    >    call espSend
  12++8555 18 06       >    jr .txtE
  12++8557             >.txtB
  12++8557 41 54 45 30 >    db "ATE0"
  12++855B 0D 0A       >    db 13, 10
  12++855D             >.txtE
  12++855D CD CA 86    >    call checkOkErr
  13++8560 DA 10 86         jp c, .initError
  14++8563
  15++8563                  IFDEF AUTH
  16++8563 21 5B 95 06      ld hl, creds, b, Dos.FMODE_READ
  16++8567 01
  16++8568 CD C0 69       call Dos.fopen
  17++856B F5               push af
  18++856C 21 6C 95 01      ld hl,outputBuffer2, bc, 255
  18++8570 FF 00
  18++8572 CD AD 6A       call Dos.fread
  19++8575 F1               pop af
  20++8576 CD 99 6A         call Dos.fclose
  21++8579
  22++8579 21 59 86         ld hl, .doneInit1
  22++857C CD 83 60       call TextMode.printZ
  23++857F                  ;ld hl, outputBuffer2 : call TextMode.printZ
  24++857F
  25++857F 21 6C 95         ld hl,outputBuffer2
  26++8582 CD 49 87         call espSendT
  27++8585 3E 0D            ld a, 13
  27++8587 CD 1E 85       call Uart.write
  28++858A 3E 0A            ld a, 10
  28++858C CD 1E 85       call Uart.write
  29++858F CD CA 86         call checkOkErr
  30++8592 DA 10 86         jp c, .initError
  31++8595                  ENDIF
  32++8595
  33++8595                 	EspCmdOkErr "AT+CIPSERVER=0"
  33++8595             >    EspCmd "AT+CIPSERVER=0"
  33++8595 21 9F 85    >    ld hl, .txtB
  33++8598 1E 10       >    ld e, (.txtE - .txtB)
  33++859A CD 3F 87    >    call espSend
  33++859D 18 10       >    jr .txtE
  33++859F             >.txtB
  33++859F 41 54 2B 43 >    db "AT+CIPSERVER=0"
  33++85A3 49 50 53 45 >
  33++85A7 52 56 45 52 >
  33++85AB 3D 30       >
  33++85AD 0D 0A       >    db 13, 10
  33++85AF             >.txtE
  33++85AF CD CA 86    >    call checkOkErr
  34++85B2                  EspCmdOkErr "AT+CIPCLOSE" ; Close if there some connection was. Don't care about result
  34++85B2             >    EspCmd "AT+CIPCLOSE"
  34++85B2 21 BC 85    >    ld hl, .txtB
  34++85B5 1E 0D       >    ld e, (.txtE - .txtB)
  34++85B7 CD 3F 87    >    call espSend
  34++85BA 18 0D       >    jr .txtE
  34++85BC             >.txtB
  34++85BC 41 54 2B 43 >    db "AT+CIPCLOSE"
  34++85C0 49 50 43 4C >
  34++85C4 4F 53 45    >
  34++85C7 0D 0A       >    db 13, 10
  34++85C9             >.txtE
  34++85C9 CD CA 86    >    call checkOkErr
  35++85CC                  EspCmdOkErr "AT+CIPMUX=0" ; Single connection mode
  35++85CC             >    EspCmd "AT+CIPMUX=0"
  35++85CC 21 D6 85    >    ld hl, .txtB
  35++85CF 1E 0D       >    ld e, (.txtE - .txtB)
  35++85D1 CD 3F 87    >    call espSend
  35++85D4 18 0D       >    jr .txtE
  35++85D6             >.txtB
  35++85D6 41 54 2B 43 >    db "AT+CIPMUX=0"
  35++85DA 49 50 4D 55 >
  35++85DE 58 3D 30    >
  35++85E1 0D 0A       >    db 13, 10
  35++85E3             >.txtE
  35++85E3 CD CA 86    >    call checkOkErr
  36++85E6 DA 10 86         jp c, .initError
  37++85E9
  38++85E9                  EspCmdOkErr "AT+CIPDINFO=0" ; Disable additional info
  38++85E9             >    EspCmd "AT+CIPDINFO=0"
  38++85E9 21 F3 85    >    ld hl, .txtB
  38++85EC 1E 0F       >    ld e, (.txtE - .txtB)
  38++85EE CD 3F 87    >    call espSend
  38++85F1 18 0F       >    jr .txtE
  38++85F3             >.txtB
  38++85F3 41 54 2B 43 >    db "AT+CIPDINFO=0"
  38++85F7 49 50 44 49 >
  38++85FB 4E 46 4F 3D >
  38++85FF 30          >
  38++8600 0D 0A       >    db 13, 10
  38++8602             >.txtE
  38++8602 CD CA 86    >    call checkOkErr
  39++8605 DA 10 86         jp c, .initError
  40++8608
  41++8608 21 52 86         ld hl, .doneInit
  41++860B CD 83 60       call TextMode.printZ
  42++860E
  43++860E B7               or a
  44++860F C9               ret
  45++8610              .initError
  46++8610 21 18 86         ld hl, .errMsg
  46++8613 CD E1 67       call DialogBox.msgBox
  47++8616 37               scf
  48++8617 C9               ret
  49++8618 57 69 46 69  .errMsg      db "WiFi chip init failed!", "\r", 0
  49++861C 20 63 68 69
  49++8620 70 20 69 6E
  49++8624 69 74 20 66
  49++8628 61 69 6C 65
  49++862C 64 21 0D 00
  50++8630 55 61 72 74  .uartIniting db "Uart initing...", "\r", 0
  50++8634 20 69 6E 69
  50++8638 74 69 6E 67
  50++863C 2E 2E 2E 0D
  50++8640 00
  51++8641 43 68 69 70  .chipIniting db "Chip initing...", "\r", 0
  51++8645 20 69 6E 69
  51++8649 74 69 6E 67
  51++864D 2E 2E 2E 0D
  51++8651 00
  52++8652 44 6F 6E 65  .doneInit    db "Done!","\r", 0
  52++8656 21 0D 00
  53++8659 43 6F 6E 6E  .doneInit1   db "Connecting to AP","\r", 0
  53++865D 65 63 74 69
  53++8661 6E 67 20 74
  53++8665 6F 20 41 50
  53++8669 0D 00
  54++866B                  IFNDEF PROXY
  55++866B              ; HL - host pointer in gopher row
  56++866B              ; DE - port pointer in gopher row
  57++866B              openTCP:
  58++866B D5               push de
  59++866C E5               push hl
  60++866D                  EspCmdOkErr "AT+CIPCLOSE" ; Don't care about result. Just close if it didn't happens before
  60++866D             >    EspCmd "AT+CIPCLOSE"
  60++866D 21 77 86    >    ld hl, .txtB
  60++8670 1E 0D       >    ld e, (.txtE - .txtB)
  60++8672 CD 3F 87    >    call espSend
  60++8675 18 0D       >    jr .txtE
  60++8677             >.txtB
  60++8677 41 54 2B 43 >    db "AT+CIPCLOSE"
  60++867B 49 50 43 4C >
  60++867F 4F 53 45    >
  60++8682 0D 0A       >    db 13, 10
  60++8684             >.txtE
  60++8684 CD CA 86    >    call checkOkErr
  61++8687                  EspSend 'AT+CIPSTART="TCP","'
  61++8687 21 91 86    >    ld hl, .txtB
  61++868A 1E 13       >    ld e, (.txtE - .txtB)
  61++868C CD 3F 87    >    call espSend
  61++868F 18 13       >    jr .txtE
  61++8691             >.txtB
  61++8691 41 54 2B 43 >    db 'AT+CIPSTART="TCP","'
  61++8695 49 50 53 54 >
  61++8699 41 52 54 3D >
  61++869D 22 54 43 50 >
  61++86A1 22 2C 22    >
  61++86A4             >.txtE
  62++86A4 E1               pop hl
  63++86A5 CD 49 87         call espSendT
  64++86A8                  EspSend '",'
  64++86A8 21 B2 86    >    ld hl, .txtB
  64++86AB 1E 02       >    ld e, (.txtE - .txtB)
  64++86AD CD 3F 87    >    call espSend
  64++86B0 18 02       >    jr .txtE
  64++86B2             >.txtB
  64++86B2 22 2C       >    db '",'
  64++86B4             >.txtE
  65++86B4 E1               pop hl
  66++86B5 CD 49 87         call espSendT
  67++86B8 3E 0D            ld a, 13
  67++86BA CD 1E 85       call Uart.write
  68++86BD 3E 0A            ld a, 10
  68++86BF CD 1E 85       call Uart.write
  69++86C2 AF               xor a
  69++86C3 32 3D 85       ld (closed), a
  70++86C6 C3 CA 86         jp checkOkErr
  71++86C9
  72++86C9              continue:
  73++86C9 C9               ret
  74++86CA                  ENDIF
  75++86CA
  76++86CA
  77++86CA
  78++86CA              checkOkErr:
  79++86CA CD 05 85         call Uart.read
  80++86CD FE 4F            cp 'O'
  80++86CF CA DF 86       jp z, .okStart ; OK
  81++86D2 FE 45            cp 'E'
  81++86D4 CA F4 86       jp z, .errStart ; ERROR
  82++86D7 FE 46            cp 'F'
  82++86D9 CA 19 87       jp z, .failStart ; FAIL
  83++86DC C3 CA 86         jp checkOkErr
  84++86DF              .okStart
  85++86DF CD 05 85         call Uart.read
  85++86E2 FE 4B          cp 'K'
  85++86E4 C2 CA 86       jp nz, checkOkErr
  86++86E7 CD 05 85         call Uart.read
  86++86EA FE 0D          cp 13
  86++86EC C2 CA 86       jp nz, checkOkErr
  87++86EF CD 36 87         call .flushToLF
  88++86F2 B7               or a
  89++86F3 C9               ret
  90++86F4              .errStart
  91++86F4 CD 05 85         call Uart.read
  91++86F7 FE 52          cp 'R'
  91++86F9 C2 CA 86       jp nz, checkOkErr
  92++86FC CD 05 85         call Uart.read
  92++86FF FE 52          cp 'R'
  92++8701 C2 CA 86       jp nz, checkOkErr
  93++8704 CD 05 85         call Uart.read
  93++8707 FE 4F          cp 'O'
  93++8709 C2 CA 86       jp nz, checkOkErr
  94++870C CD 05 85         call Uart.read
  94++870F FE 52          cp 'R'
  94++8711 C2 CA 86       jp nz, checkOkErr
  95++8714 CD 36 87         call .flushToLF
  96++8717 37               scf
  97++8718 C9               ret
  98++8719              .failStart
  99++8719 CD 05 85         call Uart.read
  99++871C FE 41          cp 'A'
  99++871E C2 CA 86       jp nz, checkOkErr
 100++8721 CD 05 85         call Uart.read
 100++8724 FE 49          cp 'I'
 100++8726 C2 CA 86       jp nz, checkOkErr
 101++8729 CD 05 85         call Uart.read
 101++872C FE 4C          cp 'L'
 101++872E C2 CA 86       jp nz, checkOkErr
 102++8731 CD 36 87         call .flushToLF
 103++8734 37               scf
 104++8735 C9               ret
 105++8736              .flushToLF
 106++8736 CD 05 85         call Uart.read
 107++8739 FE 0A            cp 10
 107++873B C2 36 87       jp nz, .flushToLF
 108++873E C9               ret
 109++873F
 110++873F              ; Send buffer to UART
 111++873F              ; HL - buff
 112++873F              ; E - count
 113++873F              espSend:
 114++873F 7E               ld a, (hl)
 114++8740 CD 1E 85       call Uart.write
 115++8743 23               inc hl
 116++8744 1D               dec e
 117++8745 C2 3F 87         jp nz, espSend
 118++8748 C9               ret
 119++8749
 120++8749              ; HL - string that ends with one of the terminator(CR/LF/TAB/NULL)
 121++8749              espSendT:
 122++8749 7E               ld a, (hl)
 123++874A
 124++874A A7               and a
 124++874B C8             ret z
 125++874C FE 09            cp 9
 125++874E C8             ret z
 126++874F FE 0D            cp 13
 126++8751 C8             ret z
 127++8752 FE 0A            cp 10
 127++8754 C8             ret z
 128++8755
 129++8755 CD 1E 85         call Uart.write
 130++8758 23               inc hl
 131++8759 C3 49 87         jp espSendT
 132++875C
 133++875C              ; HL - stringZ to send
 134++875C              ; Adds CR LF
 135++875C              tcpSendZ:
 136++875C E5               push hl
 137++875D                  EspSend "AT+CIPSEND="
 137++875D 21 67 87    >    ld hl, .txtB
 137++8760 1E 0B       >    ld e, (.txtE - .txtB)
 137++8762 CD 3F 87    >    call espSend
 137++8765 18 0B       >    jr .txtE
 137++8767             >.txtB
 137++8767 41 54 2B 43 >    db "AT+CIPSEND="
 137++876B 49 50 53 45 >
 137++876F 4E 44 3D    >
 137++8772             >.txtE
 138++8772 D1               pop de
 138++8773 D5             push de
 139++8774 CD 2F 85         call strLen
 140++8777 23               inc hl
 140++8778 23             inc hl ; +CRLF
 141++8779 CD 47 88         call hlToNumEsp
 142++877C 3E 0D            ld a, 13
 142++877E CD 1E 85       call Uart.write
 143++8781 3E 0A            ld a, 10
 143++8783 CD 1E 85       call Uart.write
 144++8786 CD CA 86         call checkOkErr
 144++8789 D8             ret c
 145++878A              .wait
 146++878A CD 05 85         call Uart.read
 146++878D FE 3E          cp '>'
 146++878F C2 8A 87       jp nz, .wait
 147++8792 E1               pop hl
 148++8793              .loop
 149++8793 7E               ld a, (hl)
 149++8794 A7             and a
 149++8795 CA 9F 87       jp z, .exit
 150++8798 CD 1E 85         call Uart.write
 151++879B 23               inc hl
 152++879C C3 93 87         jp .loop
 153++879F              .exit
 154++879F 3E 0D            ld a, 13
 154++87A1 CD 1E 85       call Uart.write
 155++87A4 3E 0A            ld a, 10
 155++87A6 CD 1E 85       call Uart.write
 156++87A9 C3 CA 86         jp checkOkErr
 157++87AC
 158++87AC              getPacket:
 159++87AC CD 05 85         call Uart.read
 160++87AF FE 2B            cp '+'
 160++87B1 CA E2 87       jp z, .ipdBegun    ; "+IPD," packet
 161++87B4 FE 4F            cp 'O'
 161++87B6 CA BC 87       jp z, .closedBegun ; It enough to check "OSED\n" :-)
 162++87B9 C3 AC 87         jp getPacket
 163++87BC              .closedBegun
 164++87BC CD 05 85         call Uart.read
 164++87BF FE 53          cp 'S'
 164++87C1 C2 AC 87       jp nz, getPacket
 165++87C4 CD 05 85         call Uart.read
 165++87C7 FE 45          cp 'E'
 165++87C9 C2 AC 87       jp nz, getPacket
 166++87CC CD 05 85         call Uart.read
 166++87CF FE 44          cp 'D'
 166++87D1 C2 AC 87       jp nz, getPacket
 167++87D4 CD 05 85         call Uart.read
 167++87D7 FE 0D          cp 13
 167++87D9 C2 AC 87       jp nz, getPacket
 168++87DC 3E 01 32 3D      ld a, 1, (closed), a
 168++87E0 85
 169++87E1 C9               ret
 170++87E2              .ipdBegun
 171++87E2 CD 05 85         call Uart.read
 171++87E5 FE 49          cp 'I'
 171++87E7 C2 AC 87       jp nz, getPacket
 172++87EA CD 05 85         call Uart.read
 172++87ED FE 50          cp 'P'
 172++87EF C2 AC 87       jp nz, getPacket
 173++87F2 CD 05 85         call Uart.read
 173++87F5 FE 44          cp 'D'
 173++87F7 C2 AC 87       jp nz, getPacket
 174++87FA CD 05 85         call Uart.read ; Comma
 175++87FD CD 2D 88         call .count_ipd_lenght
 175++8800 22 39 85       ld (bytes_avail), hl
 176++8803 44 4D            ld bc, hl
 177++8805 2A 3B 85         ld hl, (buffer_pointer)
 178++8808              .readp
 179++8808 7C               ld a, h
 179++8809 FE FE          cp #fe
 179++880B D2 21 88       jp nc, .skipbuff
 180++880E C5 E5            push bc, hl
 181++8810 CD 05 85         call Uart.read
 182++8813 E1 C1            pop hl, bc
 183++8815 77               ld (hl), a
 184++8816 0B               dec bc
 184++8817 23             inc hl
 185++8818 78               ld a, b
 185++8819 B1             or c
 185++881A C2 08 88       jp nz, .readp
 186++881D 22 3B 85         ld (buffer_pointer), hl
 187++8820 C9               ret
 188++8821              .skipbuff
 189++8821 C5               push bc
 190++8822 CD 05 85         call Uart.read
 191++8825 C1               pop bc
 192++8826 0B               dec bc
 192++8827 78             ld a, b
 192++8828 B1             or c
 192++8829 C2 21 88       jp nz, .skipbuff
 193++882C C9               ret
 194++882D              .count_ipd_lenght
 195++882D 21 00 00     		ld hl,0			; count lenght
 196++8830 E5           .cil1	push  hl
 197++8831 CD 05 85             call Uart.read
 198++8834 E1                   pop hl
 199++8835 FE 3A        		cp ':'
 199++8837 C8             ret z
 200++8838 D6 30        		sub 0x30
 200++883A 4D             ld c,l
 200++883B 44             ld b,h
 200++883C 29             add hl,hl
 200++883D 29             add hl,hl
 200++883E 09             add hl,bc
 200++883F 29             add hl,hl
 200++8840 4F             ld c,a
 200++8841 06 00          ld b,0
 200++8843 09             add hl,bc
 201++8844 C3 30 88     		jp .cil1
 202++8847
 203++8847              ; Based on: https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispHL
 204++8847              ; HL - number
 205++8847              ; It will be written to UART
 206++8847              hlToNumEsp:
 207++8847 01 F0 D8     	ld	bc,-10000
 208++884A CD 60 88     	call	.n1
 209++884D 01 18 FC     	ld	bc,-1000
 210++8850 CD 60 88     	call	.n1
 211++8853 01 9C FF     	ld	bc,-100
 212++8856 CD 60 88     	call	.n1
 213++8859 0E F6        	ld	c,-10
 214++885B CD 60 88     	call	.n1
 215++885E 0E FF        	ld	c,-1
 216++8860 3E 2F        .n1	ld	a,'0'-1
 217++8862 3C           .n2	inc	a
 218++8863 09           	add	hl,bc
 219++8864 DA 62 88     	jp	c, .n2
 220++8867 ED 42        	sbc	hl,bc
 221++8869 C5               push bc
 222++886A CD 1E 85     	call Uart.write
 223++886D C1               pop bc
 224++886E C9               ret
 225++886F              flushToLF1
 226++886F CD 05 85         call Uart.read
 227++8872 FE 0A            cp 10
 227++8874 C2 6F 88       jp nz, flushToLF1
 228++8877 C9               ret
 229++8878                  ENDMODULE
# file closed: drivers/wifi.asm
  35+ 8878              	ENDIF
  36+ 8878
  37+ 8878              ;	IFDEF NEDOOS
  38+ 8878              ;       	include "nedoos.asm"
  39+ 8878              ;	ENDIF
  40+ 8878
  41+ 8878              	include "proxy.asm"
# file opened: drivers/proxy.asm
   1++8878                  IFDEF PROXY
   2++8878 ~                MODULE Wifi
   3++8878 ~            ; Same singature as wifi.openTCP
   4++8878 ~            ; HL - host pointer in gopher row
   5++8878 ~            ; DE - port pointer in gopher row
   6++8878 ~            openTCP:
   7++8878 ~                push de
   8++8878 ~                push hl
   9++8878 ~
  10++8878 ~                xor a
  10++8878 ~              ld hl, hostBuff, de, hostBuff + 1, bc, 102, (hl), a
  10++8878 ~              ldir
  11++8878 ~
  12++8878 ~                EspCmdOkErr "AT+CIPCLOSE"
  13++8878 ~                EspCmdOkErr 'AT+CIPSTART="TCP","138.68.76.243",6912' // Replace here for yourown proxy. If you wish
  14++8878 ~                jr c, .error
  15++8878 ~                pop hl
  15++8878 ~              ld de, hostBuff
  16++8878 ~            .copyHost
  17++8878 ~                ld a, (hl)
  17++8878 ~              and a
  17++8878 ~              jr z, 1F
  17++8878 ~              and a
  17++8878 ~              jr z, 1F
  18++8878 ~                ld (de), a
  18++8878 ~              inc hl, de
  19++8878 ~                jr .copyHost
  20++8878 ~            1   xor a
  20++8878 ~              ld (de), a
  21++8878 ~                pop hl
  21++8878 ~              ld de, portBuff
  22++8878 ~            .copyPort
  23++8878 ~                ld a, (hl)
  23++8878 ~              and a
  23++8878 ~              jr z, 1F
  23++8878 ~              and a
  23++8878 ~              jr z, 1F
  24++8878 ~                ld (de), a
  24++8878 ~              inc hl, de
  25++8878 ~                jr .copyPort
  26++8878 ~            1   ld hl, hostBuff
  26++8878 ~              call tcpSendZ
  27++8878 ~                ld hl, portBuff
  27++8878 ~              call tcpSendZ
  28++8878 ~                xor a
  28++8878 ~              ld (closed), a
  29++8878 ~                ret
  30++8878 ~            .error
  31++8878 ~                pop hl
  31++8878 ~              pop de
  32++8878 ~                ret
  33++8878 ~
  34++8878 ~            continue:
  35++8878 ~                EspCmdOkErr "AT+CIPSEND=1"
  36++8878 ~                ret c
  37++8878 ~            .wait
  38++8878 ~                call Uart.read
  38++8878 ~              cp '>'
  38++8878 ~              jr nz, .wait
  39++8878 ~                ld a, 'c'
  39++8878 ~              call Uart.write
  40++8878 ~                jp checkOkErr
  41++8878 ~
  42++8878 ~            hostBuff ds 96
  43++8878 ~            portBuff ds 7
  44++8878 ~                ENDMODULE
  45++8878                  ENDIF
# file closed: drivers/proxy.asm
  42+ 8878              	include "memory.asm"
# file opened: drivers/memory.asm
   1++8878                  module Memory
   2++8878              BANKM = #5b5c
   3++8878              MEM_PORT = #7ffd
   4++8878
   5++8878              init:
   6++8878 F3               di
   7++8879 FD CB 01 A6      res 4, (iy + 1)
   8++887D
   9++887D AF               xor a
   9++887E CD 82 88       call setPage
  10++8881 C9               ret
  11++8882
  12++8882              ; a - page
  13++8882              setPage:
  14++8882 F6 18            or #18
  14++8884 32 5C 5B       ld (BANKM), a
  15++8887 01 FD 7F         ld bc, MEM_PORT
  15++888A ED 79          out (c), a
  16++888C C9               ret
  17++888D
  18++888D                  endmodule
# file closed: drivers/memory.asm
  43+ 888D              	include "general-sound.asm"
# file opened: drivers/general-sound.asm
   1++888D                  ifdef GS
   2++888D ~                macro GS_WaitCommand
   3++888D ~            .wait
   4++888D ~                in a, (GeneralSound.CMD)
   5++888D ~                rrca
   6++888D ~                jr c, .wait
   7++888D ~                endm
   8++888D ~
   9++888D ~                macro GS_WaitData
  10++888D ~            .wait
  11++888D ~                in a, (GeneralSound.CMD)
  12++888D ~                rlca
  13++888D ~                jr c, .wait
  14++888D ~                endm
  15++888D ~
  16++888D ~                macro GS_SendCommand nn
  17++888D ~                ld a, nn
  17++888D ~              out (GeneralSound.CMD), a
  18++888D ~                endm
  19++888D ~
  20++888D ~                module GeneralSound
  21++888D ~            ;; Control ports
  22++888D ~            CMD  = 187
  23++888D ~            DATA = 179
  24++888D ~
  25++888D ~            ;; Commands
  26++888D ~            CMD_WARM_RESET      = #F3
  27++888D ~            CMD_COLD_RESET      = #F4
  28++888D ~            CMD_LOAD_MODULE     = #30
  29++888D ~            CMD_PLAY_MODULE     = #31
  30++888D ~            CMD_STOP_MODULE     = #32
  31++888D ~            CMD_CONTINUE_MODULE = #33
  32++888D ~            CMD_OPEN_STREAM     = #D1
  33++888D ~            CMD_CLOSE_STREAM    = #D2
  34++888D ~
  35++888D ~            ; A - 0 warm reset, other - cold
  36++888D ~            init:
  37++888D ~                and a
  37++888D ~              jr nz, .cold
  38++888D ~                GS_SendCommand CMD_WARM_RESET
  39++888D ~                ret
  40++888D ~            .cold
  41++888D ~                GS_SendCommand CMD_COLD_RESET
  42++888D ~                ret
  43++888D ~
  44++888D ~            ;; Initializes loading module
  45++888D ~            loadModule:
  46++888D ~                GS_SendCommand CMD_LOAD_MODULE
  47++888D ~                GS_WaitCommand
  48++888D ~                GS_SendCommand CMD_OPEN_STREAM
  49++888D ~                GS_WaitCommand
  50++888D ~                ret
  51++888D ~
  52++888D ~            ;; Use it for streaming mod file
  53++888D ~            sendByte:
  54++888D ~                out (DATA), a
  55++888D ~                GS_WaitData
  56++888D ~                ret
  57++888D ~
  58++888D ~            ;; Call it when module was loaded
  59++888D ~            finishLoadingModule:
  60++888D ~                GS_SendCommand CMD_CLOSE_STREAM
  61++888D ~                GS_WaitCommand
  62++888D ~            rewind:
  63++888D ~                ld a, 1
  63++888D ~              out (DATA), a
  64++888D ~                GS_SendCommand CMD_PLAY_MODULE
  65++888D ~                GS_WaitCommand
  66++888D ~                ld a, 1, (state),a
  67++888D ~                ret
  68++888D ~
  69++888D ~            ;; Works like pause too
  70++888D ~            stopModule:
  71++888D ~                xor a
  71++888D ~              ld (state), a
  72++888D ~                GS_SendCommand CMD_STOP_MODULE
  73++888D ~                ret
  74++888D ~
  75++888D ~            continueModule:
  76++888D ~                ld a, 1
  76++888D ~              ld (state), a
  77++888D ~                GS_SendCommand CMD_CONTINUE_MODULE
  78++888D ~                ret
  79++888D ~
  80++888D ~            ; Pauses resumes
  81++888D ~            toggleModule:
  82++888D ~                call Console.waitForKeyUp
  83++888D ~                ld a, (state)
  83++888D ~              and a
  84++888D ~                jr z, continueModule
  85++888D ~                jr stopModule
  86++888D ~
  87++888D ~            toggleDownload:
  88++888D ~                ld a,(GSdownType)
  89++888D ~                xor 1
  90++888D ~                ld (GSdownType),a
  91++888D ~                ret
  92++888D ~
  93++888D ~            GSdownType  db 0
  94++888D ~            state db 0
  95++888D ~                endmodule
  96++888D ~
  97++888D                  endif
# file closed: drivers/general-sound.asm
  44+ 888D
# file closed: drivers/index.asm
  38  888D                  IFNDEF NEDOOS
  39  888D                  include "player/vortex-processor.asm"
# file opened: player/vortex-processor.asm
   1+ 888D                  MODULE VortexProcessor
   2+ 888D              	IFDEF MSX
   3+ 888D ~            play:
   4+ 888D ~                call Console.peekC
   4+ 888D ~              and a
   5+ 888D ~                jr nz, play
   6+ 888D ~
   7+ 888D ~                ld hl, message
   7+ 888D ~              call DialogBox.msgNoWait
   8+ 888D ~
   9+ 888D ~                ld hl, outputBuffer
   9+ 888D ~              call VTPL.INIT
  10+ 888D ~            .loop
  11+ 888D ~                halt
  11+ 888D ~              di
  11+ 888D ~              call VTPL.PLAY
  11+ 888D ~              ei
  12+ 888D ~                call Console.peekC
  12+ 888D ~              and a
  12+ 888D ~              jp nz, .stop
  13+ 888D ~                jr nc, .loop
  14+ 888D ~            .stop
  15+ 888D ~                call VTPL.MUTE
  16+ 888D ~            .wlp
  17+ 888D ~                call Console.peekC
  17+ 888D ~              and a
  18+ 888D ~                jr nz, .wlp
  19+ 888D ~                ret
  20+ 888D ~
  21+ 888D ~            message db "Press key to stop...", 0
  22+ 888D ~                ENDMODULE
  23+ 888D ~                include "msxplayer.asm"
  24+ 888D              	ELSE
  25+ 888D              play:
  26+ 888D CD 19 68         call Console.waitForKeyUp
  27+ 8890
  28+ 8890 21 C8 88         ld hl, message
  28+ 8893 CD EA 67       call DialogBox.msgNoWait
  29+ 8896
  30+ 8896 21 F8 94         ld hl, outputBuffer
  30+ 8899 CD 1E 89       call VTPL.INIT
  31+ 889C
  32+ 889C
  33+ 889C 3E 01 32 35      ld a, 1, (Render.play_next), a
  33+ 88A0 67
  34+ 88A1
  35+ 88A1                  IFDEF GS
  36+ 88A1 ~                call GeneralSound.stopModule
  37+ 88A1                  ENDIF
  38+ 88A1              .loop
  39+ 88A1 76               halt
  39+ 88A2 F3             di
  39+ 88A3 CD 41 91       call VTPL.PLAY
  39+ 88A6 FB             ei
  40+ 88A7 AF               xor a
  40+ 88A8 DB FE          in a, (#fe)
  40+ 88AA 2F             cpl
  40+ 88AB E6 1F          and 31
  40+ 88AD C2 C2 88       jp nz, .stopKey
  41+ 88B0 3A E7 88         ld a, (VTPL.SETUP)
  41+ 88B3 17             rla
  41+ 88B4 30 EB          jr nc, .loop
  42+ 88B6 3E 01 32 35      ld a, 1, (Render.play_next), a
  42+ 88BA 67
  43+ 88BB              .stop
  44+ 88BB CD 0C 89         call VTPL.MUTE
  45+ 88BE
  46+ 88BE                  IFDEF AY
  47+ 88BE ~                call restoreAyState
  48+ 88BE                  ENDIF
  49+ 88BE
  50+ 88BE CD 19 68         call Console.waitForKeyUp
  51+ 88C1 C9               ret
  52+ 88C2              .stopKey
  53+ 88C2 AF               xor a
  53+ 88C3 32 35 67       ld (Render.play_next), a
  54+ 88C6 18 F3            jr .stop
  55+ 88C8
  56+ 88C8                  IFDEF AY
  57+ 88C8 ~            restoreAyState:
  58+ 88C8 ~                ld a, #07
  59+ 88C8 ~                ld bc, #fffd
  60+ 88C8 ~                out (c), a
  61+ 88C8 ~                ld a, #fc
  62+ 88C8 ~                ld b, #bf
  63+ 88C8 ~                out (c), a ; Enable read mode
  64+ 88C8 ~
  65+ 88C8 ~                ld a, #0e
  66+ 88C8 ~                ld bc, #fffd
  67+ 88C8 ~                out (c), a
  68+ 88C8 ~                ret
  69+ 88C8              	ENDIF
  70+ 88C8 50 72 65 73  message db "Press key to stop...", 0
  70+ 88CC 73 20 6B 65
  70+ 88D0 79 20 74 6F
  70+ 88D4 20 73 74 6F
  70+ 88D8 70 2E 2E 2E
  70+ 88DC 00
  71+ 88DD                  ENDMODULE
  72+ 88DD                  include "player.asm"
# file opened: player/player.asm
   1++88DD              ;Universal PT2'n'PT3 Turbo Sound player for ZX Spectrum
   2++88DD              ;(c)2004-2007 S.V.Bulba <vorobey@mail.khstu.ru>
   3++88DD              ;Specially for AlCo
   4++88DD              ;http://bulba.untergrund.net/ (http://bulba.at.kz/)
   5++88DD              	MODULE VTPL
   6++88DD              ;Release number
   7++88DD              Release EQU "0"
   8++88DD              ;Conditional assembly
   9++88DD              ;1) Current position counters at (Vars1+0) and (Vars2+0)
  10++88DD              CurPosCounter=0
  11++88DD              ;2) Allow channels allocation bits at (START+10)
  12++88DD              ACBBAC=0
  13++88DD              ;3) Allow loop checking and disabling
  14++88DD              LoopChecker=1
  15++88DD              ;4) Insert official identificator
  16++88DD              Id=0
  17++88DD              ;5) Set IY for correct return to ZX Basic
  18++88DD              Basic=1
  19++88DD
  20++88DD              ;Features
  21++88DD              ;--------
  22++88DD              ;-Can be compiled at any address (i.e. no need rounding ORG
  23++88DD              ; address).
  24++88DD              ;-Variables (VARS) can be located at any address (not only after
  25++88DD              ; code block).
  26++88DD              ;-INIT subprogram checks PT3-module version and rightly
  27++88DD              ; generates both note and volume tables outside of code block
  28++88DD              ; (in VARS).
  29++88DD              ;-Two portamento (spc. command 3xxx) algorithms (depending of
  30++88DD              ; PT3 module version).
  31++88DD              ;-New 1.XX and 2.XX special command behaviour (only for PT v3.7
  32++88DD              ; and higher).
  33++88DD              ;-Any Tempo value are accepted (including Tempo=1 and Tempo=2).
  34++88DD              ;-TS modes: 2xPT3, 2xPT2 and PT v3.7 TS standard.
  35++88DD              ;-Fully compatible with Ay_Emul PT3 and PT2 players codes.
  36++88DD              ;-See also notes at the end of this source code.
  37++88DD
  38++88DD              ;Limitations
  39++88DD              ;-----------
  40++88DD              ;-Can run in RAM only (self-modified code is used).
  41++88DD              ;-PT2 position list must be end by #FF marker only.
  42++88DD
  43++88DD              ;Warning!!! PLAY subprogram can crash if no module are loaded
  44++88DD              ;into RAM or INIT subprogram was not called before.
  45++88DD
  46++88DD              ;Call MUTE or INIT one more time to mute sound after stopping
  47++88DD              ;playing
  48++88DD
  49++88DD              ;Test codes (commented)
  50++88DD              ;	LD A,32 ;SinglePT3(TS if TSPT3.7),ABC,Looped
  51++88DD              ;	LD (START+10),A
  52++88DD              ;	LD HL,#8000 ;Mod1
  53++88DD              ;	LD DE,#A000 ;Mod2 (optional)
  54++88DD              ;	CALL START+3
  55++88DD              ;	EI
  56++88DD              ;_LP	HALT
  57++88DD              ;	CALL START+5
  58++88DD              ;	XOR A
  59++88DD              ;	IN A,(#FE)
  60++88DD              ;	CPL
  61++88DD              ;	AND 15
  62++88DD              ;	JR Z,_LP
  63++88DD              ;	JR START+8
  64++88DD
  65++88DD              TonA	EQU 0
  66++88DD              TonB	EQU 2
  67++88DD              TonC	EQU 4
  68++88DD              Noise	EQU 6
  69++88DD              Mixer	EQU 7
  70++88DD              AmplA	EQU 8
  71++88DD              AmplB	EQU 9
  72++88DD              AmplC	EQU 10
  73++88DD              Env	EQU 11
  74++88DD              EnvTp	EQU 13
  75++88DD
  76++88DD              ;Entry and other points
  77++88DD              ;START initialize playing of modules at MDLADDR (single module)
  78++88DD              ;START+3 initialization with module address in HL and DE (TS)
  79++88DD              ;START+5 play one quark
  80++88DD              ;START+8 mute
  81++88DD              ;START+10 setup and status flags
  82++88DD
  83++88DD              START:
  84++88DD 21 F8 94     	LD HL,outputBuffer ;DE - address of 2nd module for TS
  85++88E0 18 3C        	JR INIT
  86++88E2 C3 41 91     	JP PLAY
  87++88E5 18 25        	JR MUTE
  88++88E7 00           SETUP	DB 0 ;set bit0, if you want to play without looping
  89++88E8              	     ;(optional);
  90++88E8              	     ;set bit1 for PT2 and reset for PT3 before
  91++88E8              	     ;calling INIT;
  92++88E8              	     ;bits2-3: %00-ABC, %01-ACB, %10-BAC (optional);
  93++88E8              	     ;bits4-5: %00-no TS, %01-2 modules TS, %10-
  94++88E8              	     ;autodetect PT3 TS-format by AlCo (PT 3.7+);
  95++88E8              	     ;Remark: old PT3 TS-format by AlCo (PT 3.6) is not
  96++88E8              	     ;documented and must be converted to new standard.
  97++88E8              	     ;bit6 is set each time, when loop point of 2nd TS
  98++88E8              	     ;module is passed (optional).
  99++88E8              	     ;bit7 is set each time, when loop point of 1st TS
 100++88E8              	     ;or of single module is passed (optional).
 101++88E8
 102++88E8              ;Identifier
 103++88E8              	IF Id
 104++88E8 ~            	DB "=UniPT2/PT3/TS-Player r.",Release,"="
 105++88E8              	ENDIF
 106++88E8
 107++88E8              	IF LoopChecker
 108++88E8 21 E7 88     CHECKLP	LD HL,SETUP
 109++88EB FD CB 9E 46  	BIT 0,(IY-100+VRS.ModNum)
 110++88EF 28 04        	JR Z,CHL1
 111++88F1 CB F6        	SET 6,(HL)
 112++88F3 18 02        	JR CHL2
 113++88F5 CB FE        CHL1	SET 7,(HL)
 114++88F7 CB 46        CHL2	BIT 0,(HL)
 115++88F9 C8           	RET Z
 116++88FA E1           	POP HL
 117++88FB FD 34 09     	INC (IY-100+VRS.DelyCnt)
 118++88FE FD 34 BA     	INC (IY-100+VRS.ChanA+CHP.NtSkCn)
 119++8901 AF           	XOR A
 120++8902 FD 77 1D     	LD (IY-100+VRS.AYREGS+AmplA),A
 121++8905 FD 77 1E     	LD (IY-100+VRS.AYREGS+AmplB),A
 122++8908 FD 77 1F     	LD (IY-100+VRS.AYREGS+AmplC),A
 123++890B C9           	RET
 124++890C              	ENDIF
 125++890C
 126++890C AF           MUTE: XOR A
 127++890D 67           	LD H,A
 128++890E 6F           	LD L,A
 129++890F 32 96 92     	LD (VARS1+VRS.AYREGS+AmplA),A
 130++8912 22 97 92     	LD (VARS1+VRS.AYREGS+AmplB),HL
 131++8915 32 1D 93     	LD (VARS2+VRS.AYREGS+AmplA),A
 132++8918 22 1E 93     	LD (VARS2+VRS.AYREGS+AmplB),HL
 133++891B C3 59 91     	JP ROUT
 134++891E
 135++891E              INIT:
 136++891E              ;HL - AddressOfModule
 137++891E              ;DE - AddresOf2ndModule
 138++891E D5           	PUSH DE
 139++891F E5           	PUSH HL
 140++8920 21 14 92     	LD HL,VARS
 141++8923 36 00        	LD (HL),0
 142++8925 11 15 92     	LD DE,VARS+1
 143++8928 01 0E 01     	LD BC,VAR0END-VARS-1
 144++892B ED B0        	LDIR
 145++892D 23           	INC HL
 146++892E 22 77 92     	LD (VARS1+VRS.AdInPtA),HL ;ptr to zero
 147++8931 22 FE 92     	LD (VARS2+VRS.AdInPtA),HL
 148++8934
 149++8934 E1           	POP HL
 150++8935 FD 21 79 92  	LD IY,VARS1+100
 151++8939 3A E7 88     	LD A,(START+10)
 152++893C E6 02        	AND 2
 153++893E C2 C7 89     	JP NZ,I_PT2
 154++8941
 155++8941 CD 14 8B     	CALL INITPT3
 156++8944 21 18 1F     	LD HL,(e_-SamCnv-2)*256+#18
 157++8947 22 E7 8E     	LD (SamCnv),HL
 158++894A 3E BA        	LD A,#BA
 159++894C 32 B2 8E     	LD (OrnCP),A
 160++894F 32 DE 8E     	LD (SamCP),A
 161++8952 3E 7B        	LD A,#7B
 162++8954 32 B5 8E     	LD (OrnLD),A
 163++8957 32 E1 8E     	LD (SamLD),A
 164++895A 3E 87        	LD A,#87
 165++895C 32 D8 8E     	LD (SamClc2),A
 166++895F E1           	POP HL
 167++8960              	;Use version and ton table of 1st module
 168++8960 DD 7E A9     	LD A,(IX+13-100) ;EXTRACT VERSION NUMBER
 169++8963 D6 30        	SUB #30
 170++8965 38 04        	JR C,L20
 171++8967 FE 0A        	CP 10
 172++8969 38 02        	JR C,L21
 173++896B 3E 06        L20	LD A,6
 174++896D 32 85 8D     L21	LD (Version),A
 175++8970 F5           	PUSH AF ;VolTable version
 176++8971 FE 04        	CP 4
 177++8973 DD 7E FF     	LD A,(IX+99-100) ;TONE TABLE NUMBER
 178++8976 17           	RLA
 179++8977 E6 07        	AND 7
 180++8979 F5           	PUSH AF ;NoteTable number
 181++897A
 182++897A FD 21 00 93  	LD IY,VARS2+100
 183++897E 3A E7 88     	LD A,(START+10)
 184++8981 E6 30        	AND 48
 185++8983 28 37        	JR Z,NOTS
 186++8985 FE 10        	CP 16
 187++8987 28 27        	JR Z,TwoPT3s
 188++8989 3A 85 8D     	LD A,(Version)
 189++898C FE 07        	CP 7
 190++898E 38 2C        	JR C,NOTS
 191++8990 DD 7E FE     	LD A,(IX+98-100) ;ALCO TS MARKER
 192++8993 FE 20        	CP #20
 193++8995 28 25        	JR Z,NOTS
 194++8997 21 15 92     	LD HL,VARS1
 195++899A 11 9C 92     	LD DE,VARS2
 196++899D 01 87 00     	LD BC,VRS
 197++89A0 ED B0        	LDIR
 198++89A2 FD CB 9E CE  	SET 1,(IY-100+VRS.ModNum)
 199++89A6 4F           	LD C,A
 200++89A7 87           	ADD A,A
 201++89A8 81           	ADD A,C
 202++89A9 D6 02        	SUB 2
 203++89AB 32 4C 90     	LD (TSSub),A
 204++89AE 18 03        	JR AlCoTS_
 205++89B0 CD 14 8B     TwoPT3s	CALL INITPT3
 206++89B3 3E 01        AlCoTS_	LD A,1
 207++89B5 32 14 92     	LD (is_ts),A
 208++89B8 FD CB 9E C6  	SET 0,(IY-100+VRS.ModNum)
 209++89BC
 210++89BC 01 D1 8C     NOTS	LD BC,PT3PD
 211++89BF 21 00 00     	LD HL,0
 212++89C2 11 DC 91     	LD DE,PT3EMPTYORN
 213++89C5 18 48        	JR INITCOMMON
 214++89C7
 215++89C7 CD 4C 8B     I_PT2	CALL INITPT2
 216++89CA 21 CB 51     	LD HL,#51CB
 217++89CD 22 E7 8E     	LD (SamCnv),HL
 218++89D0 3E BB        	LD A,#BB
 219++89D2 32 B2 8E     	LD (OrnCP),A
 220++89D5 32 DE 8E     	LD (SamCP),A
 221++89D8 3E 7A        	LD A,#7A
 222++89DA 32 B5 8E     	LD (OrnLD),A
 223++89DD 32 E1 8E     	LD (SamLD),A
 224++89E0 3E 80        	LD A,#80
 225++89E2 32 D8 8E     	LD (SamClc2),A
 226++89E5 E1           	POP HL
 227++89E6 3E 05        	LD A,5
 228++89E8 32 85 8D     	LD (Version),A
 229++89EB F5           	PUSH AF
 230++89EC 3E 02        	LD A,2
 231++89EE F5           	PUSH AF
 232++89EF
 233++89EF 3A E7 88     	LD A,(START+10)
 234++89F2 E6 30        	AND 48
 235++89F4 28 10        	JR Z,NOTS2
 236++89F6
 237++89F6 FD 21 00 93  	LD IY,VARS2+100
 238++89FA 3E 01        	LD A,1
 239++89FC 32 14 92     	LD (is_ts),A
 240++89FF FD CB 9E C6  	SET 0,(IY-100+VRS.ModNum)
 241++8A03 CD 4C 8B     	CALL INITPT2
 242++8A06
 243++8A06 01 0B 8C     NOTS2	LD BC,PT2PD
 244++8A09 21 87 86     	LD HL,#8687
 245++8A0C 11 32 93     	LD DE,PT2EMPTYORN
 246++8A0F
 247++8A0F              INITCOMMON
 248++8A0F
 249++8A0F              	IF Basic
 250++8A0F FD 21 3A 5C  	LD IY,#5C3A
 251++8A13              	ENDIF
 252++8A13
 253++8A13 ED 43 BC 8B  	LD (PTDEC),BC
 254++8A17 22 4E 90     	LD (PsCalc),HL
 255++8A1A D5           	PUSH DE
 256++8A1B
 257++8A1B              ;note table data depacker
 258++8A1B              ;(c) Ivan Roshin
 259++8A1B 11 DF 91     	LD DE,T_PACK
 260++8A1E 01 84 93     	LD BC,T1_+(2*49)-1
 261++8A21 1A           TP_0	LD A,(DE)
 262++8A22 13           	INC DE
 263++8A23 FE 1E        	CP 15*2
 264++8A25 30 06        	JR NC,TP_1
 265++8A27 67           	LD H,A
 266++8A28 1A           	LD A,(DE)
 267++8A29 6F           	LD L,A
 268++8A2A 13           	INC DE
 269++8A2B 18 07        	JR TP_2
 270++8A2D D5           TP_1	PUSH DE
 271++8A2E 16 00        	LD D,0
 272++8A30 5F           	LD E,A
 273++8A31 19           	ADD HL,DE
 274++8A32 19           	ADD HL,DE
 275++8A33 D1           	POP DE
 276++8A34 7C           TP_2	LD A,H
 277++8A35 02           	LD (BC),A
 278++8A36 0B           	DEC BC
 279++8A37 7D           	LD A,L
 280++8A38 02           	LD (BC),A
 281++8A39 0B           	DEC BC
player.asm(282): warning: value 0x1F0 is truncated to 8bit value: 0xF0
 282++8A3A D6 F0        	SUB #F8*2
 283++8A3C 20 E3        	JR NZ,TP_0
 284++8A3E
 285++8A3E 3C           	INC A
 286++8A3F 32 82 92     	LD (VARS1+VRS.DelyCnt),A
 287++8A42 32 09 93     	LD (VARS2+VRS.DelyCnt),A
 288++8A45 21 01 F0     	LD HL,#F001 ;H - CHP.Volume, L - CHP.NtSkCn
 289++8A48 22 33 92     	LD (VARS1+VRS.ChanA+CHP.NtSkCn),HL
 290++8A4B 22 50 92     	LD (VARS1+VRS.ChanB+CHP.NtSkCn),HL
 291++8A4E 22 6D 92     	LD (VARS1+VRS.ChanC+CHP.NtSkCn),HL
 292++8A51 22 BA 92     	LD (VARS2+VRS.ChanA+CHP.NtSkCn),HL
 293++8A54 22 D7 92     	LD (VARS2+VRS.ChanB+CHP.NtSkCn),HL
 294++8A57 22 F4 92     	LD (VARS2+VRS.ChanC+CHP.NtSkCn),HL
 295++8A5A E1           	POP HL
 296++8A5B 22 25 92     	LD (VARS1+VRS.ChanA+CHP.OrnPtr),HL
 297++8A5E 22 42 92     	LD (VARS1+VRS.ChanB+CHP.OrnPtr),HL
 298++8A61 22 5F 92     	LD (VARS1+VRS.ChanC+CHP.OrnPtr),HL
 299++8A64 22 AC 92     	LD (VARS2+VRS.ChanA+CHP.OrnPtr),HL
 300++8A67 22 C9 92     	LD (VARS2+VRS.ChanB+CHP.OrnPtr),HL
 301++8A6A 22 E6 92     	LD (VARS2+VRS.ChanC+CHP.OrnPtr),HL
 302++8A6D
 303++8A6D F1           	POP AF
 304++8A6E
 305++8A6E              ;NoteTableCreator (c) Ivan Roshin
 306++8A6E              ;A - NoteTableNumber*2+VersionForNoteTable
 307++8A6E              ;(xx1b - 3.xx..3.4r, xx0b - 3.4x..3.6x..VTII1.0)
 308++8A6E
 309++8A6E 21 8C 91     	LD HL,NT_DATA
 310++8A71 16 00        	LD D,0
 311++8A73 87           	ADD A,A
 312++8A74 5F           	LD E,A
 313++8A75 19           	ADD HL,DE
 314++8A76 5E           	LD E,(HL)
 315++8A77 23           	INC HL
 316++8A78 CB 3B        	SRL E
 317++8A7A 9F           	SBC A,A
 318++8A7B E6 A7        	AND #A7 ;#00 (NOP) or #A7 (AND A)
 319++8A7D 32 A5 8A     	LD (L3),A
 320++8A80 EB           	EX DE,HL
 321++8A81 01 23 93     	LD BC,T1_
 322++8A84 09           	ADD HL,BC
 323++8A85
 324++8A85 1A           	LD A,(DE)
player.asm(325): warning: value 0x919C is truncated to 8bit value: 0x9C
 325++8A86 C6 9C        	ADD A,T_
 326++8A88 4F           	LD C,A
 327++8A89 CE 91        	ADC A,T_/256
 328++8A8B 91           	SUB C
 329++8A8C 47           	LD B,A
 330++8A8D C5           	PUSH BC
 331++8A8E 11 13 94     	LD DE,NT_
 332++8A91 D5           	PUSH DE
 333++8A92
 334++8A92 06 0C        	LD B,12
 335++8A94 C5           L1	PUSH BC
 336++8A95 4E           	LD C,(HL)
 337++8A96 23           	INC HL
 338++8A97 E5           	PUSH HL
 339++8A98 46           	LD B,(HL)
 340++8A99
 341++8A99 D5           	PUSH DE
 342++8A9A EB           	EX DE,HL
 343++8A9B 11 17 00     	LD DE,23
 344++8A9E DD 26 08     	LD IXH,8
 345++8AA1
 346++8AA1 CB 38        L2	SRL B
 347++8AA3 CB 19        	RR C
 348++8AA5 19           L3	DB #19	;AND A or NOP
 349++8AA6 79           	LD A,C
 350++8AA7 8A           	ADC A,D	;=ADC 0
 351++8AA8 77           	LD (HL),A
 352++8AA9 23           	INC HL
 353++8AAA 78           	LD A,B
 354++8AAB 8A           	ADC A,D
 355++8AAC 77           	LD (HL),A
 356++8AAD 19           	ADD HL,DE
 357++8AAE DD 25        	DEC IXH
 358++8AB0 20 EF        	JR NZ,L2
 359++8AB2
 360++8AB2 D1           	POP DE
 361++8AB3 13           	INC DE
 362++8AB4 13           	INC DE
 363++8AB5 E1           	POP HL
 364++8AB6 23           	INC HL
 365++8AB7 C1           	POP BC
 366++8AB8 10 DA        	DJNZ L1
 367++8ABA
 368++8ABA E1           	POP HL
 369++8ABB D1           	POP DE
 370++8ABC
 371++8ABC 7B           	LD A,E
player.asm(372): warning: value 0x91A8 is truncated to 8bit value: 0xA8
 372++8ABD FE A8        	CP TCOLD_1
 373++8ABF 20 05        	JR NZ,CORR_1
 374++8AC1 3E FD        	LD A,#FD
 375++8AC3 32 41 94     	LD (NT_+#2E),A
 376++8AC6
 377++8AC6 1A           CORR_1	LD A,(DE)
 378++8AC7 A7           	AND A
 379++8AC8 28 11        	JR Z,TC_EXIT
 380++8ACA 1F           	RRA
 381++8ACB F5           	PUSH AF
 382++8ACC 87           	ADD A,A
 383++8ACD 4F           	LD C,A
 384++8ACE 09           	ADD HL,BC
 385++8ACF F1           	POP AF
 386++8AD0 30 02        	JR NC,CORR_2
 387++8AD2 35           	DEC (HL)
 388++8AD3 35           	DEC (HL)
 389++8AD4 34           CORR_2	INC (HL)
 390++8AD5 A7           	AND A
 391++8AD6 ED 42        	SBC HL,BC
 392++8AD8 13           	INC DE
 393++8AD9 18 EB        	JR CORR_1
 394++8ADB
 395++8ADB              TC_EXIT
 396++8ADB
 397++8ADB F1           	POP AF
 398++8ADC
 399++8ADC              ;VolTableCreator (c) Ivan Roshin
 400++8ADC              ;A - VersionForVolumeTable (0..4 - 3.xx..3.4x;
 401++8ADC              			   ;5.. - 2.x,3.5x..3.6x..VTII1.0)
 402++8ADC
 403++8ADC FE 05        	CP 5
 404++8ADE 21 11 00     	LD HL,#11
 405++8AE1 54           	LD D,H
 406++8AE2 5C           	LD E,H
 407++8AE3 3E 17        	LD A,#17
 408++8AE5 30 03        	JR NC,M1
 409++8AE7 2D           	DEC L
 410++8AE8 5D           	LD E,L
 411++8AE9 AF           	XOR A
 412++8AEA 32 FB 8A     M1      LD (M2),A
 413++8AED
 414++8AED DD 21 23 93  	LD IX,VT_+16
 415++8AF1
 416++8AF1 0E 0F        	LD C,#F
 417++8AF3 E5           INITV2  PUSH HL
 418++8AF4
 419++8AF4 19           	ADD HL,DE
 420++8AF5 EB           	EX DE,HL
 421++8AF6 ED 62        	SBC HL,HL
 422++8AF8
 423++8AF8 06 10        	LD B,#10
 424++8AFA 7D           INITV1  LD A,L
 425++8AFB 7D           M2      DB #7D
 426++8AFC 7C           	LD A,H
 427++8AFD CE 00        	ADC A,0
 428++8AFF DD 77 00     	LD (IX),A
 429++8B02 DD 23        	INC IX
 430++8B04 19           	ADD HL,DE
 431++8B05 10 F3        	DJNZ INITV1
 432++8B07
 433++8B07 E1           	POP HL
 434++8B08 7B           	LD A,E
 435++8B09 FE 77        	CP #77
 436++8B0B 20 01        	JR NZ,M3
 437++8B0D 1C           	INC E
 438++8B0E 0D           M3      DEC C
 439++8B0F 20 E2        	JR NZ,INITV2
 440++8B11
 441++8B11 C3 59 91     	JP ROUT
 442++8B14
 443++8B14 CD 87 8B     INITPT3	CALL SETMDAD
 444++8B17 E5           	PUSH HL
 445++8B18 11 64 00     	LD DE,100
 446++8B1B 19           	ADD HL,DE
 447++8B1C 7E           	LD A,(HL)
 448++8B1D FD 77 08     	LD (IY-100+VRS.Delay),A
 449++8B20 E5           	PUSH HL
 450++8B21 DD E1        	POP IX
 451++8B23 19           	ADD HL,DE
 452++8B24 CD 95 8B     	CALL SETCPPT
 453++8B27 DD 5E 02     	LD E,(IX+102-100)
 454++8B2A 23           	INC HL
 455++8B2B
 456++8B2B              	IF CurPosCounter
 457++8B2B ~            	LD (IY-100+VRS.PosSub),L
 458++8B2B              	ENDIF
 459++8B2B
 460++8B2B 19           	ADD HL,DE
 461++8B2C CD 9C 8B     	CALL SETLPPT
 462++8B2F D1           	POP DE
 463++8B30 DD 6E 03     	LD L,(IX+103-100)
 464++8B33 DD 66 04     	LD H,(IX+104-100)
 465++8B36 19           	ADD HL,DE
 466++8B37 CD 80 8B     	CALL SETPTPT
 467++8B3A 21 A9 00     	LD HL,169
 468++8B3D 19           	ADD HL,DE
 469++8B3E CD 8E 8B     	CALL SETORPT
 470++8B41 21 69 00     	LD HL,105
 471++8B44 19           	ADD HL,DE
 472++8B45
 473++8B45 FD 75 FA     SETSMPT LD (IY-100+VRS.SamPtrs),L
 474++8B48 FD 74 FB     	LD (IY-100+VRS.SamPtrs+1),H
 475++8B4B C9           	RET
 476++8B4C
 477++8B4C 7E           INITPT2	LD A,(HL)
 478++8B4D FD 77 08     	LD (IY-100+VRS.Delay),A
 479++8B50 E5           	PUSH HL
 480++8B51 E5           	PUSH HL
 481++8B52 E5           	PUSH HL
 482++8B53 23           	INC HL
 483++8B54 23           	INC HL
 484++8B55 7E           	LD A,(HL)
 485++8B56 23           	INC HL
 486++8B57 CD 45 8B     	CALL SETSMPT
 487++8B5A 5E           	LD E,(HL)
 488++8B5B 23           	INC HL
 489++8B5C 56           	LD D,(HL)
 490++8B5D E1           	POP HL
 491++8B5E A7           	AND A
 492++8B5F ED 52        	SBC HL,DE
 493++8B61 CD 87 8B     	CALL SETMDAD
 494++8B64 E1           	POP HL
 495++8B65 11 43 00     	LD DE,67
 496++8B68 19           	ADD HL,DE
 497++8B69 CD 8E 8B     	CALL SETORPT
 498++8B6C 1E 20        	LD E,32
 499++8B6E 19           	ADD HL,DE
 500++8B6F 4E           	LD C,(HL)
 501++8B70 23           	INC HL
 502++8B71 46           	LD B,(HL)
 503++8B72 1E 1E        	LD E,30
 504++8B74 19           	ADD HL,DE
 505++8B75 CD 95 8B     	CALL SETCPPT
 506++8B78 5F           	LD E,A
 507++8B79 23           	INC HL
 508++8B7A
 509++8B7A              	IF CurPosCounter
 510++8B7A ~            	LD (IY-100+VRS.PosSub),L
 511++8B7A              	ENDIF
 512++8B7A
 513++8B7A 19           	ADD HL,DE
 514++8B7B CD 9C 8B     	CALL SETLPPT
 515++8B7E E1           	POP HL
 516++8B7F 09           	ADD HL,BC
 517++8B80
 518++8B80 FD 75 FC     SETPTPT	LD (IY-100+VRS.PatsPtr),L
 519++8B83 FD 74 FD     	LD (IY-100+VRS.PatsPtr+1),H
 520++8B86 C9           	RET
 521++8B87
 522++8B87 FD 75 F6     SETMDAD	LD (IY-100+VRS.MODADDR),L
 523++8B8A FD 74 F7     	LD (IY-100+VRS.MODADDR+1),H
 524++8B8D C9           	RET
 525++8B8E
 526++8B8E FD 75 F8     SETORPT	LD (IY-100+VRS.OrnPtrs),L
 527++8B91 FD 74 F9     	LD (IY-100+VRS.OrnPtrs+1),H
 528++8B94 C9           	RET
 529++8B95
 530++8B95 FD 75 04     SETCPPT	LD (IY-100+VRS.CrPsPtr),L
 531++8B98 FD 74 05     	LD (IY-100+VRS.CrPsPtr+1),H
 532++8B9B C9           	RET
 533++8B9C
 534++8B9C FD 75 06     SETLPPT	LD (IY-100+VRS.LPosPtr),L
 535++8B9F FD 74 07     	LD (IY-100+VRS.LPosPtr+1),H
 536++8BA2 C9           	RET
 537++8BA3
 538++8BA3 FD 75 13     SETENBS	LD (IY-100+VRS.EnvBase),L
 539++8BA6 FD 74 14     	LD (IY-100+VRS.EnvBase+1),H
 540++8BA9 C9           	RET
 541++8BAA
 542++8BAA FD 75 0C     SETESLD	LD (IY-100+VRS.CurESld),L
 543++8BAD FD 74 0D     	LD (IY-100+VRS.CurESld+1),H
 544++8BB0 C9           	RET
 545++8BB1
 546++8BB1 FD E5        GETIX	PUSH IY
 547++8BB3 DD E1        	POP IX
 548++8BB5 DD 19        	ADD IX,DE
 549++8BB7 C9           	RET
 550++8BB8
 551++8BB8 CD B1 8B     PTDECOD CALL GETIX
 552++8BBB              PTDEC	EQU $+1
 553++8BBB C3 C3 C3     	JP #C3C3
 554++8BBE
 555++8BBE              ;PT2 pattern decoder
 556++8BBE CD 54 8E     PD2_SAM	CALL SETSAM
 557++8BC1 18 4A        	JR PD2_LOOP
 558++8BC3
 559++8BC3 DD 77 08     PD2_EOff LD (IX-12+CHP.Env_En),A
 560++8BC6 18 45        	JR PD2_LOOP
 561++8BC8
 562++8BC8 DD 36 08 10  PD2_ENV	LD (IX-12+CHP.Env_En),16
 563++8BCC FD 77 22     	LD (IY-100+VRS.AYREGS+EnvTp),A
 564++8BCF 0A           	LD A,(BC)
 565++8BD0 03           	INC BC
 566++8BD1 6F           	LD L,A
 567++8BD2 0A           	LD A,(BC)
 568++8BD3 03           	INC BC
 569++8BD4 67           	LD H,A
 570++8BD5 CD A3 8B     	CALL SETENBS
 571++8BD8 18 33        	JR PD2_LOOP
 572++8BDA
 573++8BDA CD 35 8E     PD2_ORN	CALL SETORN
 574++8BDD 18 2E        	JR PD2_LOOP
 575++8BDF
 576++8BDF 3C           PD2_SKIP INC A
 577++8BE0 DD 77 05     	LD (IX-12+CHP.NNtSkp),A
 578++8BE3 18 28        	JR PD2_LOOP
 579++8BE5
 580++8BE5 0F           PD2_VOL	RRCA
 581++8BE6 0F           	RRCA
 582++8BE7 0F           	RRCA
 583++8BE8 0F           	RRCA
 584++8BE9 DD 77 10     	LD (IX-12+CHP.Volume),A
 585++8BEC 18 1F        	JR PD2_LOOP
 586++8BEE
 587++8BEE CD 05 8E     PD2_DEL	CALL C_DELAY
 588++8BF1 18 1A        	JR PD2_LOOP
 589++8BF3
 590++8BF3 DD CB 09 D6  PD2_GLIS SET 2,(IX-12+CHP.Flags)
 591++8BF7 3C           	INC A
 592++8BF8 DD 77 0A     	LD (IX-12+CHP.TnSlDl),A
 593++8BFB DD 77 F9     	LD (IX-12+CHP.TSlCnt),A
 594++8BFE 0A           	LD A,(BC)
 595++8BFF 03           	INC BC
 596++8C00 DD 77 0B             LD (IX-12+CHP.TSlStp),A
 597++8C03 87           	ADD A,A
 598++8C04 9F           	SBC A,A
 599++8C05 DD 77 0C             LD (IX-12+CHP.TSlStp+1),A
 600++8C08 37           	SCF
 601++8C09 18 01        	JR PD2_LP2
 602++8C0B
 603++8C0B A7           PT2PD	AND A
 604++8C0C
 605++8C0C 08           PD2_LP2	EX AF,AF'
 606++8C0D
 607++8C0D 0A           PD2_LOOP LD A,(BC)
 608++8C0E 03           	INC BC
 609++8C0F C6 20        	ADD A,#20
 610++8C11 28 3F        	JR Z,PD2_REL
 611++8C13 38 A9        	JR C,PD2_SAM
 612++8C15 C6 60        	ADD A,96
 613++8C17 38 3E        	JR C,PD2_NOTE
 614++8C19 3C           	INC A
 615++8C1A 28 A7        	JR Z,PD2_EOff
 616++8C1C C6 0F        	ADD A,15
 617++8C1E CA 34 8D     	JP Z,PD_FIN
 618++8C21 38 A5        	JR C,PD2_ENV
 619++8C23 C6 10        	ADD A,#10
 620++8C25 38 B3        	JR C,PD2_ORN
 621++8C27 C6 40        	ADD A,#40
 622++8C29 38 B4        	JR C,PD2_SKIP
 623++8C2B C6 10        	ADD A,#10
 624++8C2D 38 B6        	JR C,PD2_VOL
 625++8C2F 3C           	INC A
 626++8C30 28 BC        	JR Z,PD2_DEL
 627++8C32 3C           	INC A
 628++8C33 28 BE        	JR Z,PD2_GLIS
 629++8C35 3C           	INC A
 630++8C36 28 0A        	JR Z,PD2_PORT
 631++8C38 3C           	INC A
 632++8C39 28 12        	JR Z,PD2_STOP
 633++8C3B 0A           	LD A,(BC)
 634++8C3C 03           	INC BC
 635++8C3D DD 77 F7     	LD (IX-12+CHP.CrNsSl),A
 636++8C40 18 CB        	JR PD2_LOOP
 637++8C42
 638++8C42 DD CB 09 96  PD2_PORT RES 2,(IX-12+CHP.Flags)
 639++8C46 0A           	LD A,(BC)
 640++8C47 03           	INC BC
 641++8C48 03           	INC BC ;ignoring precalc delta to right sound
 642++8C49 03           	INC BC
 643++8C4A 37           	SCF
 644++8C4B 18 BF        	JR PD2_LP2
 645++8C4D
 646++8C4D DD 77 F9     PD2_STOP LD (IX-12+CHP.TSlCnt),A
 647++8C50 18 BB        	JR PD2_LOOP
 648++8C52
 649++8C52 DD 77 09     PD2_REL	LD (IX-12+CHP.Flags),A
 650++8C55 18 2C        	JR PD2_EXIT
 651++8C57
 652++8C57 6F           PD2_NOTE LD L,A
 653++8C58 DD 7E 06     	LD A,(IX-12+CHP.Note)
 654++8C5B 32 6E 8D     	LD (PrNote+1),A
 655++8C5E DD 75 06     	LD (IX-12+CHP.Note),L
 656++8C61 AF           	XOR A
 657++8C62 DD 77 F9     	LD (IX-12+CHP.TSlCnt),A
 658++8C65 DD CB 09 C6  	SET 0,(IX-12+CHP.Flags)
 659++8C69 08           	EX AF,AF'
 660++8C6A 30 16        	JR NC,NOGLIS2
 661++8C6C DD CB 09 56  	BIT 2,(IX-12+CHP.Flags)
 662++8C70 20 0C        	JR NZ,NOPORT2
 663++8C72 32 94 8D     	LD (LoStep),A
 664++8C75 87           	ADD A,A
 665++8C76 9F           	SBC A,A
 666++8C77 08           	EX AF,AF'
 667++8C78 67           	LD H,A
 668++8C79 6F           	LD L,A
 669++8C7A 3C           	INC A
 670++8C7B CD 4F 8D     	CALL SETPORT
 671++8C7E DD 36 F9 01  NOPORT2	LD (IX-12+CHP.TSlCnt),1
 672++8C82 AF           NOGLIS2	XOR A
 673++8C83
 674++8C83
 675++8C83 DD 77 F5     PD2_EXIT LD (IX-12+CHP.PsInSm),A
 676++8C86 DD 77 F4     	LD (IX-12+CHP.PsInOr),A
 677++8C89 DD 77 FA     	LD (IX-12+CHP.CrTnSl),A
 678++8C8C DD 77 FB     	LD (IX-12+CHP.CrTnSl+1),A
 679++8C8F C3 34 8D     	JP PD_FIN
 680++8C92
 681++8C92              ;PT3 pattern decoder
 682++8C92 DD 36 08 00  PD_OrSm	LD (IX-12+CHP.Env_En),0
 683++8C96 CD 35 8E     	CALL SETORN
 684++8C99 0A           PD_SAM_	LD A,(BC)
 685++8C9A 03           	INC BC
 686++8C9B 0F           	RRCA
 687++8C9C
 688++8C9C CD 54 8E     PD_SAM	CALL SETSAM
 689++8C9F 18 3F        	JR PD_LOOP
 690++8CA1
 691++8CA1 0F           PD_VOL	RRCA
 692++8CA2 0F           	RRCA
 693++8CA3 0F           	RRCA
 694++8CA4 0F           	RRCA
 695++8CA5 DD 77 10     	LD (IX-12+CHP.Volume),A
 696++8CA8 18 39        	JR PD_LP2
 697++8CAA
 698++8CAA DD 77 08     PD_EOff	LD (IX-12+CHP.Env_En),A
 699++8CAD DD 77 F4     	LD (IX-12+CHP.PsInOr),A
 700++8CB0 18 31        	JR PD_LP2
 701++8CB2
 702++8CB2 3D           PD_SorE	DEC A
 703++8CB3 20 07        	JR NZ,PD_ENV
 704++8CB5 0A           	LD A,(BC)
 705++8CB6 03           	INC BC
 706++8CB7 DD 77 05     	LD (IX-12+CHP.NNtSkp),A
 707++8CBA 18 27        	JR PD_LP2
 708++8CBC
 709++8CBC CD 1A 8E     PD_ENV	CALL SETENV
 710++8CBF 18 22        	JR PD_LP2
 711++8CC1
 712++8CC1 CD 35 8E     PD_ORN	CALL SETORN
 713++8CC4 18 1A        	JR PD_LOOP
 714++8CC6
 715++8CC6 DD 77 08     PD_ESAM	LD (IX-12+CHP.Env_En),A
 716++8CC9 DD 77 F4     	LD (IX-12+CHP.PsInOr),A
 717++8CCC C4 1A 8E     	CALL NZ,SETENV
 718++8CCF 18 C8        	JR PD_SAM_
 719++8CD1
 720++8CD1 DD 7E 06     PT3PD	LD A,(IX-12+CHP.Note)
 721++8CD4 32 6E 8D     	LD (PrNote+1),A
 722++8CD7 DD 6E FA     	LD L,(IX-12+CHP.CrTnSl)
 723++8CDA DD 66 FB     	LD H,(IX-12+CHP.CrTnSl+1)
 724++8CDD 22 8B 8D     	LD (PrSlide+1),HL
 725++8CE0
 726++8CE0 11 10 20     PD_LOOP	LD DE,#2010
 727++8CE3 0A           PD_LP2	LD A,(BC)
 728++8CE4 03           	INC BC
 729++8CE5 83           	ADD A,E
 730++8CE6 38 AA        	JR C,PD_OrSm
 731++8CE8 82           	ADD A,D
 732++8CE9 28 49        	JR Z,PD_FIN
 733++8CEB 38 AF        	JR C,PD_SAM
 734++8CED 83           	ADD A,E
 735++8CEE 28 25        	JR Z,PD_REL
 736++8CF0 38 AF        	JR C,PD_VOL
 737++8CF2 83           	ADD A,E
 738++8CF3 28 B5        	JR Z,PD_EOff
 739++8CF5 38 BB        	JR C,PD_SorE
 740++8CF7 C6 60        	ADD A,96
 741++8CF9 38 20        	JR C,PD_NOTE
 742++8CFB 83           	ADD A,E
 743++8CFC 38 C3        	JR C,PD_ORN
 744++8CFE 82           	ADD A,D
 745++8CFF 38 0F        	JR C,PD_NOIS
 746++8D01 83           	ADD A,E
 747++8D02 38 C2        	JR C,PD_ESAM
 748++8D04 87           	ADD A,A
 749++8D05 5F           	LD E,A
player.asm(750): warning: value 0x16D90 is truncated to 16bit value: 0x6D90
 750++8D06 21 90 6D     	LD HL,SPCCOMS+#FF20-#2000
 751++8D09 19           	ADD HL,DE
 752++8D0A 5E           	LD E,(HL)
 753++8D0B 23           	INC HL
 754++8D0C 56           	LD D,(HL)
 755++8D0D D5           	PUSH DE
 756++8D0E 18 D0        	JR PD_LOOP
 757++8D10
 758++8D10 FD 77 10     PD_NOIS	LD (IY-100+VRS.Ns_Base),A
 759++8D13 18 CE        	JR PD_LP2
 760++8D15
 761++8D15 DD CB 09 86  PD_REL	RES 0,(IX-12+CHP.Flags)
 762++8D19 18 08        	JR PD_RES
 763++8D1B
 764++8D1B DD 77 06     PD_NOTE	LD (IX-12+CHP.Note),A
 765++8D1E DD CB 09 C6  	SET 0,(IX-12+CHP.Flags)
 766++8D22 AF           	XOR A
 767++8D23
 768++8D23 ED 73 32 8D  PD_RES	LD (PDSP_+1),SP
 769++8D27 DD F9        	LD SP,IX
 770++8D29 67           	LD H,A
 771++8D2A 6F           	LD L,A
 772++8D2B E5           	PUSH HL
 773++8D2C E5           	PUSH HL
 774++8D2D E5           	PUSH HL
 775++8D2E E5           	PUSH HL
 776++8D2F E5           	PUSH HL
 777++8D30 E5           	PUSH HL
 778++8D31 31 31 31     PDSP_	LD SP,#3131
 779++8D34
 780++8D34 DD 7E 05     PD_FIN	LD A,(IX-12+CHP.NNtSkp)
 781++8D37 DD 77 0F     	LD (IX-12+CHP.NtSkCn),A
 782++8D3A C9           	RET
 783++8D3B
 784++8D3B 0A           C_PORTM LD A,(BC)
 785++8D3C 03           	INC BC
 786++8D3D              ;SKIP PRECALCULATED TONE DELTA (BECAUSE
 787++8D3D              ;CANNOT BE RIGHT AFTER PT3 COMPILATION)
 788++8D3D 03           	INC BC
 789++8D3E 03           	INC BC
 790++8D3F 08           	EX AF,AF'
 791++8D40 0A           	LD A,(BC) ;SIGNED TONE STEP
 792++8D41 03           	INC BC
 793++8D42 32 94 8D     	LD (LoStep),A
 794++8D45 0A           	LD A,(BC)
 795++8D46 03           	INC BC
 796++8D47 A7           	AND A
 797++8D48 08           	EX AF,AF'
 798++8D49 DD 6E FA     	LD L,(IX-12+CHP.CrTnSl)
 799++8D4C DD 66 FB     	LD H,(IX-12+CHP.CrTnSl+1)
 800++8D4F
 801++8D4F              ;Set portamento variables
 802++8D4F              ;A - Delay; A' - Hi(Step); ZF' - (A'=0); HL - CrTnSl
 803++8D4F
 804++8D4F DD CB 09 96  SETPORT	RES 2,(IX-12+CHP.Flags)
 805++8D53 DD 77 0A     	LD (IX-12+CHP.TnSlDl),A
 806++8D56 DD 77 F9     	LD (IX-12+CHP.TSlCnt),A
 807++8D59 E5           	PUSH HL
 808++8D5A 11 13 94     	LD DE,NT_
 809++8D5D DD 7E 06     	LD A,(IX-12+CHP.Note)
 810++8D60 DD 77 07     	LD (IX-12+CHP.SlToNt),A
 811++8D63 87           	ADD A,A
 812++8D64 6F           	LD L,A
 813++8D65 26 00        	LD H,0
 814++8D67 19           	ADD HL,DE
 815++8D68 7E           	LD A,(HL)
 816++8D69 23           	INC HL
 817++8D6A 66           	LD H,(HL)
 818++8D6B 6F           	LD L,A
 819++8D6C E5           	PUSH HL
 820++8D6D 3E 3E        PrNote	LD A,#3E
 821++8D6F DD 77 06     	LD (IX-12+CHP.Note),A
 822++8D72 87           	ADD A,A
 823++8D73 6F           	LD L,A
 824++8D74 26 00        	LD H,0
 825++8D76 19           	ADD HL,DE
 826++8D77 5E           	LD E,(HL)
 827++8D78 23           	INC HL
 828++8D79 56           	LD D,(HL)
 829++8D7A E1           	POP HL
 830++8D7B ED 52        	SBC HL,DE
 831++8D7D DD 75 0D     	LD (IX-12+CHP.TnDelt),L
 832++8D80 DD 74 0E     	LD (IX-12+CHP.TnDelt+1),H
 833++8D83 D1           	POP DE
 834++8D84              Version EQU $+1
 835++8D84 3E 3E        	LD A,#3E
 836++8D86 FE 06        	CP 6
 837++8D88 38 09        	JR C,OLDPRTM ;Old 3xxx for PT v3.5-
 838++8D8A 11 11 11     PrSlide	LD DE,#1111
 839++8D8D DD 73 FA     	LD (IX-12+CHP.CrTnSl),E
 840++8D90 DD 72 FB     	LD (IX-12+CHP.CrTnSl+1),D
 841++8D93              LoStep	EQU $+1
 842++8D93 3E 3E        OLDPRTM	LD A,#3E
 843++8D95 08           	EX AF,AF'
 844++8D96 28 01        	JR Z,NOSIG
 845++8D98 EB           	EX DE,HL
 846++8D99 ED 52        NOSIG	SBC HL,DE
 847++8D9B F2 A3 8D     	JP P,SET_STP
 848++8D9E 2F           	CPL
 849++8D9F 08           	EX AF,AF'
 850++8DA0 ED 44        	NEG
 851++8DA2 08           	EX AF,AF'
 852++8DA3 DD 77 0C     SET_STP	LD (IX-12+CHP.TSlStp+1),A
 853++8DA6 08           	EX AF,AF'
 854++8DA7 DD 77 0B     	LD (IX-12+CHP.TSlStp),A
 855++8DAA DD 36 FE 00  	LD (IX-12+CHP.COnOff),0
 856++8DAE C9           	RET
 857++8DAF
 858++8DAF DD CB 09 D6  C_GLISS	SET 2,(IX-12+CHP.Flags)
 859++8DB3 0A           	LD A,(BC)
 860++8DB4 03           	INC BC
 861++8DB5 DD 77 0A     	LD (IX-12+CHP.TnSlDl),A
 862++8DB8 A7           	AND A
 863++8DB9 20 07        	JR NZ,GL36
 864++8DBB 3A 85 8D     	LD A,(Version) ;AlCo PT3.7+
 865++8DBE FE 07        	CP 7
 866++8DC0 9F           	SBC A,A
 867++8DC1 3C           	INC A
 868++8DC2 DD 77 F9     GL36	LD (IX-12+CHP.TSlCnt),A
 869++8DC5 0A           	LD A,(BC)
 870++8DC6 03           	INC BC
 871++8DC7 08           	EX AF,AF'
 872++8DC8 0A           	LD A,(BC)
 873++8DC9 03           	INC BC
 874++8DCA 18 D7        	JR SET_STP
 875++8DCC
 876++8DCC 0A           C_SMPOS	LD A,(BC)
 877++8DCD 03           	INC BC
 878++8DCE DD 77 F5     	LD (IX-12+CHP.PsInSm),A
 879++8DD1 C9           	RET
 880++8DD2
 881++8DD2 0A           C_ORPOS	LD A,(BC)
 882++8DD3 03           	INC BC
 883++8DD4 DD 77 F4     	LD (IX-12+CHP.PsInOr),A
 884++8DD7 C9           	RET
 885++8DD8
 886++8DD8 0A           C_VIBRT	LD A,(BC)
 887++8DD9 03           	INC BC
 888++8DDA DD 77 FF     	LD (IX-12+CHP.OnOffD),A
 889++8DDD DD 77 FE     	LD (IX-12+CHP.COnOff),A
 890++8DE0 0A           	LD A,(BC)
 891++8DE1 03           	INC BC
 892++8DE2 DD 77 00     	LD (IX-12+CHP.OffOnD),A
 893++8DE5 AF           	XOR A
 894++8DE6 DD 77 F9     	LD (IX-12+CHP.TSlCnt),A
 895++8DE9 DD 77 FA     	LD (IX-12+CHP.CrTnSl),A
 896++8DEC DD 77 FB     	LD (IX-12+CHP.CrTnSl+1),A
 897++8DEF C9           	RET
 898++8DF0
 899++8DF0 0A           C_ENGLS	LD A,(BC)
 900++8DF1 03           	INC BC
 901++8DF2 FD 77 0E     	LD (IY-100+VRS.Env_Del),A
 902++8DF5 FD 77 0F     	LD (IY-100+VRS.CurEDel),A
 903++8DF8 0A           	LD A,(BC)
 904++8DF9 03           	INC BC
 905++8DFA 6F           	LD L,A
 906++8DFB 0A           	LD A,(BC)
 907++8DFC 03           	INC BC
 908++8DFD 67           	LD H,A
 909++8DFE FD 75 0A     	LD (IY-100+VRS.ESldAdd),L
 910++8E01 FD 74 0B     	LD (IY-100+VRS.ESldAdd+1),H
 911++8E04 C9           	RET
 912++8E05
 913++8E05 0A           C_DELAY	LD A,(BC)
 914++8E06 03           	INC BC
 915++8E07 FD 77 08     	LD (IY-100+VRS.Delay),A
 916++8E0A 21 9E 92     	LD HL,VARS2+VRS.ModNum ;if AlCo_TS
 917++8E0D CB 4E        	BIT 1,(HL)
 918++8E0F C8           	RET Z
 919++8E10 32 81 92     	LD (VARS1+VRS.Delay),A
 920++8E13 32 82 92     	LD (VARS1+VRS.DelyCnt),A
 921++8E16 32 08 93     	LD (VARS2+VRS.Delay),A
 922++8E19 C9           	RET
 923++8E1A
 924++8E1A DD 73 08     SETENV	LD (IX-12+CHP.Env_En),E
 925++8E1D FD 77 22     	LD (IY-100+VRS.AYREGS+EnvTp),A
 926++8E20 0A           	LD A,(BC)
 927++8E21 03           	INC BC
 928++8E22 67           	LD H,A
 929++8E23 0A           	LD A,(BC)
 930++8E24 03           	INC BC
 931++8E25 6F           	LD L,A
 932++8E26 CD A3 8B     	CALL SETENBS
 933++8E29 AF           	XOR A
 934++8E2A DD 77 F4     	LD (IX-12+CHP.PsInOr),A
 935++8E2D FD 77 0F     	LD (IY-100+VRS.CurEDel),A
 936++8E30 67           	LD H,A
 937++8E31 6F           	LD L,A
 938++8E32 C3 AA 8B     	JP SETESLD
 939++8E35
 940++8E35 87           SETORN	ADD A,A
 941++8E36 5F           	LD E,A
 942++8E37 16 00        	LD D,0
 943++8E39 DD 72 F4     	LD (IX-12+CHP.PsInOr),D
 944++8E3C FD 6E F8     	LD L,(IY-100+VRS.OrnPtrs)
 945++8E3F FD 66 F9     	LD H,(IY-100+VRS.OrnPtrs+1)
 946++8E42 19           	ADD HL,DE
 947++8E43 5E           	LD E,(HL)
 948++8E44 23           	INC HL
 949++8E45 56           	LD D,(HL)
 950++8E46 FD 6E F6     	LD L,(IY-100+VRS.MODADDR)
 951++8E49 FD 66 F7     	LD H,(IY-100+VRS.MODADDR+1)
 952++8E4C 19           	ADD HL,DE
 953++8E4D DD 75 01     	LD (IX-12+CHP.OrnPtr),L
 954++8E50 DD 74 02     	LD (IX-12+CHP.OrnPtr+1),H
 955++8E53 C9           C_NOP	RET
 956++8E54
 957++8E54 87           SETSAM	ADD A,A
 958++8E55 5F           	LD E,A
 959++8E56 16 00        	LD D,0
 960++8E58 FD 6E FA     	LD L,(IY-100+VRS.SamPtrs);
 961++8E5B FD 66 FB     	LD H,(IY-100+VRS.SamPtrs+1);
 962++8E5E 19           	ADD HL,DE
 963++8E5F 5E           	LD E,(HL)
 964++8E60 23           	INC HL
 965++8E61 56           	LD D,(HL)
 966++8E62 FD 6E F6     	LD L,(IY-100+VRS.MODADDR)
 967++8E65 FD 66 F7     	LD H,(IY-100+VRS.MODADDR+1)
 968++8E68 19           	ADD HL,DE
 969++8E69 DD 75 03     	LD (IX-12+CHP.SamPtr),L
 970++8E6C DD 74 04     	LD (IX-12+CHP.SamPtr+1),H
 971++8E6F C9           	RET
 972++8E70
 973++8E70              ;ALL 16 ADDRESSES TO PROTECT FROM BROKEN PT3 MODULES
 974++8E70 53 8E        SPCCOMS DW C_NOP
 975++8E72 AF 8D        	DW C_GLISS
 976++8E74 3B 8D        	DW C_PORTM
 977++8E76 CC 8D        	DW C_SMPOS
 978++8E78 D2 8D        	DW C_ORPOS
 979++8E7A D8 8D        	DW C_VIBRT
 980++8E7C 53 8E        	DW C_NOP
 981++8E7E 53 8E        	DW C_NOP
 982++8E80 F0 8D        	DW C_ENGLS
 983++8E82 05 8E        	DW C_DELAY
 984++8E84 53 8E        	DW C_NOP
 985++8E86 53 8E        	DW C_NOP
 986++8E88 53 8E        	DW C_NOP
 987++8E8A 53 8E        	DW C_NOP
 988++8E8C 53 8E        	DW C_NOP
 989++8E8E 53 8E        	DW C_NOP
 990++8E90
 991++8E90 CD B1 8B     CHREGS	CALL GETIX
 992++8E93 AF           	XOR A
 993++8E94 32 D0 90     	LD (Ampl),A
 994++8E97 DD CB 15 46  	BIT 0,(IX+CHP.Flags)
 995++8E9B E5           	PUSH HL
 996++8E9C CA E3 8F     	JP Z,CH_EXIT
 997++8E9F ED 73 2D 8F  	LD (CSP_+1),SP
 998++8EA3 DD 6E 0D     	LD L,(IX+CHP.OrnPtr)
 999++8EA6 DD 66 0E     	LD H,(IX+CHP.OrnPtr+1)
1000++8EA9 F9           	LD SP,HL
1001++8EAA D1           	POP DE
1002++8EAB 67           	LD H,A
1003++8EAC DD 7E 00     	LD A,(IX+CHP.PsInOr)
1004++8EAF 6F           	LD L,A
1005++8EB0 39           	ADD HL,SP
1006++8EB1 3C           	INC A
1007++8EB2              		;PT2	PT3
1008++8EB2 3C           OrnCP	INC A	;CP E	CP D
1009++8EB3 38 01        	JR C,CH_ORPS
1010++8EB5 01           OrnLD	DB 1	;LD A,D	LD A,E
1011++8EB6 DD 77 00     CH_ORPS	LD (IX+CHP.PsInOr),A
1012++8EB9 DD 7E 12     	LD A,(IX+CHP.Note)
1013++8EBC 86           	ADD A,(HL)
1014++8EBD F2 C1 8E     	JP P,CH_NTP
1015++8EC0 AF           	XOR A
1016++8EC1 FE 60        CH_NTP	CP 96
1017++8EC3 38 02        	JR C,CH_NOK
1018++8EC5 3E 5F        	LD A,95
1019++8EC7 87           CH_NOK	ADD A,A
1020++8EC8 08           	EX AF,AF'
1021++8EC9 DD 6E 0F     	LD L,(IX+CHP.SamPtr)
1022++8ECC DD 66 10     	LD H,(IX+CHP.SamPtr+1)
1023++8ECF F9           	LD SP,HL
1024++8ED0 D1           	POP DE
1025++8ED1 26 00        	LD H,0
1026++8ED3 DD 7E 01     	LD A,(IX+CHP.PsInSm)
1027++8ED6 47           	LD B,A
1028++8ED7 87           	ADD A,A
1029++8ED8 87           SamClc2	ADD A,A ;or ADD A,B for PT2
1030++8ED9 6F           	LD L,A
1031++8EDA 39           	ADD HL,SP
1032++8EDB F9           	LD SP,HL
1033++8EDC 78           	LD A,B
1034++8EDD 3C           	INC A
1035++8EDE              		;PT2	PT3
1036++8EDE 3C           SamCP	INC A	;CP E	CP D
1037++8EDF 38 01        	JR C,CH_SMPS
1038++8EE1 01           SamLD	DB 1	;LD A,D	LD A,E
1039++8EE2 DD 77 01     CH_SMPS	LD (IX+CHP.PsInSm),A
1040++8EE5 C1           	POP BC
1041++8EE6 E1           	POP HL
1042++8EE7
1043++8EE7              ;Convert PT2 sample to PT3
1044++8EE7              		;PT2		PT3
1045++8EE7 E1           SamCnv	POP HL  ;BIT 2,C	JR e_
1046++8EE8 E1           	POP HL
1047++8EE9 60           	LD H,B
1048++8EEA 20 06        	JR NZ,$+8
1049++8EEC EB           	EX DE,HL
1050++8EED A7           	AND A
1051++8EEE ED 62        	SBC HL,HL
1052++8EF0 ED 52        	SBC HL,DE
1053++8EF2 51           	LD D,C
1054++8EF3 CB 19        	RR C
1055++8EF5 9F           	SBC A,A
1056++8EF6 2F           	CPL
1057++8EF7 E6 3E        	AND #3E
1058++8EF9 CB 19        	RR C
1059++8EFB CB 18        	RR B
1060++8EFD A1           	AND C
1061++8EFE 4F           	LD C,A
1062++8EFF 78           	LD A,B
1063++8F00 1F           	RRA
1064++8F01 1F           	RRA
1065++8F02 CB 1A        	RR D
1066++8F04 1F           	RRA
1067++8F05 E6 9F        	AND #9F
1068++8F07 47           	LD B,A
1069++8F08
1070++8F08 DD 5E 08     e_	LD E,(IX+CHP.TnAcc)
1071++8F0B DD 56 09     	LD D,(IX+CHP.TnAcc+1)
1072++8F0E 19           	ADD HL,DE
1073++8F0F CB 70        	BIT 6,B
1074++8F11 28 06        	JR Z,CH_NOAC
1075++8F13 DD 75 08     	LD (IX+CHP.TnAcc),L
1076++8F16 DD 74 09     	LD (IX+CHP.TnAcc+1),H
1077++8F19 EB           CH_NOAC EX DE,HL
1078++8F1A 08           	EX AF,AF'
player.asm(1079): warning: value 0x9413 is truncated to 8bit value: 0x13
1079++8F1B C6 13        	ADD A,NT_
1080++8F1D 6F           	LD L,A
1081++8F1E CE 94        	ADC A,NT_/256
1082++8F20 95           	SUB L
1083++8F21 67           	LD H,A
1084++8F22 F9           	LD SP,HL
1085++8F23 E1           	POP HL
1086++8F24 19           	ADD HL,DE
1087++8F25 DD 5E 06     	LD E,(IX+CHP.CrTnSl)
1088++8F28 DD 56 07     	LD D,(IX+CHP.CrTnSl+1)
1089++8F2B 19           	ADD HL,DE
1090++8F2C 31 31 31     CSP_	LD SP,#3131
1091++8F2F E3           	EX (SP),HL
1092++8F30 AF           	XOR A
1093++8F31 DD B6 05     	OR (IX+CHP.TSlCnt)
1094++8F34 28 3E        	JR Z,CH_AMP
1095++8F36 DD 35 05     	DEC (IX+CHP.TSlCnt)
1096++8F39 20 39        	JR NZ,CH_AMP
1097++8F3B DD 7E 16     	LD A,(IX+CHP.TnSlDl)
1098++8F3E DD 77 05     	LD (IX+CHP.TSlCnt),A
1099++8F41 DD 6E 17     	LD L,(IX+CHP.TSlStp)
1100++8F44 DD 66 18     	LD H,(IX+CHP.TSlStp+1)
1101++8F47 7C           	LD A,H
1102++8F48 19           	ADD HL,DE
1103++8F49 DD 75 06     	LD (IX+CHP.CrTnSl),L
1104++8F4C DD 74 07     	LD (IX+CHP.CrTnSl+1),H
1105++8F4F DD CB 15 56  	BIT 2,(IX+CHP.Flags)
1106++8F53 20 1F        	JR NZ,CH_AMP
1107++8F55 DD 5E 19     	LD E,(IX+CHP.TnDelt)
1108++8F58 DD 56 1A     	LD D,(IX+CHP.TnDelt+1)
1109++8F5B A7           	AND A
1110++8F5C 28 01        	JR Z,CH_STPP
1111++8F5E EB           	EX DE,HL
1112++8F5F ED 52        CH_STPP SBC HL,DE
1113++8F61 FA 74 8F     	JP M,CH_AMP
1114++8F64 DD 7E 13     	LD A,(IX+CHP.SlToNt)
1115++8F67 DD 77 12     	LD (IX+CHP.Note),A
1116++8F6A AF           	XOR A
1117++8F6B DD 77 05     	LD (IX+CHP.TSlCnt),A
1118++8F6E DD 77 06     	LD (IX+CHP.CrTnSl),A
1119++8F71 DD 77 07     	LD (IX+CHP.CrTnSl+1),A
1120++8F74 DD 7E 02     CH_AMP	LD A,(IX+CHP.CrAmSl)
1121++8F77 CB 79        	BIT 7,C
1122++8F79 28 13        	JR Z,CH_NOAM
1123++8F7B CB 71        	BIT 6,C
1124++8F7D 28 07        	JR Z,CH_AMIN
1125++8F7F FE 0F        	CP 15
1126++8F81 28 0B        	JR Z,CH_NOAM
1127++8F83 3C           	INC A
1128++8F84 18 05        	JR CH_SVAM
1129++8F86 FE F1        CH_AMIN	CP -15
1130++8F88 28 04        	JR Z,CH_NOAM
1131++8F8A 3D           	DEC A
1132++8F8B DD 77 02     CH_SVAM	LD (IX+CHP.CrAmSl),A
1133++8F8E 6F           CH_NOAM	LD L,A
1134++8F8F 78           	LD A,B
1135++8F90 E6 0F        	AND 15
1136++8F92 85           	ADD A,L
1137++8F93 F2 97 8F     	JP P,CH_APOS
1138++8F96 AF           	XOR A
1139++8F97 FE 10        CH_APOS	CP 16
1140++8F99 38 02        	JR C,CH_VOL
1141++8F9B 3E 0F        	LD A,15
1142++8F9D DD B6 1C     CH_VOL	OR (IX+CHP.Volume)
player.asm(1143): warning: value 0x9313 is truncated to 8bit value: 0x13
1143++8FA0 C6 13        	ADD A,VT_
1144++8FA2 6F           	LD L,A
1145++8FA3 CE 93        	ADC A,VT_/256
1146++8FA5 95           	SUB L
1147++8FA6 67           	LD H,A
1148++8FA7 7E           	LD A,(HL)
1149++8FA8 CB 41        CH_ENV	BIT 0,C
1150++8FAA 20 03        	JR NZ,CH_NOEN
1151++8FAC DD B6 14     	OR (IX+CHP.Env_En)
1152++8FAF 32 D0 90     CH_NOEN	LD (Ampl),A
1153++8FB2 CB 78        	BIT 7,B
1154++8FB4 79           	LD A,C
1155++8FB5 28 1A        	JR Z,NO_ENSL
1156++8FB7 17           	RLA
1157++8FB8 17           	RLA
1158++8FB9 CB 2F        	SRA A
1159++8FBB CB 2F        	SRA A
1160++8FBD CB 2F        	SRA A
1161++8FBF DD 86 04     	ADD A,(IX+CHP.CrEnSl) ;SEE COMMENT BELOW
1162++8FC2 CB 68        	BIT 5,B
1163++8FC4 28 03        	JR Z,NO_ENAC
1164++8FC6 DD 77 04     	LD (IX+CHP.CrEnSl),A
1165++8FC9 FD 86 12     NO_ENAC	ADD A,(IY-100+VRS.AddToEn) ;BUG IN PT3 - NEED WORD HERE
1166++8FCC FD 77 12     	LD (IY-100+VRS.AddToEn),A
1167++8FCF 18 0E        	JR CH_MIX
1168++8FD1 1F           NO_ENSL RRA
1169++8FD2 DD 86 03     	ADD A,(IX+CHP.CrNsSl)
1170++8FD5 FD 77 11     	LD (IY-100+VRS.AddToNs),A
1171++8FD8 CB 68        	BIT 5,B
1172++8FDA 28 03        	JR Z,CH_MIX
1173++8FDC DD 77 03     	LD (IX+CHP.CrNsSl),A
1174++8FDF 78           CH_MIX	LD A,B
1175++8FE0 1F           	RRA
1176++8FE1 E6 48        	AND #48
1177++8FE3 FD B6 1C     CH_EXIT	OR (IY-100+VRS.AYREGS+Mixer)
1178++8FE6 0F           	RRCA
1179++8FE7 FD 77 1C     	LD (IY-100+VRS.AYREGS+Mixer),A
1180++8FEA E1           	POP HL
1181++8FEB AF           	XOR A
1182++8FEC DD B6 0A     	OR (IX+CHP.COnOff)
1183++8FEF C8           	RET Z
1184++8FF0 DD 35 0A     	DEC (IX+CHP.COnOff)
1185++8FF3 C0           	RET NZ
1186++8FF4 DD AE 15     	XOR (IX+CHP.Flags)
1187++8FF7 DD 77 15     	LD (IX+CHP.Flags),A
1188++8FFA 1F           	RRA
1189++8FFB DD 7E 0B     	LD A,(IX+CHP.OnOffD)
1190++8FFE 38 03        	JR C,CH_ONDL
1191++9000 DD 7E 0C     	LD A,(IX+CHP.OffOnD)
1192++9003 DD 77 0A     CH_ONDL	LD (IX+CHP.COnOff),A
1193++9006 C9           	RET
1194++9007
1195++9007 AF           PLAY_	XOR A
1196++9008 FD 77 12     	LD (IY-100+VRS.AddToEn),A
1197++900B FD 77 1C     	LD (IY-100+VRS.AYREGS+Mixer),A
1198++900E 3D           	DEC A
1199++900F FD 77 22     	LD (IY-100+VRS.AYREGS+EnvTp),A
1200++9012 FD 35 09     	DEC (IY-100+VRS.DelyCnt)
1201++9015 C2 BD 90     	JP NZ,PL2
1202++9018 FD 35 BA     	DEC (IY-100+VRS.ChanA+CHP.NtSkCn)
1203++901B 20 6C        	JR NZ,PL1B
1204++901D FD 4E FE     	LD C,(IY-100+VRS.AdInPtA)
1205++9020 FD 46 FF     	LD B,(IY-100+VRS.AdInPtA+1)
1206++9023 0A           	LD A,(BC)
1207++9024 A7           	AND A
1208++9025 20 56        	JR NZ,PL1A
1209++9027 57           	LD D,A
1210++9028 FD 77 10     	LD (IY-100+VRS.Ns_Base),A
1211++902B FD 6E 04     	LD L,(IY-100+VRS.CrPsPtr)
1212++902E FD 66 05     	LD H,(IY-100+VRS.CrPsPtr+1)
1213++9031 23           	INC HL
1214++9032 7E           	LD A,(HL)
1215++9033 3C           	INC A
1216++9034 20 0B        	JR NZ,PLNLP
1217++9036
1218++9036              	IF LoopChecker
1219++9036 CD E8 88     	CALL CHECKLP
1220++9039              	ENDIF
1221++9039
1222++9039 FD 6E 06     	LD L,(IY-100+VRS.LPosPtr)
1223++903C FD 66 07     	LD H,(IY-100+VRS.LPosPtr+1)
1224++903F 7E           	LD A,(HL)
1225++9040 3C           	INC A
1226++9041 CD 95 8B     PLNLP	CALL SETCPPT
1227++9044 3D           	DEC A
1228++9045 FD CB 9E 4E  	BIT 1,(IY-100+VRS.ModNum)
1229++9049 28 03        	JR Z,NoAlCo
1230++904B              TSSub	EQU $+1
1231++904B D6 D6        	SUB #D6
1232++904D 2F           	CPL
1233++904E              NoAlCo
1234++904E              		;PT2		PT3
1235++904E 3D           PsCalc	DEC A	;ADD A,A	NOP
1236++904F 3D           	DEC A	;ADD A,(HL)	NOP
1237++9050 87           	ADD A,A
1238++9051 5F           	LD E,A
1239++9052 CB 12        	RL D
1240++9054
1241++9054              	IF CurPosCounter
1242++9054 ~            	LD A,L
1243++9054 ~            	SUB (IY-100+VRS.PosSub)
1244++9054 ~            	LD (IY-100+VRS.CurPos),A
1245++9054              	ENDIF
1246++9054
1247++9054 FD 6E FC     	LD L,(IY-100+VRS.PatsPtr)
1248++9057 FD 66 FD     	LD H,(IY-100+VRS.PatsPtr+1)
1249++905A 19           	ADD HL,DE
1250++905B FD 5E F6     	LD E,(IY-100+VRS.MODADDR)
1251++905E FD 56 F7     	LD D,(IY-100+VRS.MODADDR+1)
1252++9061 ED 73 7B 90  	LD (PSP_+1),SP
1253++9065 F9           	LD SP,HL
1254++9066 E1           	POP HL
1255++9067 19           	ADD HL,DE
1256++9068 44           	LD B,H
1257++9069 4D           	LD C,L
1258++906A E1           	POP HL
1259++906B 19           	ADD HL,DE
1260++906C FD 75 00     	LD (IY-100+VRS.AdInPtB),L
1261++906F FD 74 01     	LD (IY-100+VRS.AdInPtB+1),H
1262++9072 E1           	POP HL
1263++9073 19           	ADD HL,DE
1264++9074 FD 75 02     	LD (IY-100+VRS.AdInPtC),L
1265++9077 FD 74 03     	LD (IY-100+VRS.AdInPtC+1),H
1266++907A 31 31 31     PSP_	LD SP,#3131
1267++907D 11 AB FF     PL1A	LD DE,VRS.ChanA+12-100
1268++9080 CD B8 8B     	CALL PTDECOD
1269++9083 FD 71 FE     	LD (IY-100+VRS.AdInPtA),C
1270++9086 FD 70 FF     	LD (IY-100+VRS.AdInPtA+1),B
1271++9089
1272++9089 FD 35 D7     PL1B	DEC (IY-100+VRS.ChanB+CHP.NtSkCn)
1273++908C 20 12        	JR NZ,PL1C
1274++908E 11 C8 FF     	LD DE,VRS.ChanB+12-100
1275++9091 FD 4E 00     	LD C,(IY-100+VRS.AdInPtB)
1276++9094 FD 46 01     	LD B,(IY-100+VRS.AdInPtB+1)
1277++9097 CD B8 8B     	CALL PTDECOD
1278++909A FD 71 00     	LD (IY-100+VRS.AdInPtB),C
1279++909D FD 70 01     	LD (IY-100+VRS.AdInPtB+1),B
1280++90A0
1281++90A0 FD 35 F4     PL1C	DEC (IY-100+VRS.ChanC+CHP.NtSkCn)
1282++90A3 20 12        	JR NZ,PL1D
1283++90A5 11 E5 FF     	LD DE,VRS.ChanC+12-100
1284++90A8 FD 4E 02     	LD C,(IY-100+VRS.AdInPtC)
1285++90AB FD 46 03     	LD B,(IY-100+VRS.AdInPtC+1)
1286++90AE CD B8 8B     	CALL PTDECOD
1287++90B1 FD 71 02     	LD (IY-100+VRS.AdInPtC),C
1288++90B4 FD 70 03     	LD (IY-100+VRS.AdInPtC+1),B
1289++90B7
1290++90B7 FD 7E 08     PL1D	LD A,(IY-100+VRS.Delay)
1291++90BA FD 77 09     	LD (IY-100+VRS.DelyCnt),A
1292++90BD
1293++90BD 11 9F FF     PL2	LD DE,VRS.ChanA-100
1294++90C0 FD 6E 15     	LD L,(IY-100+VRS.AYREGS+TonA)
1295++90C3 FD 66 16     	LD H,(IY-100+VRS.AYREGS+TonA+1)
1296++90C6 CD 90 8E     	CALL CHREGS
1297++90C9 FD 75 15     	LD (IY-100+VRS.AYREGS+TonA),L
1298++90CC FD 74 16     	LD (IY-100+VRS.AYREGS+TonA+1),H
1299++90CF              Ampl	EQU $+1
1300++90CF 3E 3E        	LD A,#3E
1301++90D1 FD 77 1D     	LD (IY-100+VRS.AYREGS+AmplA),A
1302++90D4 11 BC FF     	LD DE,VRS.ChanB-100
1303++90D7 FD 6E 17     	LD L,(IY-100+VRS.AYREGS+TonB)
1304++90DA FD 66 18     	LD H,(IY-100+VRS.AYREGS+TonB+1)
1305++90DD CD 90 8E     	CALL CHREGS
1306++90E0 FD 75 17     	LD (IY-100+VRS.AYREGS+TonB),L
1307++90E3 FD 74 18     	LD (IY-100+VRS.AYREGS+TonB+1),H
1308++90E6 3A D0 90     	LD A,(Ampl)
1309++90E9 FD 77 1E     	LD (IY-100+VRS.AYREGS+AmplB),A
1310++90EC 11 D9 FF     	LD DE,VRS.ChanC-100
1311++90EF FD 6E 19     	LD L,(IY-100+VRS.AYREGS+TonC)
1312++90F2 FD 66 1A     	LD H,(IY-100+VRS.AYREGS+TonC+1)
1313++90F5 CD 90 8E     	CALL CHREGS
1314++90F8 FD 75 19     	LD (IY-100+VRS.AYREGS+TonC),L
1315++90FB FD 74 1A     	LD (IY-100+VRS.AYREGS+TonC+1),H
1316++90FE 3A D0 90     	LD A,(Ampl)
1317++9101 FD 77 1F     	LD (IY-100+VRS.AYREGS+AmplC),A
1318++9104
1319++9104 FD 7E 10     	LD A,(IY-100+VRS.Ns_Base)
1320++9107 FD 86 11     	ADD (IY-100+VRS.AddToNs)
1321++910A FD 77 1B     	LD (IY-100+VRS.AYREGS+Noise),A
1322++910D
1323++910D FD 7E 12     	LD A,(IY-100+VRS.AddToEn)
1324++9110 5F           	LD E,A
1325++9111 87           	ADD A,A
1326++9112 9F           	SBC A,A
1327++9113 57           	LD D,A
1328++9114 FD 6E 13     	LD L,(IY-100+VRS.EnvBase)
1329++9117 FD 66 14     	LD H,(IY-100+VRS.EnvBase+1)
1330++911A 19           	ADD HL,DE
1331++911B FD 5E 0C     	LD E,(IY-100+VRS.CurESld)
1332++911E FD 56 0D     	LD D,(IY-100+VRS.CurESld+1)
1333++9121 19           	ADD HL,DE
1334++9122 FD 75 20     	LD (IY-100+VRS.AYREGS+Env),L
1335++9125 FD 74 21     	LD (IY-100+VRS.AYREGS+Env+1),H
1336++9128
1337++9128 AF           	XOR A
1338++9129 FD B6 0F     	OR (IY-100+VRS.CurEDel)
1339++912C C8           	RET Z
1340++912D FD 35 0F     	DEC (IY-100+VRS.CurEDel)
1341++9130 C0           	RET NZ
1342++9131 FD 7E 0E     	LD A,(IY-100+VRS.Env_Del)
1343++9134 FD 77 0F     	LD (IY-100+VRS.CurEDel),A
1344++9137 FD 6E 0A     	LD L,(IY-100+VRS.ESldAdd)
1345++913A FD 66 0B     	LD H,(IY-100+VRS.ESldAdd+1)
1346++913D 19           	ADD HL,DE
1347++913E C3 AA 8B     	JP SETESLD
1348++9141
1349++9141 FD 21 79 92  PLAY    LD IY,VARS1+100
1350++9145 CD 07 90     	CALL PLAY_
1351++9148 3A 14 92     	LD A,(is_ts)
1352++914B A7           	AND A
1353++914C 28 07        	JR Z,PL_nts
1354++914E FD 21 00 93  	LD IY,VARS2+100
1355++9152 CD 07 90     	CALL PLAY_
1356++9155              PL_nts
1357++9155              	IF Basic
1358++9155 FD 21 3A 5C  	LD IY,#5C3A
1359++9159              	ENDIF
1360++9159
1361++9159 01 FD FF     ROUT	LD BC,#FFFD
1362++915C 3A 14 92     	LD A,(is_ts)
1363++915F A7           	AND A
1364++9160 28 02        	JR Z,r_nts ;keep old standard
1365++9162 ED 41        	OUT (C),B
1366++9164 08           r_nts	EX AF,AF'
1367++9165
1368++9165              	IF ACBBAC
1369++9165 ~            	LD IX,VARS1+VRS.AYREGS
1370++9165              	ELSE
1371++9165 21 8E 92     	LD HL,VARS1+VRS.AYREGS
1372++9168              	ENDIF
1373++9168
1374++9168 CD 74 91     	CALL ROUT_
1375++916B 08           	EX AF,AF'
1376++916C C8           	RET Z
1377++916D 42           	LD B,D
1378++916E 2F           	CPL
1379++916F ED 79        	OUT (C),A
1380++9171
1381++9171              	IF ACBBAC
1382++9171 ~            	LD IX,VARS2+VRS.AYREGS
1383++9171              	ELSE
1384++9171 21 15 93     	LD HL,VARS2+VRS.AYREGS
1385++9174              	ENDIF
1386++9174
1387++9174              ROUT_
1388++9174              	IF ACBBAC
1389++9174 ~            	LD A,(SETUP)
1390++9174 ~            	AND 12
1391++9174 ~            	JR Z,ABC
1392++9174 ~            	ADD A,CHTABLE
1393++9174 ~            	LD E,A
1394++9174 ~            	ADC A,CHTABLE/256
1395++9174 ~            	SUB E
1396++9174 ~            	LD D,A
1397++9174 ~            	LD B,0
1398++9174 ~            	PUSH IX
1399++9174 ~            	POP HL
1400++9174 ~            	LD A,(DE)
1401++9174 ~            	INC DE
1402++9174 ~            	LD C,A
1403++9174 ~            	ADD HL,BC
1404++9174 ~            	LD A,(IX+TonB)
1405++9174 ~            	LD C,(HL)
1406++9174 ~            	LD (IX+TonB),C
1407++9174 ~            	LD (HL),A
1408++9174 ~            	INC HL
1409++9174 ~            	LD A,(IX+TonB+1)
1410++9174 ~            	LD C,(HL)
1411++9174 ~            	LD (IX+TonB+1),C
1412++9174 ~            	LD (HL),A
1413++9174 ~            	LD A,(DE)
1414++9174 ~            	INC DE
1415++9174 ~            	LD C,A
1416++9174 ~            	ADD HL,BC
1417++9174 ~            	LD A,(IX+AmplB)
1418++9174 ~            	LD C,(HL)
1419++9174 ~            	LD (IX+AmplB),C
1420++9174 ~            	LD (HL),A
1421++9174 ~            	LD A,(DE)
1422++9174 ~            	INC DE
1423++9174 ~            	LD (RxCA1),A
1424++9174 ~            	XOR 8
1425++9174 ~            	LD (RxCA2),A
1426++9174 ~            	LD A,(DE)
1427++9174 ~            	AND (IX+Mixer)
1428++9174 ~            	LD E,A
1429++9174 ~            	LD A,(IX+Mixer)
1430++9174 ~            RxCA1	DB #E6
1431++9174 ~            	AND %010010
1432++9174 ~            	OR E
1433++9174 ~            	LD E,A
1434++9174 ~            	LD A,(IX+Mixer)
1435++9174 ~            	AND %010010
1436++9174 ~            RxCA2	OR E
1437++9174 ~            	OR E
1438++9174 ~            	LD (IX+Mixer),A
1439++9174 ~            ABC
1440++9174              	ENDIF
1441++9174
1442++9174 AF           	XOR A
1443++9175 11 BF FF     	LD DE,#FFBF
1444++9178
1445++9178              	IF ACBBAC
1446++9178 ~            	LD BC,#FFFD
1447++9178 ~            	PUSH IX
1448++9178 ~            	POP HL
1449++9178              	ENDIF
1450++9178
1451++9178 ED 79        LOUT	OUT (C),A
1452++917A 43           	LD B,E
1453++917B ED A3        	OUTI
1454++917D 42           	LD B,D
1455++917E 3C           	INC A
1456++917F FE 0D        	CP 13
1457++9181 20 F5        	JR NZ,LOUT
1458++9183 ED 79        	OUT (C),A
1459++9185 7E           	LD A,(HL)
1460++9186 A7           	AND A
1461++9187 F8           	RET M
1462++9188 43           	LD B,E
1463++9189 ED 79        	OUT (C),A
1464++918B C9           	RET
1465++918C
1466++918C              	IF ACBBAC
1467++918C ~            CHTABLE	EQU $-4
1468++918C ~            	DB 4,5,15,%001001,0,7,7,%100100
1469++918C              	ENDIF
1470++918C
1471++918C 64           NT_DATA	DB (T_NEW_0-T1_)*2
1472++918D 2A           	DB TCNEW_0-T_
1473++918E 65           	DB (T_OLD_0-T1_)*2+1
1474++918F 00           	DB TCOLD_0-T_
1475++9190 01           	DB (T_NEW_1-T1_)*2+1
1476++9191 0C           	DB TCNEW_1-T_
1477++9192 01           	DB (T_OLD_1-T1_)*2+1
1478++9193 0C           	DB TCOLD_1-T_
1479++9194 94           	DB (T_NEW_2-T1_)*2
1480++9195 35           	DB TCNEW_2-T_
1481++9196 30           	DB (T_OLD_2-T1_)*2
1482++9197 0E           	DB TCOLD_2-T_
1483++9198 60           	DB (T_NEW_3-T1_)*2
1484++9199 20           	DB TCNEW_3-T_
1485++919A 60           	DB (T_OLD_3-T1_)*2
1486++919B 21           	DB TCOLD_3-T_
1487++919C
1488++919C              T_
1489++919C
1490++919C 01 05 09 0B  TCOLD_0	DB #00+1,#04+1,#08+1,#0A+1,#0C+1,#0E+1,#12+1,#14+1
1490++91A0 0D 0F 13 15
1491++91A4 19 25 3D 00  	DB #18+1,#24+1,#3C+1,0
1492++91A8 5D 00        TCOLD_1	DB #5C+1,0
1493++91AA 31 37 4D 53  TCOLD_2	DB #30+1,#36+1,#4C+1,#52+1,#5E+1,#70+1,#82,#8C,#9C
1493++91AE 5F 71 82 8C
1493++91B2 9C
1494++91B3 9E A0 A6 A8  	DB #9E,#A0,#A6,#A8,#AA,#AC,#AE,#AE,0
1494++91B7 AA AC AE AE
1494++91BB 00
1495++91BC 57           TCNEW_3	DB #56+1
1496++91BD 1F 23 25 29  TCOLD_3	DB #1E+1,#22+1,#24+1,#28+1,#2C+1,#2E+1,#32+1,#BE+1,0
1496++91C1 2D 2F 33 BF
1496++91C5 00
1497++91C6 1D 21 23 27  TCNEW_0	DB #1C+1,#20+1,#22+1,#26+1,#2A+1,#2C+1,#30+1,#54+1
1497++91CA 2B 2D 31 55
1498++91CE BD BF 00     	DB #BC+1,#BE+1,0
1499++91D1              TCNEW_1 EQU TCOLD_1
1500++91D1 1B 21 25 29  TCNEW_2	DB #1A+1,#20+1,#24+1,#28+1,#2A+1,#3A+1,#4C+1,#5E+1
1500++91D5 2B 3B 4D 5F
1501++91D9 BB BD BF 00  	DB #BA+1,#BC+1,#BE+1,0
1502++91DD
1503++91DD              PT3EMPTYORN EQU $-1
1504++91DD 01 00        	DB 1,0
1505++91DF
1506++91DF              ;first 12 values of tone tables (packed)
1507++91DF
player.asm(1508): warning: value 0xDD8 is truncated to 8bit value: 0xD8
1508++91DF 0D D8        T_PACK	DB #06EC*2/256,#06EC*2
1509++91E1 69           	DB #0755-#06EC
1510++91E2 70           	DB #07C5-#0755
1511++91E3 76           	DB #083B-#07C5
1512++91E4 7D           	DB #08B8-#083B
1513++91E5 85           	DB #093D-#08B8
1514++91E6 8D           	DB #09CA-#093D
1515++91E7 95           	DB #0A5F-#09CA
1516++91E8 9D           	DB #0AFC-#0A5F
1517++91E9 A8           	DB #0BA4-#0AFC
1518++91EA B1           	DB #0C55-#0BA4
1519++91EB BB           	DB #0D10-#0C55
player.asm(1520): warning: value 0xCDA is truncated to 8bit value: 0xDA
1520++91EC 0C DA        	DB #066D*2/256,#066D*2
1521++91EE 62           	DB #06CF-#066D
1522++91EF 68           	DB #0737-#06CF
1523++91F0 6D           	DB #07A4-#0737
1524++91F1 75           	DB #0819-#07A4
1525++91F2 7B           	DB #0894-#0819
1526++91F3 83           	DB #0917-#0894
1527++91F4 8A           	DB #09A1-#0917
1528++91F5 92           	DB #0A33-#09A1
1529++91F6 9C           	DB #0ACF-#0A33
1530++91F7 A4           	DB #0B73-#0ACF
1531++91F8 AF           	DB #0C22-#0B73
1532++91F9 B8           	DB #0CDA-#0C22
player.asm(1533): warning: value 0xE08 is truncated to 8bit value: 0x08
1533++91FA 0E 08        	DB #0704*2/256,#0704*2
1534++91FC 6A           	DB #076E-#0704
1535++91FD 72           	DB #07E0-#076E
1536++91FE 78           	DB #0858-#07E0
1537++91FF 7E           	DB #08D6-#0858
1538++9200 86           	DB #095C-#08D6
1539++9201 90           	DB #09EC-#095C
1540++9202 96           	DB #0A82-#09EC
1541++9203 A0           	DB #0B22-#0A82
1542++9204 AA           	DB #0BCC-#0B22
1543++9205 B4           	DB #0C80-#0BCC
1544++9206 BE           	DB #0D3E-#0C80
player.asm(1545): warning: value 0xFC0 is truncated to 8bit value: 0xC0
1545++9207 0F C0        	DB #07E0*2/256,#07E0*2
1546++9209 78           	DB #0858-#07E0
1547++920A 88           	DB #08E0-#0858
1548++920B 80           	DB #0960-#08E0
1549++920C 90           	DB #09F0-#0960
1550++920D 98           	DB #0A88-#09F0
1551++920E A0           	DB #0B28-#0A88
1552++920F B0           	DB #0BD8-#0B28
1553++9210 A8           	DB #0C80-#0BD8
1554++9211 E0           	DB #0D60-#0C80
1555++9212 B0           	DB #0E10-#0D60
1556++9213 E8           	DB #0EF8-#0E10
1557++9214
1558++9214              ;vars from here can be stripped
1559++9214              ;you can move VARS to any other address
1560++9214
1561++9214              VARS
1562++9214
1563++9214 00           is_ts	DB 0
1564++9215
1565++9215              ;ChannelsVars
1566++9215              	STRUCT	CHP
1567++9215 ~            ;reset group
1568++9215 ~            PsInOr	DB 0
1569++9215 ~            PsInSm	DB 0
1570++9215 ~            CrAmSl	DB 0
1571++9215 ~            CrNsSl	DB 0
1572++9215 ~            CrEnSl	DB 0
1573++9215 ~            TSlCnt	DB 0
1574++9215 ~            CrTnSl	DW 0
1575++9215 ~            TnAcc	DW 0
1576++9215 ~            COnOff	DB 0
1577++9215 ~            ;reset group
1578++9215 ~
1579++9215 ~            OnOffD	DB 0
1580++9215 ~
1581++9215 ~            ;IX for PTDECOD here (+12)
1582++9215 ~            OffOnD	DB 0
1583++9215 ~            OrnPtr	DW 0
1584++9215 ~            SamPtr	DW 0
1585++9215 ~            NNtSkp	DB 0
1586++9215 ~            Note	DB 0
1587++9215 ~            SlToNt	DB 0
1588++9215 ~            Env_En	DB 0
1589++9215 ~            Flags	DB 0
1590++9215 ~             ;Enabled - 0, SimpleGliss - 2
1591++9215 ~            TnSlDl	DB 0
1592++9215 ~            TSlStp	DW 0
1593++9215 ~            TnDelt	DW 0
1594++9215 ~            NtSkCn	DB 0
1595++9215 ~            Volume	DB 0
1596++9215              	ENDS
1597++9215
1598++9215              	STRUCT	VRS
1599++9215 ~
1600++9215 ~            ;IF not works in STRUCT in SjASM :(
1601++9215 ~            ;	IF CurPosCounter
1602++9215 ~            CurPos	DB 0
1603++9215 ~            PosSub	DB 0
1604++9215 ~            ;	ENDIF
1605++9215 ~
1606++9215 ~            ModNum	DB 0 ;bit0: ChipNum
1607++9215 ~            	     ;bit1: 1-reversed patterns order (AlCo TS)
1608++9215 ~
1609++9215 ~            ChanA	DS CHP
1610++9215 ~            ChanB	DS CHP
1611++9215 ~            ChanC	DS CHP
1612++9215 ~
1613++9215 ~            ;GlobalVars
1614++9215 ~            MODADDR	DW 0
1615++9215 ~            OrnPtrs	DW 0
1616++9215 ~            SamPtrs	DW 0
1617++9215 ~            PatsPtr	DW 0
1618++9215 ~            AdInPtA	DW 0
1619++9215 ~            AdInPtB	DW 0
1620++9215 ~            AdInPtC	DW 0
1621++9215 ~            CrPsPtr	DW 0
1622++9215 ~            LPosPtr	DW 0
1623++9215 ~            Delay	DB 0
1624++9215 ~            DelyCnt	DB 0
1625++9215 ~            ESldAdd	DW 0
1626++9215 ~            CurESld	DW 0
1627++9215 ~            Env_Del	DB 0
1628++9215 ~            CurEDel	DB 0
1629++9215 ~            Ns_Base	DB 0
1630++9215 ~            AddToNs	DB 0
1631++9215 ~            AddToEn	DB 0
1632++9215 ~            EnvBase	DW 0
1633++9215 ~            AYREGS	DS 14
1634++9215              	ENDS
1635++9215
1636++9215 00 00 00...  VARS1	DS VRS
1637++929C 00 00 00...  VARS2	DS VRS
1638++9323
1639++9323              VT_	EQU $-16
1640++9323 00 00 00...  	DS 256-16 ;CreatedVolumeTableAddress
1641++9413
1642++9413              T1_	EQU VT_+16 ;Tone tables data depacked here
1643++9413
1644++9413              T_OLD_1	EQU T1_
1645++9413              T_OLD_2	EQU T_OLD_1+24
1646++9413              T_OLD_3	EQU T_OLD_2+24
1647++9413              T_OLD_0	EQU T_OLD_3+2
1648++9413              T_NEW_0	EQU T_OLD_0
1649++9413              T_NEW_1	EQU T_OLD_1
1650++9413              T_NEW_2	EQU T_NEW_0+24
1651++9413              T_NEW_3	EQU T_OLD_3
1652++9413
1653++9413              PT2EMPTYORN EQU VT_+31 ;1,0,0 sequence
1654++9413
1655++9413 00 00 00...  NT_	DS 192 ;CreatedNoteTableAddress
1656++94D3
1657++94D3              VAR0END	EQU VT_+16 ;INIT zeroes from VARS to VAR0END-1
1658++94D3
1659++94D3              VARSEND EQU $
1660++94D3
1661++94D3              MDLADDR EQU outputBuffer
1662++94D3
1663++94D3              ;Release 0 steps:
1664++94D3              ;04/21/2007
1665++94D3              ;Works start (PTxPlay adaptation); first beta.
1666++94D3              ;04/22/2007
1667++94D3              ;Job finished; beta-testing.
1668++94D3              ;04/23/2007
1669++94D3              ;PT v3.7 TS mode corrected (after AlCo remarks).
1670++94D3              ;04/29/2007
1671++94D3              ;Added 1.XX and 2.XX special commands interpretation for PT3
1672++94D3              ;modules of v3.7+.
1673++94D3
1674++94D3              ;Size (minimal build for ZX Spectrum):
1675++94D3              ;Code block #908 bytes
1676++94D3              ;Variables #2BF bytes (can be stripped)
1677++94D3              ;Total size #908+#2BF=#BC7 (3015) bytes
1678++94D3              	ENDMODULE
# file closed: player/player.asm
  73+ 94D3                  ENDIF
# file closed: player/vortex-processor.asm
  40  94D3                  include "player/mod-processor.asm"
# file opened: player/mod-processor.asm
   1+ 94D3                  MODULE ModProcessor
   2+ 94D3                  ifdef GS
   3+ 94D3 ~
   4+ 94D3 ~                macro GS_WaitCommand2
   5+ 94D3 ~            .wait
   6+ 94D3 ~                in a, (CMD)
   7+ 94D3 ~                rrca
   8+ 94D3 ~                jr c, .wait
   9+ 94D3 ~                endm
  10+ 94D3 ~
  11+ 94D3 ~                macro GS_SendCommand2 nn
  12+ 94D3 ~                ld a, nn
  12+ 94D3 ~              out (CMD), a
  13+ 94D3 ~                endm
  14+ 94D3 ~
  15+ 94D3 ~            play:
  16+ 94D3 ~                call Console.waitForKeyUp
  17+ 94D3 ~
  18+ 94D3 ~                ld hl, Gopher.requestbuffer
  18+ 94D3 ~              call DialogBox.msgNoWait
  19+ 94D3 ~
  20+ 94D3 ~                ;ld a, 1, (Render.play_next), a
  21+ 94D3 ~            	xor a
  22+ 94D3 ~            	ld (last_song_position),a
  23+ 94D3 ~
  24+ 94D3 ~                ld h, #00, a, 32
  25+ 94D3 ~                call TextMode.fillLine
  26+ 94D3 ~                ld de, #0001
  26+ 94D3 ~              call TextMode.gotoXY
  27+ 94D3 ~                ld hl, message
  27+ 94D3 ~              call TextMode.printZ
  28+ 94D3 ~                ld a, #00
  29+ 94D3 ~                call TextMode.highlightLine
  30+ 94D3 ~
  31+ 94D3 ~            .loop
  32+ 94D3 ~                halt
  33+ 94D3 ~                xor a
  34+ 94D3 ~                call Console.peekC
  35+ 94D3 ~                cp Console.BACKSPACE
  36+ 94D3 ~                jp z, .stopKey
  37+ 94D3 ~            	cp SPACE
  38+ 94D3 ~                jp z, .playNext
  39+ 94D3 ~
  40+ 94D3 ~               ;проверка что MOD начал играть сначала
  41+ 94D3 ~                GS_SendCommand2 CMD_GET_SONG_POSITION
  42+ 94D3 ~                GS_WaitCommand2
  43+ 94D3 ~            	ld a,(last_song_position) ;предыдущая позиция
  44+ 94D3 ~            	ld c,a
  45+ 94D3 ~            	in a,(DATA) ;текущая позиция
  46+ 94D3 ~            	ld (last_song_position),a
  47+ 94D3 ~            	cp c
  48+ 94D3 ~            	jr nc, .loop ;если не меньше, продолжаем играть
  49+ 94D3 ~            .playNext
  50+ 94D3 ~                ld a, 1, (Render.play_next), a ;флаг что надо будет играть следующий файл
  51+ 94D3 ~            .stop
  52+ 94D3 ~                call GeneralSound.stopModule
  53+ 94D3 ~
  54+ 94D3 ~                call Console.waitForKeyUp
  55+ 94D3 ~                ret
  56+ 94D3 ~            .stopKey
  57+ 94D3 ~                xor a
  57+ 94D3 ~              ld (Render.play_next), a ;флаг что не надо играть следующий файл
  58+ 94D3 ~                jr .stop
  59+ 94D3 ~
  60+ 94D3 ~
  61+ 94D3 ~            message db "Playing MODs [SPACE] for next song [BACKSPACE] for stop playing", 0
  62+ 94D3 ~
  63+ 94D3 ~
  64+ 94D3 ~            CMD_GET_SONG_POSITION     = #60
  65+ 94D3 ~            last_song_position db 0
  66+ 94D3 ~
  67+ 94D3 ~            ;; Control ports
  68+ 94D3 ~            CMD  = 187
  69+ 94D3 ~            DATA = 179
  70+ 94D3                  endif
  71+ 94D3                  ENDMODULE
  72+ 94D3
# file closed: player/mod-processor.asm
  41  94D3                  include "screen/screen.asm"
# file opened: screen/screen.asm
   1+ 94D3                  module ScreenViewer
   2+ 94D3              display:
   3+ 94D3 CD 19 68         call Console.waitForKeyUp
   4+ 94D6 3E 07            ld a, 7
   4+ 94D8 CD 82 88       call Memory.setPage
   5+ 94DB 21 F8 94 11      ld hl, outputBuffer, de, #c000, bc, 6912
   5+ 94DF 00 C0 01 00
   5+ 94E3 1B
   5+ 94E4 ED B0          ldir
   6+ 94E6 CD BE 61         call TextMode.disable
   7+ 94E9              .wait
   8+ 94E9 76           	halt
   9+ 94EA AF               xor a
   9+ 94EB DB FE          in a, (#fe)
   9+ 94ED 2F             cpl
   9+ 94EE E6 1F          and 31
   9+ 94F0 28 F7          jr z, .wait
  10+ 94F2 CD 19 60         call TextMode.cls
  11+ 94F5 C3 00 70         jp History.back
  12+ 94F8
  13+ 94F8                  endmodule
# file closed: screen/screen.asm
  42  94F8              	ELSE
  43  94F8 ~                include "screen/nedoscreen.asm"
  44  94F8 ~                include "player/vortexnedoos.asm"
  45  94F8 ~                include "player/mod-processor.asm"
  46  94F8                  ENDIF
  47  94F8              start:
  48  94F8              	IFNDEF NEDOOS
  49  94F8              outputBuffer:
  50  94F8 F3               di
  51  94F9 AF               xor a
  51  94FA 32 6A 5C       ld (#5c6a), a  ; Thank you, Mario Prato, for feedback
  52  94FD 32 00 5C         ld (#5c00),a
  53  9500 31 00 60         ld sp, asmOrg
  54  9503 CD 78 88         call Memory.init
  55  9506 AF               xor a
  55  9507 D3 FE          out (#fe),a
  56  9509 FB               ei
  57  950A
  58  950A 3E 07            ld a, 7
  58  950C CD 82 88       call Memory.setPage
  59  950F                  ;; Logo
  60  950F 21 4A 95 06      ld hl, logo, b, Dos.FMODE_READ
  60  9513 01
  60  9514 CD C0 69       call Dos.fopen
  61  9517 F5               push af
  62  9518 21 00 C0 01      ld hl, #c000, bc, 6912
  62  951C 00 1B
  62  951E CD AD 6A       call Dos.fread
  63  9521 F1               pop af
  64  9522 CD 99 6A         call Dos.fclose
  65  9525
  66  9525 06 32            ld b, 50
  67  9527 76           1   halt
  68  9528 10 FD            djnz 1b
  69  952A                  ;; End of logo :-)
  70  952A
  71  952A                  ELSE
  72  952A ~                    ld sp, 0x4000
  73  952A ~                    ld c,nos.CMD_SETSYSDRV
  74  952A ~                 	ex af,af'
  75  952A ~            	    call nos.BDOS
  76  952A                  ENDIF
  77  952A
  78  952A CD 03 60         call TextMode.init
  79  952D 21 39 95     	ld hl, initing
  79  9530 CD 83 60       call TextMode.printZ
  80  9533 CD 3E 85       	call Wifi.init
  81  9536
  82  9536 C3 6D 70        jp History.home
  83  9539
  84  9539                  IFDEF NEDOOS
  85  9539 ~            outputBuffer:
  86  9539              	ENDIF
  87  9539
  88  9539 49 6E 69 74  initing db "Initing Wifi...", "\r", 0
  88  953D 69 6E 67 20
  88  9541 57 69 66 69
  88  9545 2E 2E 2E 0D
  88  9549 00
  89  954A 62 72 6F 77  logo    db "browser/logo.scr", 0
  89  954E 73 65 72 2F
  89  9552 6C 6F 67 6F
  89  9556 2E 73 63 72
  89  955A 00
  90  955B 62 72 6F 77  creds   db "browser/auth.pwd", 0
  90  955F 73 65 72 2F
  90  9563 61 75 74 68
  90  9567 2E 70 77 64
  90  956B 00
  91  956C
  92  956C                  display "ENDS: ", $
  93  956C                  display "Buff size", #ffff - $
  94  956C                  IFDEF NEDOOS
  95  956C ~                    savebin "moon.com", asmOrg, $ - asmOrg
  96  956C                  ELSE
  97  956C              		IFDEF TRDOS
  98  956C              			SAVETRD "MOONR.TRD",|"moon.C",asmOrg, $ - asmOrg
  99  956C              		ELSE
 100  956C ~            			savebin "moon.bin", asmOrg, $ - asmOrg
 101  956C              	    	ENDIF
 102  956C                  ENDIF
 103  956C              outputBuffer2:
 104  956C 41 54 45 30      db  "ATE0", 0
 104  9570 00
 105  9571
 106  9571                  ELSE
 107  9571 ~            ;****************************** MSX ***********************************************
 108  9571 ~                output "moonr.com"
 109  9571 ~                org 100h
 110  9571 ~                jp start
 111  9571 ~                include "vdp/vdpdriver.asm"
 112  9571 ~                include "utils/index.asm"
 113  9571 ~                include "gopher/render/index.asm"
 114  9571 ~                include "dos/msxdos.asm"
 115  9571 ~                include "gopher/engine/history/index.asm"
 116  9571 ~                include "gopher/engine/urlencoder.asm"
 117  9571 ~                include "gopher/engine/fetcher.asm"
 118  9571 ~                include "gopher/engine/media-processor.asm"
 119  9571 ~                include "drivers/unapi/unapi.asm"
 120  9571 ~                include "drivers/unapi/tcp.asm"
 121  9571 ~                include "gopher/msxgopher.asm"
 122  9571 ~                include "screen/msxscreen.asm"
 123  9571 ~                include "player/vortex-processor.asm"
 124  9571 ~                include "player/mod-processor.asm"
 125  9571 ~            fontName db "font.bin",0
 126  9571 ~            start:
 127  9571 ~                ld hl,(0x0006)
 128  9571 ~                ld bc,outputBuffer
 129  9571 ~                sbc hl,bc
 130  9571 ~                ld bc, 0x100
 131  9571 ~                sbc hl,bc
 132  9571 ~                ld (ramtop),hl
 133  9571 ~
 134  9571 ~                call TcpIP.init
 134  9571 ~              jp nc, noTcpIP ; No TCP/IP - no browser! Anyway you can use "useless tcp/ip driver"
 135  9571 ~                ; Loading font
 136  9571 ~                ;ld de, fontName, a, FMODE_NO_WRITE : call Dos.fopen
 137  9571 ~                ;push bc
 138  9571 ~                ;ld de, font, hl, 2048 :call Dos.fread
 139  9571 ~                ;pop bc
 140  9571 ~                ;call Dos.fclose
 141  9571 ~                call TextMode.loadFont
 142  9571 ~                call TextMode.init
 143  9571 ~                call History.home
 144  9571 ~                jp exit
 145  9571 ~            noTcpIP:
 146  9571 ~                ld hl, .err
 147  9571 ~                call Console.putStringZ
 148  9571 ~                rst 0
 149  9571 ~            .err db 13,10,"No TCP/IP implementation found!",13,10,0
 150  9571 ~            ramtop:
 151  9571 ~                db 0x00, 0xD0
 152  9571 ~            outputBuffer:
 153  9571 ~            font:
 154  9571 ~                display "ENDS: ", $
 155  9571                  ENDIF
# file closed: main.asm
