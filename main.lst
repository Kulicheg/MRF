# file opened: main.asm
   1  0000                  DEFINE TCP_BUF_SIZE 1024
   2  0000              ; Generate version string
   3  0000                  LUA ALLPASS
   4  0000 ~                v = tostring(sj.get_define("V"))
   5  0000 ~                maj = string.sub(v, 1,1)
   6  0000 ~                min = string.sub(v, 2,2)
   7  0000 ~                sj.insert_define("VERSION_STRING", "\"" .. maj .. "." .. min .. "\"")
   8  0000 ~
   9  0000 ~                b = tostring(sj.get_define("BLD"))
  10  0000 ~                sj.insert_define("BUILD_STRING", "\"" .. b .. "\"")
  11  0000                  ENDLUA
  12  0000
  13  0000                  IFNDEF MSX
  14  0000                  device	zxspectrum128
  15  0000                  IFDEF NEDOOS
  16  0000 ~            	DEFINE CRLF "\r\n"
  17  0000 ~                    MODULE nos
  18  0000 ~                        include "../_sdk/sysdefs.asm"
  19  0000 ~                    ENDMODULE
  20  0000 ~                    org nos.PROGSTART
  21  0000                      ELSE
  22  0000              	DEFINE CRLF "\r"
  23  0000                      org 24576
  24  6000                  ENDIF
  25  6000              asmOrg:
  26  6000                  align 256
  27  6000 C3 F5 9A         jp start
  28  6003                  include "vdp/index.asm"
# file opened: vdp/index.asm
   1+ 6003                  IFDEF TIMEX
   2+ 6003 ~                include "timex.asm"
   3+ 6003                  ENDIF
   4+ 6003
   5+ 6003                  IFDEF TIMEX80
   6+ 6003                  include "timex80.asm"
# file opened: vdp/timex80.asm
   1++6003              COLOR=0
   2++6003                  module TextMode
   3++6003              PORT_SELECT = #7c3b
   4++6003              init:
   5++6003 21 C8 61 06      ld hl, font_file, b, Dos.FMODE_READ
   5++6007 01
   6++6008 CD C0 69         call Dos.fopen
   7++600B F5               push af
   8++600C 01 00 08 21      ld bc, 2048, hl, font
   8++6010 00 40
   9++6012 CD AD 6A         call Dos.fread
  10++6015 F1               pop af
  11++6016 CD 99 6A         call Dos.fclose
  12++6019
  13++6019                  IFDEF UNO
  14++6019 ~                ;; Force turbo mode
  15++6019 ~                ld bc, 64571
  15++6019 ~              ld a, #0b
  15++6019 ~              out (c), a
  16++6019 ~                ld bc, 64827
  16++6019 ~              in a, (c)
  16++6019 ~              or #c0
  16++6019 ~              out (c),a
  17++6019                  ENDIF
  18++6019              cls:
  19++6019 3E 07            ld a, 7
  19++601B CD 7F 8E       call Memory.setPage
  20++601E
  21++601E                  IFDEF UNO
  22++601E ~                ld a, #3E
  22++601E ~              out (#ff), a
  23++601E                  ELSE
  24++601E 01 F7 EF         ld	bc, #EFF7   ;   Scorpio
  25++6021 3E 02            ld a,2
  26++6023 ED 79            out (C), a
  27++6025                  ENDIF
  28++6025
  29++6025 F3               di
  30++6026 21 00 00 54      ld	hl,0, d,h, e,h, b,h, c,b
  30++602A 5C 44 48
  31++602D 39               add	hl,sp
  32++602E 31 00 D8         ld	sp,#c000 + 6144
  33++6031              .loop
  34++6031                  dup 12
  35++6031 D5          >	push	de
  35++6032 D5          >	push	de
  35++6033 D5          >	push	de
  35++6034 D5          >	push	de
  35++6035 D5          >	push	de
  35++6036 D5          >	push	de
  35++6037 D5          >	push	de
  35++6038 D5          >	push	de
  35++6039 D5          >	push	de
  35++603A D5          >	push	de
  35++603B D5          >	push	de
  35++603C D5          >	push	de
  36++603D                  edup
  37++603D
  38++603D 10 F2            djnz	.loop
  39++603F
  40++603F 41               ld	b,c
  41++6040 31 00 F8         ld	sp,#e000 + 6144
  42++6043              .loop2:
  43++6043                  dup 12
  44++6043 D5          >	push	de
  44++6044 D5          >	push	de
  44++6045 D5          >	push	de
  44++6046 D5          >	push	de
  44++6047 D5          >	push	de
  44++6048 D5          >	push	de
  44++6049 D5          >	push	de
  44++604A D5          >	push	de
  44++604B D5          >	push	de
  44++604C D5          >	push	de
  44++604D D5          >	push	de
  44++604E D5          >	push	de
  45++604F                  edup
  46++604F
  47++604F 10 F2            djnz .loop2
  48++6051 F9               ld	sp,hl
  49++6052 21 00 00         ld hl ,0
  49++6055 22 C6 61       ld (coords), hl
  50++6058 AF               xor a
  50++6059 CD 7F 8E       call Memory.setPage
  51++605C
  52++605C FB               ei
  53++605D C9               ret
  54++605E
  55++605E              ; A - line
  56++605E              usualLine:
  57++605E 57              ld d, a
  58++605F 18 01           jr fill
  59++6061              ; A - line
  60++6061              highlightLine:
  61++6061 57               ld d, a
  62++6062              fill:
  63++6062 1E 00 06 40      ld e, 0, b, 64
  64++6066              .lloop
  65++6066 C5           	push bc
  66++6067 D5           	push de
  67++6068 CD 8D 61     	call findAddr
  68++606B 3E 07            ld a, 7
  68++606D CD 7F 8E       call Memory.setPage
  69++6070
  70++6070 06 08        	ld b, 8
  71++6072              .cloop
  72++6072 1A           	ld a, (de)
  72++6073 EE FF          xor #ff
  72++6075 12             ld (de), a
  73++6076 14           	inc d
  74++6077 10 F9        	djnz .cloop
  75++6079 D1           	pop de
  76++607A 1C           	inc e
  77++607B C1           	pop bc
  78++607C 10 E8        	djnz .lloop
  79++607E
  80++607E AF               xor a
  80++607F CD 7F 8E       call Memory.setPage
  81++6082 C9               ret
  82++6083
  83++6083              printZ:
  84++6083 7E               ld a, (hl)
  84++6084 A7             and a
  84++6085 C8             ret z
  85++6086 E5               push hl
  86++6087 CD 8E 60         call putC
  87++608A E1               pop hl
  88++608B 23               inc hl
  89++608C 18 F5            jr printZ
  90++608E
  91++608E
  92++608E              ; A - char
  93++608E              putC:
  94++608E 32 39 61         ld (drawC.char_tmp), a
  95++6091
  96++6091 FE 0D        	cp 13
  97++6093 CA B0 60     	jp z, .cr
  98++6096
  99++6096 ED 5B C6 61      ld de, (coords)
 100++609A 7B               ld a, e
 101++609B FE 55            cp 85
 102++609D D0               ret nc
 103++609E
 104++609E
 105++609E 3E 07            ld a, 7
 106++60A0 CD 7F 8E         call Memory.setPage
 107++60A3 FD E5            push iy
 108++60A5 CD C7 60         call drawC
 109++60A8 FD E1            pop iy
 110++60AA
 111++60AA 21 C6 61         ld hl, coords
 112++60AD 34               inc (hl)
 113++60AE
 114++60AE 18 12            jr .exit
 115++60B0              .cr
 116++60B0 2A C6 61     	ld hl, (coords)
 117++60B3 24           	inc h
 118++60B4 2E 00 22 C6  	ld l, 0, (coords), hl
 118++60B8 61
 119++60B9 FE 18        	cp 24
 120++60BB D8           	ret c
 121++60BC 21 00 00 22  	ld hl, 0, (coords), hl
 121++60C0 C6 61
 122++60C2              .exit
 123++60C2 AF               xor a
 123++60C3 CD 7F 8E       call Memory.setPage
 124++60C6 C9           	ret
 125++60C7
 126++60C7              drawC:
 127++60C7 2A C6 61         ld hl, (coords)
 128++60CA 45               ld b, l
 129++60CB CD F6 60         call .calc
 130++60CE 54               ld d, h
 131++60CF 5D               ld e, l
 132++60D0 32 3A 61         ld (.rot_tmp), a
 133++60D3 CD 8D 61         call findAddr
 134++60D6 D5               push de
 135++60D7 CD 2A 61         call .get_char
 136++60DA
 137++60DA E1               pop hl
 138++60DB              .print0
 139++60DB E5 DD E1         ld ix, hl
 140++60DE 7C               ld a, h
 141++60DF CB 6F            bit 5, a
 142++60E1 28 01            jr z, .ok
 143++60E3 2C               inc l
 144++60E4              .ok
 145++60E4 EE 20            xor #20
 145++60E6 67             ld h, a
 146++60E7 E5 FD E1         ld iy, hl
 147++60EA 3A 3A 61         ld a, (.rot_tmp)
 148++60ED CD 19 61         call .rotate_mask
 149++60F0 3A 3A 61         ld a, (.rot_tmp)
 150++60F3 C3 3B 61         jp basic_draw
 151++60F6              .calc
 152++60F6 2E 00              ld l,0
 153++60F8 78                 ld a, b
 153++60F9 A7             and a
 153++60FA C8             ret z
 154++60FB DD 21 00 00        ld ix, 0
 155++60FF 11 06 00           ld de,6
 156++6102 DD 19        1     add ix, de
 157++6104 10 FC              djnz 1b
 158++6106 11 F8 FF           ld de, -8
 159++6109 DD 7C        2     ld a, ixh
 160++610B A7                 and a
 161++610C 20 05              jr nz, 3f
 162++610E DD 7D              ld a, ixl
 163++6110 FE 08              cp 8
 164++6112 D8                 ret c
 165++6113              3
 166++6113 DD 19              add ix, de
 167++6115 2C                 inc l
 168++6116 18 F1              jr 2b
 169++6118 C9                 ret
 170++6119
 171++6119              .rotate_mask
 172++6119 21 FF 03         ld hl, #03ff
 173++611C A7               and a
 173++611D C8             ret z
 174++611E              .rot_loop
 175++611E 08               ex af, af
 176++611F 7D               ld a,l
 177++6120 0F               rrca
 178++6121 CB 1C            rr h
 179++6123 CB 1D            rr l
 180++6125 08               ex af, af
 181++6126 3D               dec a
 182++6127 20 F5            jr nz, .rot_loop
 183++6129 C9               ret
 184++612A              .get_char:
 185++612A 3A 39 61         ld a, (.char_tmp)
 186++612D 6F               ld l, a
 187++612E 26 00            ld h, 0
 188++6130 29               add hl, hl
 189++6131 29               add hl, hl
 190++6132 29               add hl, hl
 191++6133 01 00 40         ld bc, font
 192++6136 09               add hl, bc
 193++6137 EB               ex hl, de
 194++6138 C9               ret
 195++6139 00           .char_tmp db 0
 196++613A 00           .rot_tmp  db 0
 197++613B              ; A - rotation counter
 198++613B              ; DE - font PTR
 199++613B              ; HL - mask
 200++613B              ; IX - left half on screen
 201++613B              ; IY - right half on screen
 202++613B              basic_draw:
 203++613B 32 4D 61         ld (.rot_cnt),a
 204++613E
 205++613E 7D               ld a, l
 206++613F 32 60 61         ld (.mask1), a
 207++6142 7C               ld a, h
 208++6143 32 69 61         ld (.mask2), a
 209++6146 06 08            ld b, 8
 210++6148              .printIt
 211++6148 1A               ld a, (de)
 212++6149 67               ld h, a
 213++614A 2E 00            ld l, 0
 214++614C 3E 00            ld a, 0
 215++614E              .rot_cnt = $ - 1
 216++614E A7               and a
 216++614F 28 0B          jr z, .skiprot
 217++6151              .rot
 218++6151 08               ex af, af
 219++6152 7D               ld a,l
 220++6153 0F               rrca
 221++6154 CB 1C            rr h
 222++6156 CB 1D            rr l
 223++6158 08               ex af, af
 224++6159 3D               dec a
 225++615A 20 F5            jr nz, .rot
 226++615C              .skiprot
 227++615C FD 7E 00         ld a, (iy)
 228++615F E6 0F            and #0f
 229++6161              .mask1 = $ - 1
 230++6161 B5               or l
 231++6162 FD 77 00         ld (iy), a
 232++6165 DD 7E 00         ld a, (ix)
 233++6168 E6 FC            and #fc
 234++616A              .mask2 = $ -1
 235++616A B4               or h
 236++616B DD 77 00         ld (ix), a
 237++616E DD 24            inc ixh
 238++6170 FD 24            inc iyh
 239++6172 13               inc de
 240++6173 10 D3            djnz .printIt
 241++6175 C9               ret
 242++6176
 243++6176
 244++6176              ; H - line
 245++6176              ; A - char
 246++6176              fillLine:
 247++6176 54 1E 00         ld d, h, e, 0
 247++6179 CD 88 61       call gotoXY
 248++617C 06 55            ld b, 85
 249++617E              .loop
 250++617E F5 C5            push af, bc
 251++6180 CD 8E 60         call putC
 252++6183 C1 F1            pop bc, af
 253++6185 10 F7            djnz .loop
 254++6187 C9               ret
 255++6188
 256++6188
 257++6188              gotoXY:
 258++6188 ED 53 C6 61      ld (coords), de
 259++618C C9               ret
 260++618D
 261++618D              ; D - Y
 262++618D              ; E - X
 263++618D              ; OUT: de - coords
 264++618D              findAddr:
 265++618D 7B               ld a, e
 266++618E CB 3F            srl a
 267++6190 5F               ld e,a
 268++6191 06 E0            ld b, #E0
 269++6193 38 02            jr c, .proc
 270++6195 06 C0            ld b, #C0
 271++6197              .proc
 272++6197 7A               LD A,D
 273++6198 E6 07            AND 7
 274++619A 0F               RRCA
 275++619B 0F               RRCA
 276++619C 0F               RRCA
 277++619D B3               OR E
 278++619E 5F               LD E,A
 279++619F 7A               LD A,D
 280++61A0 E6 18            AND 24
 281++61A2 B0               OR b
 282++61A3 57               LD D,A
 283++61A4 C9               ret
 284++61A5
 285++61A5              toggleColor:
 286++61A5 3A BD 61         ld a,(curState)
 287++61A8 FE 07            cp 7
 288++61AA CA B5 61         jp z, sevenEleven
 289++61AD              ;zerroTolerance
 290++61AD 3E 07            ld a,7
 291++61AF 32 BD 61         ld (curState),a
 292++61B2 D3 FE            out (#fe),a
 293++61B4 C9               ret
 294++61B5              sevenEleven:
 295++61B5 3E 00            ld a,0
 296++61B7 32 BD 61         ld (curState),a
 297++61BA D3 FE            out (#fe),a
 298++61BC C9               ret
 299++61BD              curState:
 300++61BD 00               db 0
 301++61BE              disable:
 302++61BE                  IFDEF UNO
 303++61BE ~                xor a
 303++61BE ~              out (#fe), a
 303++61BE ~              out (#ff), a
 304++61BE                  ELSE
 305++61BE 01 F7 EF         ld	bc, #EFF7   ;   Scorpio
 306++61C1 3E 00            ld a,0
 307++61C3 ED 79            out (C), a
 308++61C5                  ENDIF
 309++61C5 C9               ret
 310++61C6
 311++61C6 00 00        coords dw 0
 312++61C8              font equ #4000 ; Using ZX-Spectrum screen as font buffer
 313++61C8 66 6F 6E 74  font_file db "font80.bin", 0
 313++61CC 38 30 2E 62
 313++61D0 69 6E 00
 314++61D3                  endmodule
 315++61D3
 316++61D3              exit:
 317++61D3 01 3B 7C 3E      ld bc, TextMode.PORT_SELECT, a, 1
 317++61D7 01
 318++61D8 ED 79            out (c), a
 319++61DA 04               inc b
 319++61DB AF             xor a
 320++61DC ED 79            out (c), a
 321++61DE C7               rst 0
# file closed: vdp/timex80.asm
   7+ 61DF                  ENDIF
   8+ 61DF
   9+ 61DF                  IFDEF ZXSCR
  10+ 61DF ~                include "zx.asm"
  11+ 61DF                  ENDIF
  12+ 61DF
  13+ 61DF              	IFDEF NEDOOS
  14+ 61DF ~                include "nedotext.asm"
  15+ 61DF                  ENDIF
# file closed: vdp/index.asm
  29  61DF                  include "utils/index.asm"
# file opened: utils/index.asm
   1+ 61DF                  include "atoi.asm"
# file opened: utils/atoi.asm
   1++61DF              ; DE - buffer
   2++61DF              ; HL - output
   3++61DF              atohl:
   4++61DF 21 00 00         ld hl, 0
   5++61E2              .loop
   6++61E2 1A               ld a, (de)
   7++61E3 13               inc de
   8++61E4                  ; Sepparators
   9++61E4 C5 E5            push bc, hl
  10++61E6 01 05 00             ld bc, sepparators_len
  11++61E9 21 01 62             ld hl, sepparators
  12++61EC ED B1                cpir
  13++61EE E1 C1            pop hl, bc
  14++61F0 C8               ret z
  15++61F1
  16++61F1 D6 30            sub '0'
  17++61F3
  18++61F3 C5               push bc
  19++61F4 4D                   ld c, l
  20++61F5 44                   ld b, h
  21++61F6
  22++61F6 29                   add hl, hl
  23++61F7 29                   add hl, hl
  24++61F8 09                   add hl, bc
  25++61F9 29                   add hl, hl
  26++61FA 4F                   ld c, a
  27++61FB 06 00                ld b, 0
  28++61FD 09                   add hl, bc
  29++61FE C1               pop bc
  30++61FF 18 E1            jr .loop
  31++6201
# file closed: utils/atoi.asm
   2+ 6201                  include "constants.asm"
# file opened: utils/constants.asm
   1++6201              TAB = 9
   2++6201              CR = 13
   3++6201              LF = 10
   4++6201              NULL = 0
   5++6201              SPACE = ' '
   6++6201              ESC = 27
   7++6201              BACKSPACE = 8
   8++6201
   9++6201                  IFDEF TIMEX80
  10++6201              MIME_DOWNLOAD 	= #19
  11++6201              MIME_LINK 		= #1A
  12++6201              MIME_TEXT 		= #10
  13++6201              MIME_IMAGE 		= #01
  14++6201              MIME_MUSIC 		= #0e
  15++6201              MIME_INPUT 		= #b3
  16++6201              MIME_MOD 		= #0d
  17++6201
  18++6201              BORDER_TOP = #b2
  19++6201              BORDER_BOTTOM = #b1
  20++6201                  ELSE
  21++6201 ~            	IFDEF MSX
  22++6201 ~            MIME_DOWNLOAD 	= 1
  23++6201 ~            MIME_LINK		= 2
  24++6201 ~            MIME_TEXT 		= 3
  25++6201 ~            MIME_IMAGE 		= 4
  26++6201 ~            MIME_MUSIC 		= 5
  27++6201 ~            MIME_INPUT 		= 6
  28++6201 ~            MIME_MOD      	= 7
  29++6201 ~            BORDER_TOP    = 7
  30++6201 ~            BORDER_BOTTOM = 8
  31++6201 ~            	ELSE
  32++6201 ~            MIME_DOWNLOAD = 1
  33++6201 ~            MIME_LINK     = 2
  34++6201 ~            MIME_TEXT     = 3
  35++6201 ~            MIME_IMAGE    = 6
  36++6201 ~            MIME_MUSIC    = 5
  37++6201 ~            MIME_INPUT    = 4
  38++6201 ~            MIME_MOD      = 7
  39++6201 ~
  40++6201 ~            BORDER_TOP    = 9
  41++6201 ~            BORDER_BOTTOM = 8
  42++6201 ~            	ENDIF
  43++6201 ~
  44++6201 ~
  45++6201 ~
  46++6201 ~
  47++6201              	ENDIF
  48++6201
  49++6201 0D 0A 09 00  sepparators db CR, LF, TAB, NULL, SPACE
  49++6205 20
  50++6206              sepparators_len = $ - sepparators
# file closed: utils/constants.asm
   3+ 6206                  include "strutils.asm"
# file opened: utils/strutils.asm
   1++6206              ; de - pointer
   2++6206              ; hl - count
   3++6206              strlen:
   4++6206 21 00 00         ld hl, 0
   5++6209              .loop
   6++6209 1A               ld a, (de)
   7++620A A7               and a
   7++620B 28 04          jr z, .exit
   8++620D 23               inc hl
   9++620E 13               inc de
  10++620F 18 F8            jr .loop
  11++6211              .exit
  12++6211 C9               ret
  13++6212
  14++6212                  module CompareBuff
  15++6212
  16++6212              ; Pushes A to buffer
  17++6212              push
  18++6212 F5               push af
  19++6213 06 20            ld b, 32
  19++6215 21 5E 62       ld hl, buffer + 1
  19++6218 11 5D 62       ld de, buffer
  20++621B              .loop
  21++621B 7E               ld a, (hl)
  21++621C 12             ld (de), a
  21++621D 23             inc hl
  21++621E 13             inc de
  21++621F 10 FA          djnz .loop
  22++6221 F1               pop af
  23++6222 21 7C 62         ld hl, buffer + 31
  23++6225 77             ld (hl), a
  24++6226 C9               ret
  25++6227
  26++6227              ; HL - Compare string(null terminated)
  27++6227              ; A - 0 NOT Found
  28++6227              ;     1 Found
  29++6227              search:
  30++6227 06 00            ld b, 0
  30++6229 E5             push hl
  31++622A              .loop:
  32++622A 7E               ld a, (hl)
  32++622B 23             inc hl
  32++622C 04             inc b
  32++622D A7             and a
  32++622E C2 2A 62       jp nz, .loop
  33++6231 05               dec b
  33++6232 E1             pop hl
  33++6233 C5             push bc
  33++6234 E5             push hl
  34++6235 E1               pop hl
  35++6236 11 7D 62         ld de, buffer + 32
  36++6239              .sourceLoop
  37++6239 1B               dec de
  37++623A 10 FD          djnz .sourceLoop
  38++623C C1               pop bc
  39++623D              .compare
  40++623D C5               push bc
  40++623E F5             push af
  41++623F 1A               ld a, (de)
  41++6240 47             ld b, a
  42++6241 F1               pop af
  42++6242 7E             ld a, (hl)
  42++6243 B8             cp b
  42++6244 C1             pop bc
  42++6245 3E 00          ld a, 0
  42++6247 C0             ret nz
  43++6248 13               inc de
  43++6249 23             inc hl
  44++624A 10 F1            djnz .compare
  45++624C 3E 01            ld a, 1
  46++624E C9               ret
  47++624F
  48++624F              clear:
  49++624F AF               xor a
  49++6250 21 5D 62       ld hl, buffer
  49++6253 11 5E 62       ld de, buffer + 1
  49++6256 01 20 00       ld bc, 32
  49++6259 77             ld (hl), a
  49++625A ED B0          ldir
  50++625C C9               ret
  51++625D
  52++625D 00 00 00...  buffer ds 32
  53++627D
  54++627D                  endmodule
# file closed: utils/strutils.asm
   4+ 627D                  IFDEF MSX
   5+ 627D ~            	    include "bios.asm"
   6+ 627D                  ENDIF
   7+ 627D                  include "screen.asm"
# file opened: utils/screen.asm
   1++627D              LINE_LIMIT = 63
   2++627D
   3++627D                  IFDEF NEDOOS
   4++627D ~            LINE_LIMIT = 79
   5++627D                  ENDIF
   6++627D
   7++627D                  IFDEF TIMEX80
   8++627D              LINE_LIMIT = 84
   9++627D                  ENDIF
  10++627D
  11++627D                  IFDEF MSX
  12++627D ~            LINE_LIMIT = 79
  13++627D                  ENDIF
  14++627D              ; HL - string pointer
  15++627D              print70Text:
  16++627D 06 54            ld b, LINE_LIMIT
  17++627F              .loop
  18++627F 7E               ld a, (hl)
  19++6280 A7               and a
  19++6281 C8             ret z
  20++6282 FE 0D            cp 13
  20++6284 C8             ret z
  21++6285 FE 0A            cp 10
  21++6287 C8             ret z
  22++6288 C5               push bc
  23++6289 E5               push hl
  24++628A CD 8E 60         call TextMode.putC
  25++628D E1               pop hl
  26++628E 23               inc hl
  27++628F C1               pop bc
  28++6290 05               dec b
  29++6291 78               ld a, b
  29++6292 A7             and a
  29++6293 C8             ret z
  30++6294 C3 7F 62         jp .loop
  31++6297
  32++6297              ; HL - string pointer
  33++6297              print70Goph:
  34++6297 06 54            ld b, LINE_LIMIT
  35++6299              .loop
  36++6299 7E               ld a, (hl)
  36++629A FE 09          cp 09
  36++629C C8             ret z
  37++629D A7               and a
  37++629E C8             ret z
  38++629F C5               push bc
  39++62A0 E5               push hl
  40++62A1 CD 8E 60         call TextMode.putC
  41++62A4 E1               pop hl
  42++62A5 23               inc hl
  43++62A6 C1               pop bc
  44++62A7 05               dec b
  45++62A8 78               ld a, b
  45++62A9 A7             and a
  45++62AA C8             ret z
  46++62AB C3 99 62         jp .loop
# file closed: utils/screen.asm
# file closed: utils/index.asm
  30  62AE                  include "gopher/render/index.asm"
# file opened: gopher/render/index.asm
   1+ 62AE                  MODULE Render
   2+ 62AE              PER_PAGE = 22
   3+ 62AE              CURSOR_OFFSET = 2
   4+ 62AE                  include "row.asm"
# file opened: gopher/render/row.asm
   1++62AE              ; A - row number
   2++62AE              ; HL - pointer to row
   3++62AE              renderRow:
   4++62AE C6 02            add CURSOR_OFFSET
   5++62B0 57               ld d,a
   6++62B1 1E 00            ld e,0
   7++62B3 CD 88 61         call TextMode.gotoXY
   8++62B6 7E               ld a,(hl)
   9++62B7 E5               push hl
  10++62B8 CD C3 62         call getIcon
  11++62BB CD 8E 60         call TextMode.putC
  12++62BE E1               pop hl
  13++62BF 23               inc hl
  14++62C0 C3 97 62         jp print70Goph
  15++62C3
  16++62C3              ; A - gopher id char
  17++62C3              getIcon:
  18++62C3 FE 69            cp 'i'
  18++62C5 CA DF 62       jp z, .info
  19++62C8 FE 39            cp '9'
  19++62CA CA E2 62       jp z, .down
  20++62CD FE 31            cp '1'
  20++62CF CA 48 63       jp z, .page
  21++62D2 FE 30            cp '0'
  21++62D4 CA 4B 63       jp z, .text
  22++62D7 FE 37            cp '7'
  22++62D9 CA 4E 63       jp z, .input
  23++62DC 3E 20            ld a, ' '
  24++62DE C9               ret
  25++62DF              .info
  26++62DF 3E 20            ld a, SPACE
  26++62E1 C9             ret
  27++62E2              .down
  28++62E2 54 5D            ld de, hl
  29++62E4 01 FF 00 3E      ld bc, #ff, a, TAB
  29++62E8 09
  29++62E9 ED B1          cpir
  30++62EB 78               ld a, b
  30++62EC B1             or c
  30++62ED 28 56          jr z, .downExit
  31++62EF D5               push de
  32++62F0              .nameLoop
  33++62F0 7E               ld a, (hl)
  33++62F1 A7             and a
  33++62F2 28 10          jr z, .check
  34++62F4 FE 09            cp TAB
  34++62F6 28 0C          jr z, .check
  35++62F8 FE 0D            cp CR
  35++62FA 28 08          jr z, .check
  36++62FC E5               push hl
  37++62FD CD 12 62         call CompareBuff.push
  38++6300 E1               pop hl
  39++6301 23               inc hl
  40++6302 18 EC            jr .nameLoop
  41++6304              .check
  42++6304 21 5D 63         ld hl, scrExt1
  42++6307 CD 27 62       call CompareBuff.search
  42++630A A7             and a
  42++630B 20 44          jr nz, .image
  43++630D 21 62 63         ld hl, scrExt2
  43++6310 CD 27 62       call CompareBuff.search
  43++6313 A7             and a
  43++6314 20 3B          jr nz, .image
  44++6316 3E 03            ld a, 3
  44++6318 32 E4 8E       ld (VTPL.SETUP), a ; 0 bit - looping, 1 bit - pt2 file
  45++631B 21 71 63         ld hl, pt2Ext1
  45++631E CD 27 62       call CompareBuff.search
  45++6321 A7             and a
  45++6322 20 31          jr nz, .music
  46++6324 21 76 63         ld hl, pt2Ext2
  46++6327 CD 27 62       call CompareBuff.search
  46++632A A7             and a
  46++632B 20 28          jr nz, .music
  47++632D 3E 01            ld a, 1
  47++632F 32 E4 8E       ld (VTPL.SETUP), a
  48++6332 21 67 63         ld hl, pt3Ext1
  48++6335 CD 27 62       call CompareBuff.search
  48++6338 A7             and a
  48++6339 20 1A          jr nz, .music
  49++633B 21 6C 63         ld hl, pt3Ext2
  49++633E CD 27 62       call CompareBuff.search
  49++6341 A7             and a
  49++6342 20 11          jr nz, .music
  50++6344
  51++6344                  ; General Sound support
  52++6344                  ifdef GS
  53++6344 ~                ld hl, modExt1
  53++6344 ~              call CompareBuff.search
  53++6344 ~              and a
  53++6344 ~              jr nz, .mod
  54++6344 ~                ld hl, modExt2
  54++6344 ~              call CompareBuff.search
  54++6344 ~              and a
  54++6344 ~              jr nz, .mod
  55++6344                  endif
  56++6344
  57++6344              .checkExit
  58++6344 E1               pop hl
  59++6345              .downExit
  60++6345 3E 19            ld a, MIME_DOWNLOAD
  60++6347 C9             ret
  61++6348              .page
  62++6348 3E 1A            ld a, MIME_LINK
  62++634A C9             ret
  63++634B              .text
  64++634B 3E 10            ld a, MIME_TEXT
  64++634D C9             ret
  65++634E              .input
  66++634E 3E B3            ld a, MIME_INPUT
  66++6350 C9             ret
  67++6351              .image
  68++6351 E1               pop hl
  68++6352 3E 01          ld a, MIME_IMAGE
  68++6354 C9             ret
  69++6355              .music
  70++6355 E1               pop hl
  70++6356 3E 0E          ld a, MIME_MUSIC
  70++6358 C9             ret
  71++6359              .mod
  72++6359 E1               pop hl
  72++635A 3E 0D          ld a, MIME_MOD
  72++635C C9             ret
  73++635D
  74++635D 2E 73 63 72  scrExt1 db ".scr", 0
  74++6361 00
  75++6362 2E 53 43 52  scrExt2 db ".SCR", 0
  75++6366 00
  76++6367
  77++6367 2E 70 74 33  pt3Ext1 db ".pt3", 0
  77++636B 00
  78++636C 2E 50 54 33  pt3Ext2 db ".PT3", 0
  78++6370 00
  79++6371 2E 70 74 32  pt2Ext1 db ".pt2", 0
  79++6375 00
  80++6376 2E 50 54 32  pt2Ext2 db ".PT2", 0
  80++637A 00
  81++637B 2E 6D 6F 64  modExt1 db ".mod", 0
  81++637F 00
  82++6380 2E 4D 4F 44  modExt2 db ".MOD", 0
  82++6384 00
# file closed: gopher/render/row.asm
   5+ 6385                  include "buffer.asm"
# file opened: gopher/render/buffer.asm
   1++6385              ; BC - line count
   2++6385              findLine:
   3++6385 21 F5 9A         ld hl, outputBuffer
   4++6388 78               ld a,b
   5++6389 B1               or c
   6++638A CA B8 63         jp z, .checkEmpty
   7++638D              .preloop
   8++638D 16 0D            ld d,13
   9++638F              .loop
  10++638F 7E               ld a, (hl)
  10++6390 A7             and a
  10++6391 CA BB 63       jp z, .nope
  11++6394 BA               cp d
  11++6395 23             inc hl
  11++6396 CA AE 63       jp z, .checkLF  ;13
  12++6399 FE 0A            cp 10
  12++639B CA A1 63       jp z, .nextCheck     ;10
  13++639E C3 8F 63         jp .loop
  14++63A1              .nextCheck
  15++63A1 A7               and a
  15++63A2 CA BB 63       jp z, .nope
  16++63A5 0B               dec bc
  17++63A6 5F               ld e,a
  18++63A7 78               ld a,b
  19++63A8 B1               or c
  20++63A9 7B               ld a,e
  21++63AA C2 8F 63         jp nz, .loop
  22++63AD C9               ret
  23++63AE              .checkLF
  24++63AE 7E               ld a, (hl)
  25++63AF FE 0A            cp 10
  25++63B1 C2 A1 63       jp nz, .nextCheck    ;10
  26++63B4 23               inc hl
  27++63B5 C3 A1 63         jp  .nextCheck
  28++63B8              .checkEmpty
  29++63B8 7E               ld a, (hl)
  29++63B9 A7             and a
  29++63BA C0             ret nz
  30++63BB              .nope
  31++63BB 21 00 00         ld hl, 0
  31++63BE C9             ret
  32++63BF
# file closed: gopher/render/buffer.asm
   6+ 63BF                  include "ui.asm"
# file opened: gopher/render/ui.asm
   1++63BF                  IFDEF ZXSCR
   2++63BF ~                DEFINE LEFT_TAB "[D]omain:                                  "
   3++63BF                  ENDIF
   4++63BF
   5++63BF                  IFDEF TIMEX     ;UNKNOWM fallback to 64
   6++63BF ~                DEFINE LEFT_TAB "[D]omain:                                  "
   7++63BF                  ENDIF
   8++63BF
   9++63BF                  IFDEF TIMEX80
  10++63BF                  DEFINE LEFT_TAB "[D]omain:                                                      "
  11++63BF                  ENDIF
  12++63BF
  13++63BF                  IFDEF NEDOOS
  14++63BF ~                DEFINE LEFT_TAB "[D]omain:                                                  "
  15++63BF                  ENDIF
  16++63BF
  17++63BF                  IFDEF MSX
  18++63BF ~                DEFINE LEFT_TAB "[D]omain:                                              "
  19++63BF                  ENDIF
  20++63BF              prepareScreen:
  21++63BF CD 19 60         call TextMode.cls
  22++63C2 21 92 64         ld hl, header
  22++63C5 CD 83 60       call TextMode.printZ
  23++63C8 11 0A 00         ld de, #000A
  23++63CB CD 88 61       call TextMode.gotoXY
  24++63CE 21 A0 86         ld hl, hostName
  24++63D1 CD 83 60       call TextMode.printZ
  25++63D4 AF               xor a
  25++63D5 CD 61 60       call TextMode.highlightLine
  26++63D8 C9               ret
  27++63D9
  28++63D9              inputHost:
  29++63D9 CD 19 68         	call Console.waitForKeyUp
  30++63DC              .loop
  31++63DC 11 0A 00         ld de, #000A
  31++63DF CD 88 61       call TextMode.gotoXY
  31++63E2 21 A0 86       ld hl, hostName
  31++63E5 CD 83 60       call TextMode.printZ
  32++63E8 3E B3            ld a, MIME_INPUT
  32++63EA CD 8E 60       call TextMode.putC
  33++63ED 3E 20            ld a, ' '
  33++63EF CD 8E 60       call TextMode.putC
  34++63F2              .wait
  35++63F2 CD 26 68         call Console.getC
  36++63F5 5F               ld e, a
  37++63F6 FE 0C            cp Console.BACKSPACE
  37++63F8 28 17          jr z, .removeChar
  38++63FA FE 0D            cp CR
  38++63FC CA 1F 64       jp z, inputNavigate
  39++63FF FE 20            cp 32
  39++6401 38 EF          jr c, .wait
  40++6403              .putC
  41++6403 AF               xor a
  41++6404 21 A0 86 01    ld hl, hostName, bc, 48
  41++6408 30 00
  41++640A ED B1          cpir
  42++640C 77               ld (hl), a
  42++640D 2B             dec hl
  42++640E 73             ld (hl), e
  43++640F 18 CB            jr .loop
  44++6411              .removeChar
  45++6411 AF               xor a
  46++6412 21 A0 86 01      ld hl, hostName, bc, 48
  46++6416 30 00
  46++6418 ED B1          cpir
  47++641A 2B               dec hl
  47++641B 2B             dec hl
  47++641C 77             ld (hl), a
  48++641D 18 BD            jr .loop
  49++641F
  50++641F              inputNavigate:
  51++641F 21 A0 86 11      ld hl, hostName, de, domain
  51++6423 52 64
  52++6425 7E               ld a,(hl)
  53++6426 A7               and a
  54++6427 CA 17 70         jp z, History.load
  55++642A              .loop
  56++642A 7E               ld a, (hl)
  56++642B A7             and a
  56++642C 28 05          jr z, .complete
  57++642E 12               ld (de), a
  57++642F 23 13          inc hl, de
  58++6431 18 F7            jr .loop
  59++6433              .complete
  60++6433 3E 09            ld a, TAB
  60++6435 12             ld (de), a
  60++6436 13             inc de
  61++6437 3E 37            ld a, '7'
  61++6439 12             ld (de), a
  61++643A 13             inc de
  62++643B 3E 30            ld a, '0'
  62++643D 12             ld (de), a
  62++643E 13             inc de
  63++643F 3E 0D            ld a, CR
  63++6441 12             ld (de), a
  63++6442 13             inc de
  64++6443 3E 0A            ld a, LF
  64++6445 12             ld (de), a
  64++6446 13             inc de
  65++6447 21 4D 64         ld hl, navRow
  65++644A C3 70 70       jp History.navigate
  66++644D
  67++644D 31 20 09 2F  navRow db "1 ", TAB, "/", TAB
  67++6451 09
  68++6452 6E 69 68 69  domain db "nihirash.net"
  68++6456 72 61 73 68
  68++645A 2E 6E 65 74
  69++645E 00 00 00...      ds 64 - ($ - domain)
  70++6492
  71++6492 5B 44 5D 6F  header db "[D]omain:                                                      ", "MRF "
  71++6496 6D 61 69 6E
  71++649A 3A 20 20 20
  71++649E 20 20 20 20
  71++64A2 20 20 20 20
  71++64A6 20 20 20 20
  71++64AA 20 20 20 20
  71++64AE 20 20 20 20
  71++64B2 20 20 20 20
  71++64B6 20 20 20 20
  71++64BA 20 20 20 20
  71++64BE 20 20 20 20
  71++64C2 20 20 20 20
  71++64C6 20 20 20 20
  71++64CA 20 20 20 20
  71++64CE 20 20 20 4D
  71++64D2 52 46 20
  72++64D5 31 2E 37            db "1.7"
  73++64D8 2E                  db "."
  74++64D9 38                  db "8"
  75++64DA              	IFDEF MSX
  76++64DA ~                   db " [MSX UNAPI]",13, 0
  77++64DA              	ENDIF
  78++64DA
  79++64DA                  IFDEF MB03
  80++64DA ~                   db " [MB03+]",13, 0
  81++64DA                     ENDIF
  82++64DA
  83++64DA                  IFDEF UNO
  84++64DA ~                   db " [UNO UART]",13, 0
  85++64DA                  ENDIF
  86++64DA
  87++64DA                  IFDEF AY
  88++64DA ~                   db " [AYWIFI]",13, 0
  89++64DA              	ENDIF
  90++64DA
  91++64DA                  IFDEF ZW
  92++64DA 20 5B 5A 58         db " [ZXWiFi]",13, 0
  92++64DE 57 69 46 69
  92++64E2 5D 0D 00
  93++64E5                  ENDIF
  94++64E5
  95++64E5                   IFDEF NEDOOSATM
  96++64E5 ~                   db " [ATM UART]",13, 0
  97++64E5                  ENDIF
  98++64E5
  99++64E5                  IFDEF NEDOOSEVO
 100++64E5 ~                   db " [EVO UART]",13, 0
 101++64E5                  ENDIF
 102++64E5
 103++64E5                  IFDEF UNOUART
 104++64E5 ~                   db " [UNO UART]",13, 0
 105++64E5                  ENDIF
 106++64E5
 107++64E5                  IFDEF NEDOOS
 108++64E5 ~            	IFNDEF NEDOOSATM
 109++64E5 ~            	IFNDEF NEDOOSEVO
 110++64E5 ~                   db " [nedoNET]",13, 0
 111++64E5 ~
 112++64E5 ~                ENDIF
 113++64E5 ~            	ENDIF
 114++64E5              	ENDIF
 115++64E5
# file closed: gopher/render/ui.asm
   7+ 64E5                  include "gopher-page.asm"
# file opened: gopher/render/gopher-page.asm
   1++64E5              renderGopherScreen:
   2++64E5 CD BF 63         call Render.prepareScreen
   3++64E8 06 16            ld b, PER_PAGE
   4++64EA              .loop
   5++64EA C5               push bc
   6++64EB 3E 16            ld a, PER_PAGE
   7++64ED 90               sub b
   8++64EE 47               ld b,a
   9++64EF 5F               ld e,a
  10++64F0
  11++64F0 48                   ld c,b
  12++64F1 06 00                ld b,0
  13++64F3
  14++64F3 2A 8E 74             ld hl, (page_offset)
  15++64F6 09                   add hl,bc
  16++64F7 44 4D                ld bc,hl
  17++64F9 D5                   push de
  18++64FA CD 85 63         call Render.findLine
  19++64FD D1               pop de
  20++64FE
  21++64FE 7C               ld a, h
  22++64FF B5               or l
  23++6500 28 04            jr z, .exit
  24++6502 7B               ld a, e
  25++6503 CD AE 62         call renderRow
  26++6506              .exit
  27++6506 C1               pop bc
  28++6507 10 E1            djnz .loop
  29++6509 CD 06 66         call showCursor
  30++650C C9               ret
  31++650D
  32++650D              checkBorder:
  33++650D 3A 8C 74         ld a, (cursor_position)
  33++6510 FE FF          cp #ff
  33++6512 CA 2A 66       jp z, pageUp
  34++6515 3A 8C 74         ld a, (cursor_position)
  34++6518 FE 16          cp PER_PAGE
  34++651A CA 5D 66       jp z, pageDn
  35++651D CD 06 66         call showCursor
  36++6520 C3 23 65         jp workLoop
  37++6523
  38++6523              workLoop:
  39++6523 3A 35 67         ld a, (play_next)
  39++6526 A7             and a
  39++6527 C2 BB 65       jp nz, navigate
  40++652A
  41++652A                  dup 5
  42++652A 76          >    halt
  42++652B 76          >    halt
  42++652C 76          >    halt
  42++652D 76          >    halt
  42++652E 76          >    halt
  43++652F                  edup
  44++652F              .nothing
  45++652F CD 37 68         call Console.peekC
  46++6532 A7               and a
  46++6533 CA 2F 65       jp z, .nothing
  47++6536
  48++6536 FE 31            cp '1'
  48++6538 CA 00 70       jp z, History.back
  49++653B FE 32            cp '2'
  49++653D CA BB 65       jp z, navigate
  50++6540 FE 33            cp '3'
  50++6542 CA 16 66       jp z, cursorDown
  51++6545 FE 34            cp '4'
  51++6547 CA 20 66       jp z, cursorUp
  52++654A FE 35            cp '5'
  52++654C CA 2A 66       jp z, pageUp
  53++654F FE 38            cp '8'
  53++6551 CA 5D 66       jp z, pageDn
  54++6554 FE 36            cp '6'
  54++6556 CA 16 66       jp z, cursorDown
  55++6559 FE 37            cp '7'
  55++655B CA 20 66       jp z, cursorUp
  56++655E
  57++655E FE 0A            cp Console.KEY_DN
  57++6560 CA 16 66       jp z, cursorDown
  58++6563 FE 61            cp 'a'
  58++6565 CA 16 66       jp z, cursorDown
  59++6568 FE 0B            cp Console.KEY_UP
  59++656A CA 20 66       jp z, cursorUp
  60++656D FE 71            cp 'q'
  60++656F CA 20 66       jp z, cursorUp
  61++6572 FE 08            cp Console.KEY_LT
  61++6574 CA 2A 66       jp z, pageUp
  62++6577 FE 6F            cp 'o'
  62++6579 CA 2A 66       jp z, pageUp
  63++657C FE 09            cp Console.KEY_RT
  63++657E CA 5D 66       jp z, pageDn
  64++6581 FE 70            cp 'p'
  64++6583 CA 5D 66       jp z, pageDn
  65++6586
  66++6586 FE 68            cp 'h'
  66++6588 CA 6D 70       jp z, History.home
  67++658B FE 48            cp 'H'
  67++658D CA 6D 70       jp z, History.home
  68++6590
  69++6590 FE 62            cp 'b'
  69++6592 CA 00 70       jp z, History.back
  70++6595 FE 42            cp 'B'
  70++6597 CA 00 70       jp z, History.back
  71++659A FE 0C            cp Console.BACKSPACE
  71++659C CA 00 70       jp z, History.back
  72++659F
  73++659F FE 64            cp 'd'
  73++65A1 CA D9 63       jp z, inputHost
  74++65A4 FE 44            cp 'D'
  74++65A6 CA D9 63       jp z, inputHost
  75++65A9
  76++65A9 FE 0D            cp CR
  76++65AB CA BB 65       jp z, navigate
  77++65AE
  78++65AE                  IFDEF MSX
  79++65AE ~                	cp ESC
  79++65AE ~              jp z, exit
  80++65AE                  ENDIF
  81++65AE
  82++65AE                  IFDEF GS
  83++65AE ~                cp 'M'
  83++65AE ~              call z, GeneralSound.toggleModule
  84++65AE ~                cp 'm'
  84++65AE ~              call z, GeneralSound.toggleModule
  85++65AE ~                cp 'g'
  85++65AE ~              call z, GeneralSound.toggleDownload
  86++65AE ~                cp 'G'
  86++65AE ~              call z, GeneralSound.toggleDownload
  87++65AE                  ENDIF
  88++65AE
  89++65AE                  IFDEF TIMEX80
  90++65AE FE 54            cp 'T'
  90++65B0 CC A5 61       call z, TextMode.toggleColor
  91++65B3 FE 74            cp 't'
  91++65B5 CC A5 61       call z, TextMode.toggleColor
  92++65B8                  ENDIF
  93++65B8
  94++65B8 C3 23 65         jp workLoop
  95++65BB
  96++65BB              navigate:
  97++65BB CD 19 68         call Console.waitForKeyUp
  98++65BE AF               xor a
  98++65BF 32 35 67       ld (play_next), a
  99++65C2 CD 0E 66         call hideCursor
 100++65C5 ED 4B 8E 74      ld bc, (page_offset)
 101++65C9 2A 8C 74         ld hl, (cursor_position)
 102++65CC 09               add hl,bc
 103++65CD 44               ld b, h ;HHHHH
 104++65CE 4D               ld c, l ;LLLLL
 105++65CF D5               push de
 106++65D0 CD 85 63         call Render.findLine
 107++65D3 D1               pop de
 108++65D4 7E               ld a, (hl)
 109++65D5 FE 31            cp '1'
 109++65D7 CA EF 65       jp z, .load
 110++65DA FE 30            cp '0'
 110++65DC CA EF 65       jp z, .load
 111++65DF FE 39            cp '9'
 111++65E1 CA EF 65       jp z, .load
 112++65E4 FE 37            cp '7'
 112++65E6 CA F7 65       jp z, .input
 113++65E9 CD 06 66         call showCursor
 114++65EC C3 23 65         jp workLoop
 115++65EF              .load
 116++65EF E5               push hl
 117++65F0 CD C3 62         call getIcon
 118++65F3 E1               pop hl
 119++65F4 C3 70 70         jp History.navigate
 120++65F7              .input
 121++65F7 E5               push hl
 122++65F8 CD 36 67         call DialogBox.inputBox
 123++65FB E1               pop hl
 124++65FC 3A 91 67         ld a, (DialogBox.inputBuffer)
 124++65FF A7             and a
 124++6600 CA 17 70       jp z, History.load
 125++6603 C3 EF 65         jp .load
 126++6606
 127++6606              showCursor:
 128++6606 3A 8C 74         ld a, (cursor_position)
 128++6609 C6 02          add CURSOR_OFFSET
 129++660B C3 61 60         jp TextMode.highlightLine
 130++660E
 131++660E              hideCursor:
 132++660E 3A 8C 74         ld a, (cursor_position)
 132++6611 C6 02          add CURSOR_OFFSET
 133++6613 C3 5E 60         jp TextMode.usualLine
 134++6616
 135++6616              cursorDown:
 136++6616 CD 0E 66         call hideCursor
 137++6619 21 8C 74         ld hl, cursor_position
 138++661C 34               inc (hl)
 139++661D C3 0D 65         jp checkBorder
 140++6620
 141++6620              cursorUp:
 142++6620 CD 0E 66         call hideCursor
 143++6623 21 8C 74         ld hl, cursor_position
 144++6626 35               dec (hl)
 145++6627 C3 0D 65         jp checkBorder
 146++662A
 147++662A              pageUp:
 148++662A 3A 8E 74         ld a, (page_offset)
 148++662D FE 00          cp 0
 148++662F C2 3D 66       jp nz, .pageUp2
 149++6632 3A 8F 74         ld a, (page_offset + 1)
 149++6635 FE 00          cp 0
 149++6637 C2 3D 66       jp nz, .pageUp2
 150++663A C3 53 66         jp .skip
 151++663D              .pageUp2:
 152++663D 3E 15            ld a, PER_PAGE - 1
 152++663F 32 8C 74       ld (cursor_position), a
 153++6642 2A 8E 74         ld hl, (page_offset)
 154++6645 11 16 00         ld de,PER_PAGE
 155++6648 ED 52            sbc hl,de
 156++664A 22 8E 74         ld (page_offset), hl
 157++664D              .exit
 158++664D CD E5 64         call renderGopherScreen
 159++6650 C3 23 65         jp workLoop
 160++6653              .skip
 161++6653 AF               xor a
 161++6654 32 8C 74       ld (cursor_position), a
 161++6657 CD E5 64       call renderGopherScreen
 161++665A C3 23 65       jp workLoop
 162++665D
 163++665D              pageDn:
 164++665D AF                xor a
 164++665E 32 8C 74       ld (cursor_position), a
 165++6661 2A 8E 74         ld hl,(page_offset)
 166++6664 11 16 00         ld de,PER_PAGE
 167++6667 19               add hl,de
 168++6668 22 8E 74         ld (page_offset), hl
 169++666B C3 4D 66         jp pageUp.exit
 170++666E
 171++666E
 172++666E
# file closed: gopher/render/gopher-page.asm
   8+ 666E                  include "plaintext.asm"
# file opened: gopher/render/plaintext.asm
   1++666E              renderPlainTextScreen:
   2++666E CD BF 63         call prepareScreen
   3++6671 06 16            ld b, PER_PAGE
   4++6673              .loop
   5++6673 C5               push bc
   6++6674 3E 16            ld a, PER_PAGE
   7++6676 90               sub b
   8++6677 47               ld b,a
   9++6678 5F               ld e,a
  10++6679 48               ld c,b
  11++667A 06 00            ld b,0
  12++667C 2A 8E 74         ld hl, (page_offset)
  13++667F 09               add hl,bc
  14++6680 44 4D            ld bc,hl
  15++6682 D5               push de
  16++6683 CD 85 63         call Render.findLine
  17++6686 D1               pop de
  18++6687 7C               ld a, h
  18++6688 B5             or l
  18++6689 CA 9C 66       jp z, .exit
  19++668C 7B               ld a, e
  20++668D C6 02            add CURSOR_OFFSET
  20++668F 57 1E 01       ld d, a, e, 1
  20++6692 CD 88 61       call TextMode.gotoXY
  21++6695 CD 7D 62         call print70Text
  22++6698 C1               pop bc
  23++6699 10 D8            djnz .loop
  24++669B C9               ret
  25++669C              .exit
  26++669C C1               pop bc
  27++669D C9               ret
  28++669E
  29++669E              plainTextLoop:
  30++669E CD 26 68         call Console.getC
  31++66A1
  32++66A1 FE 31            cp '1'
  32++66A3 CA 00 70       jp z, History.back
  33++66A6 FE 32            cp '2'
  33++66A8 CA BB 65       jp z, navigate
  34++66AB FE 35            cp '5'
  34++66AD CA 13 67       jp z, textUp
  35++66B0 FE 38            cp '8'
  35++66B2 CA 03 67       jp z, textDown
  36++66B5 FE 08            cp Console.KEY_LT
  36++66B7 CA 13 67       jp z, textUp
  37++66BA FE 09            cp Console.KEY_RT
  37++66BC CA 03 67       jp z, textDown
  38++66BF
  39++66BF FE 0A            cp Console.KEY_DN
  39++66C1 CA 03 67       jp z, textDown
  40++66C4 FE 61            cp 'a'
  40++66C6 CA 03 67       jp z, textDown
  41++66C9
  42++66C9 FE 0B            cp Console.KEY_UP
  42++66CB CA 13 67       jp z, textUp
  43++66CE FE 71            cp 'q'
  43++66D0 CA 13 67       jp z, textUp
  44++66D3
  45++66D3 FE 68            cp 'h'
  45++66D5 CA 6D 70       jp z, History.home
  46++66D8 FE 48            cp 'H'
  46++66DA CA 6D 70       jp z, History.home
  47++66DD
  48++66DD FE 62            cp 'b'
  48++66DF CA 00 70       jp z, History.back
  49++66E2 FE 42            cp 'B'
  49++66E4 CA 00 70       jp z, History.back
  50++66E7
  51++66E7 FE 64            cp 'd'
  51++66E9 CA D9 63       jp z, inputHost
  52++66EC FE 44            cp 'D'
  52++66EE CA D9 63       jp z, inputHost
  53++66F1
  54++66F1 FE 0C            cp Console.BACKSPACE
  54++66F3 CA 00 70       jp z, History.back
  55++66F6
  56++66F6                  IFDEF MSX
  57++66F6 ~                	cp ESC
  57++66F6 ~              jp z, exit
  58++66F6                  ENDIF
  59++66F6
  60++66F6                  IFDEF GS
  61++66F6 ~                cp 'M'
  61++66F6 ~              call z, GeneralSound.toggleModule
  62++66F6 ~                cp 'm'
  62++66F6 ~              call z, GeneralSound.toggleModule
  63++66F6                  ENDIF
  64++66F6
  65++66F6                  IFDEF TIMEX80
  66++66F6 FE 54            cp 'T'
  66++66F8 CC A5 61       call z, TextMode.toggleColor
  67++66FB FE 74            cp 't'
  67++66FD CC A5 61       call z, TextMode.toggleColor
  68++6700                  ENDIF
  69++6700
  70++6700 C3 9E 66         jp plainTextLoop
  71++6703
  72++6703
  73++6703              textDown:
  74++6703 2A 8E 74         ld hl,(page_offset)
  75++6706 11 16 00         ld de,PER_PAGE
  76++6709 19               add hl,de
  77++670A 22 8E 74         ld (page_offset), hl
  78++670D CD 6E 66         call renderPlainTextScreen
  79++6710 C3 9E 66         jp plainTextLoop
  80++6713
  81++6713              textUp:
  82++6713 3A 8E 74         ld a, (page_offset)
  82++6716 FE 00          cp 0
  82++6718 20 0A          jr nz, .textUp2
  83++671A 3A 8F 74         ld a, (page_offset + 1)
  83++671D FE 00          cp 0
  83++671F 20 03          jr nz, .textUp2
  84++6721 C3 9E 66         jp plainTextLoop
  85++6724
  86++6724              .textUp2:
  87++6724 2A 8E 74         ld hl,(page_offset)
  88++6727 11 16 00         ld de,PER_PAGE
  89++672A ED 52            sbc hl,de
  90++672C 22 8E 74         ld (page_offset), hl
  91++672F CD 6E 66         call renderPlainTextScreen
  92++6732 C3 9E 66         jp plainTextLoop
  93++6735
# file closed: gopher/render/plaintext.asm
   9+ 6735
  10+ 6735 00           play_next       db  0
  11+ 6736              position        EQU historyBlock.position
  12+ 6736              cursor_position EQU position + 2
  13+ 6736              page_offset     EQU position + 4
  14+ 6736
  15+ 6736                  ENDMODULE
  16+ 6736
  17+ 6736                  include "dialogbox.asm"
# file opened: gopher/render/dialogbox.asm
   1++6736                  module DialogBox
   2++6736
   3++6736              inputBox:
   4++6736 AF               xor a
   4++6737 32 91 67       ld (inputBuffer), a
   5++673A              .noclear
   6++673A CD F2 67         call drawBox
   7++673D              .loop
   8++673D 11 05 0B         ld de, #0B05
   8++6740 CD 88 61       call TextMode.gotoXY
   9++6743 21 91 67         ld hl, inputBuffer
   9++6746 CD 83 60       call TextMode.printZ
  10++6749 3E B3            ld a, MIME_INPUT
  10++674B CD 8E 60       call TextMode.putC
  10++674E 3E 20          ld a, ' '
  10++6750 CD 8E 60       call TextMode.putC
  11++6753              .checkkey
  12++6753 CD 26 68         call Console.getC
  13++6756 FE 0C            cp Console.BACKSPACE
  13++6758 28 16          jr z, .removeChar
  14++675A FE 0D        	cp CR
  14++675C C8             ret z
  15++675D FE 20            cp SPACE
  15++675F 38 F2          jr c, .checkkey
  16++6761              .putC
  17++6761 5F               ld e, a
  18++6762 AF               xor a
  18++6763 21 91 67 01    ld hl, inputBuffer, bc, #ff
  18++6767 FF 00
  18++6769 ED B1          cpir
  19++676B 77               ld (hl), a
  19++676C 2B             dec hl
  19++676D 73             ld (hl), e
  20++676E 18 CD            jr .loop
  21++6770              .removeChar
  22++6770 AF               xor a
  23++6771 21 91 67 01      ld hl, inputBuffer, bc, #ff
  23++6775 FF 00
  23++6777 ED B1          cpir
  24++6779 E5               push hl
  25++677A 11 92 67             ld de, inputBuffer + 1
  26++677D B7                   or a
  26++677E ED 52          sbc hl, de
  27++6780 7C                   ld a, h
  27++6781 B5             or l
  28++6782 E1               pop hl
  29++6783 28 B8            jr z, .loop
  30++6785 AF               xor a
  31++6786 2B               dec hl
  31++6787 2B             dec hl
  31++6788 77             ld (hl), a
  32++6789 18 B2            jr .loop
  33++678B
  34++678B              	IFNDEF MSX
  35++678B              delayinput:
  36++678B 06 32           ld b, 50
  37++678D              .loop2
  38++678D 76               halt
  39++678E 10 FD            djnz .loop2
  40++6790 C9               ret
  41++6791              namedownload
  42++6791                  IFDEF NEDOOS
  43++6791 ~            		db "..",92,"downloads",92
  44++6791                  ENDIF
  45++6791                  ENDIF
  46++6791 00 00 00...  inputBuffer ds 80
  47++67E1
  48++67E1              msgBox:
  49++67E1 CD EA 67         call msgNoWait
  50++67E4 06 96            ld b, 150
  51++67E6              .loop
  52++67E6 76               halt
  53++67E7 10 FD            djnz .loop
  54++67E9 C9               ret
  55++67EA
  56++67EA              msgNoWait:
  57++67EA E5               push hl
  58++67EB CD F2 67         call drawBox
  59++67EE E1               pop hl
  60++67EF C3 83 60         jp TextMode.printZ
  61++67F2
  62++67F2              drawBox:
  63++67F2 26 0A 3E B2      ld h, #0a, a, BORDER_TOP
  64++67F6 CD 76 61         call TextMode.fillLine
  65++67F9 26 0B 3E 20      ld h, #0b, a, ' '
  66++67FD CD 76 61         call TextMode.fillLine
  67++6800 26 0C 3E B1      ld h, #0c, a, BORDER_BOTTOM
  68++6804 CD 76 61         call TextMode.fillLine
  69++6807 3E 0A            ld a, #0a
  70++6809 CD 61 60         call TextMode.highlightLine
  71++680C 3E 0C            ld a, #0c
  72++680E CD 61 60         call TextMode.highlightLine
  73++6811 11 03 0B         ld de,#0B03
  74++6814 CD 88 61         call TextMode.gotoXY
  75++6817 C9               ret
  76++6818                  endmodule
  77++6818
# file closed: gopher/render/dialogbox.asm
# file closed: gopher/render/index.asm
  31  6818                  include "dos/index.asm"
# file opened: dos/index.asm
   1+ 6818              	IFDEF NEDOOS
   2+ 6818 ~            	    include "nedoconsole.asm"
   3+ 6818 ~            		include "nedoos.asm"
   4+ 6818              	ENDIF
   5+ 6818
   6+ 6818              	IFDEF TRDOS
   7+ 6818                  	include "console.asm"
# file opened: dos/console.asm
   1++6818                  module Console
   2++6818              KEY_UP = 11
   3++6818              KEY_DN = 10
   4++6818              KEY_LT = 8
   5++6818              KEY_RT = 9
   6++6818              BACKSPACE = 12
   7++6818 00           keyCode db 0
   8++6819
   9++6819              BASIC_KEY = #5C08
  10++6819
  11++6819              waitForKeyUp:
  12++6819 76           	halt
  13++681A AF              xor a
  13++681B DB FE          in a, (#fe)
  13++681D 2F             cpl
  13++681E E6 1F          and 31
  13++6820 20 F7          jr nz, waitForKeyUp
  14++6822 32 08 5C        ld (BASIC_KEY), a
  15++6825 C9              ret
  16++6826
  17++6826              getC:
  18++6826 AF              xor a
  19++6827 32 08 5C        ld (BASIC_KEY),a
  20++682A              getC2:
  21++682A 3A 08 5C        ld a,(BASIC_KEY)
  22++682D A7              and a
  22++682E 28 FA          jr z, getC2
  23++6830 47              ld b,a
  24++6831 AF              xor a
  24++6832 32 08 5C       ld (BASIC_KEY), a
  25++6835 78              ld a, b
  26++6836 C9              ret
  27++6837
  28++6837              peekC:
  29++6837 AF               xor a
  29++6838 32 08 5C       ld (BASIC_KEY),a
  30++683B CD 3F 68         call inkey
  31++683E C9               ret
  32++683F
  33++683F              inkey:
  34++683F 11 00 00        ld de,0
  35++6842 01 FE FE        ld bc,$fefe
  36++6845 ED 78           in a,(c)
  37++6847 F6 E1           or $e1
  38++6849 FE FF           cp $ff
  39++684B 20 57           jr nz, .keyhitA
  40++684D
  41++684D 1E 05           ld e,5
  42++684F 06 FD           ld b,$fd
  43++6851 ED 78           in a,(c)
  44++6853 F6 E0           or $e0
  45++6855 FE FF           cp $ff
  46++6857 20 4B           jr nz, .keyhitA
  47++6859
  48++6859 1E 0A           ld e,10
  49++685B 06 FB           ld b,$fb
  50++685D ED 78           in a,(c)
  51++685F F6 E0           or $e0
  52++6861 FE FF           cp $ff
  53++6863 20 3F           jr nz, .keyhitA
  54++6865
  55++6865 1E 0F           ld e,15
  56++6867 06 F7           ld b,$f7
  57++6869 ED 78           in a,(c)
  58++686B F6 E0           or $e0
  59++686D FE FF           cp $ff
  60++686F 20 33           jr nz, .keyhitA
  61++6871
  62++6871 1E 14           ld e,20
  63++6873 06 EF           ld b,$ef
  64++6875 ED 78           in a,(c)
  65++6877 F6 E0           or $e0
  66++6879 FE FF           cp $ff
  67++687B 20 27           jr nz, .keyhitA
  68++687D
  69++687D 1E 19           ld e,25
  70++687F 06 DF           ld b,$df
  71++6881 ED 78           in a,(c)
  72++6883 F6 E0           or $e0
  73++6885 FE FF           cp $ff
  74++6887 20 1B           jr nz, .keyhitA
  75++6889
  76++6889 1E 1E           ld e,30
  77++688B 06 BF           ld b,$bf
  78++688D ED 78           in a,(c)
  79++688F F6 E0           or $e0
  80++6891 FE FF           cp $ff
  81++6893 20 0F           jr nz, .keyhitA
  82++6895
  83++6895 1E 23           ld e,35
  84++6897 06 7F           ld b,$7f
  85++6899 ED 78           in a,(c)
  86++689B F6 E2           or $e2
  87++689D FE FF           cp $ff
  88++689F 4F              ld c,a
  89++68A0 20 19           jr nz, .keyhitB
  90++68A2
  91++68A2              .nokey
  92++68A2 AF              xor a
  93++68A3 C9              ret
  94++68A4
  95++68A4              .keyhitA
  96++68A4
  97++68A4 4F              ld c,a
  98++68A5
  99++68A5 78              ld a,b
 100++68A6 2F              cpl
 101++68A7 F6 81           or $81
 102++68A9 DB FE           in a,($fe)
 103++68AB F6 E0           or $e0
 104++68AD FE FF           cp $ff
 105++68AF 20 F1           jr nz, .nokey
 106++68B1
 107++68B1 3E 7F           ld a,$7f
 108++68B3 DB FE           in a,($fe)
 109++68B5 F6 E2           or $e2
 110++68B7 FE FF           cp $ff
 111++68B9 20 E7           jr nz, .nokey
 112++68BB
 113++68BB              .keyhitB
 114++68BB
 115++68BB 06 00           ld b,0
 116++68BD 21 04 68        ld hl,.rowtbl-$e0
 117++68C0 09              add hl,bc
 118++68C1 7E              ld a,(hl)
 119++68C2 FE 05           cp 5
 120++68C4 30 DC           jr nc, .nokey
 121++68C6 83              add a,e
 122++68C7 5F              ld e,a
 123++68C8
 124++68C8 21 04 69        ld hl,.table
 125++68CB 19              add hl,de
 126++68CC
 127++68CC 3E FE           ld a,$fe
 128++68CE DB FE           in a,($fe)
 129++68D0 E6 01           and $01
 130++68D2 20 03           jr nz, .nocaps
 131++68D4 1E 28           ld e,40
 132++68D6 19              add hl,de
 133++68D7
 134++68D7              .nocaps
 135++68D7
 136++68D7 3E 7F           ld a,$7f
 137++68D9 DB FE           in a,($fe)
 138++68DB E6 02           and $02
 139++68DD 20 03           jr nz, .nosym
 140++68DF 1E 50           ld e,80
 141++68E1 19              add hl,de
 142++68E2
 143++68E2              .nosym
 144++68E2
 145++68E2 7E              ld a,(hl)
 146++68E3 C9              ret
 147++68E4
 148++68E4              .rowtbl
 149++68E4 FF FF FF FF     defb 255,255,255,255,255,255,255
 149++68E8 FF FF FF
 150++68EB FF FF FF FF     defb 255,255,255,255,255,255,255,255
 150++68EF FF FF FF FF
 151++68F3 04 FF FF FF     defb 4,255,255,255,255,255,255
 151++68F7 FF FF FF
 152++68FA FF 03 FF FF     defb 255,3,255,255,255,2,255,1
 152++68FE FF 02 FF 01
 153++6902 00 FF           defb 0,255
 154++6904
 155++6904              .table
 156++6904 00 7A 78 63     db 0,'z','x','c','v'      ; CAPS SHIFT, Z, X, C, V
 156++6908 76
 157++6909 61 73 64 66     db 'a','s','d','f','g'      ; A, S, D, F, G
 157++690D 67
 158++690E 71 77 65 72     db 'q','w','e','r','t'      ; Q, W, E, R, T
 158++6912 74
 159++6913 31 32 33 34     db '1','2','3','4','5'      ; 1, 2, 3, 4, 5
 159++6917 35
 160++6918 30 39 38 37     db '0','9','8','7','6'      ; 0, 9, 8, 7, 6
 160++691C 36
 161++691D 70 6F 69 75     db 'p','o','i','u','y'      ; P, O, I, U, Y
 161++6921 79
 162++6922 0D 6C 6B 6A     db 13,'l','k','j','h'       ; ENTER, L, K, J, H
 162++6926 68
 163++6927 20 00 6D 6E     db ' ',0,'m','n','b'      ; SPACE, SYM SHIFT, M, N, B
 163++692B 62
 164++692C
 165++692C                 ; the following are CAPS SHIFTed
 166++692C
 167++692C 00 5A 58 43     db 0,'Z','X','C','V'      ; CAPS SHIFT, Z, X, C, V
 167++6930 56
 168++6931 41 53 44 46     db 'A','S','D','F','G'      ; A, S, D, F, G
 168++6935 47
 169++6936 51 57 45 52     db 'Q','W','E','R','T'      ; Q, W, E, R, T
 169++693A 54
 170++693B 07 06 80 81     db 7,6,128,129,8            ; 1, 2, 3, 4, 5
 170++693F 08
 171++6940 0C 00 09 0B     db 12,0,9,11,10             ; 0, 9, 8, 7, 6
 171++6944 0A
 172++6945 50 4F 49 55     db 'P','O','I','U','Y'      ; P, O, I, U, Y
 172++6949 59
 173++694A 0D 4C 4B 4A     db 13,'L','K','J','H'       ; ENTER, L, K, J, H
 173++694E 48
 174++694F 20 00 4D 4E     db ' ',0,'M','N','B'      ; SPACE, SYM SHIFT, M, N, B
 174++6953 42
 175++6954
 176++6954                 ; the following are SYM SHIFTed
 177++6954
 178++6954 00 3A 60 3F     db 0,':',96,'?','/'       ; CAPS SHIFT, Z, X, C, V
 178++6958 2F
 179++6959 7E 7C 5C 7B     db '~','|',92,'{','}'       ; A, S, D, F, G
 179++695D 7D
 180++695E 83 84 85 3C     db 131,132,133,'<','>'      ; Q, W, E, R, T
 180++6962 3E
 181++6963 21 40 23 24     db '!','@','#','$','%'      ; 1, 2, 3, 4, 5
 181++6967 25
 182++6968 5F 29 28 27     db '_',')','(',39,'&'       ; 0, 9, 8, 7, 6
 182++696C 26
 183++696D 22 3B 82 5D     db 34,';',130,']','['       ; P, O, I, U, Y
 183++6971 5B
 184++6972 0D 3D 2B 2D     db 13,'=','+','-','^'       ; ENTER, L, K, J, H
 184++6976 5E
 185++6977 20 00 2E 2C     db ' ',0,'.',',','*'      ; SPACE, SYM SHIFT, M, N, B
 185++697B 2A
 186++697C
 187++697C                 ; the following are CAPS SHIFTed and SYM SHIFTed ("CTRL" key)
 188++697C
 189++697C 00 1A 18 03     db 0,26,24,3,22           ; CAPS SHIFT, Z, X, C, V
 189++6980 16
 190++6981 01 13 04 06     db 1,19,4,6,7               ; A, S, D, F, G
 190++6985 07
 191++6986 11 17 05 12     db 17,23,5,18,20            ; Q, W, E, R, T
 191++698A 14
 192++698B 1B 1C 1D 1E     db 27,28,29,30,31           ; 1, 2, 3, 4, 5
 192++698F 1F
 193++6990 7F 00 86 60     db 127,0,134,'`',135      ; 0, 9, 8, 7, 6
 193++6994 87
 194++6995 10 0F 09 15     db 16,15,9,21,25            ; P, O, I, U, Y
 194++6999 19
 195++699A 0D 0C 0B 0A     db 13,12,11,10,8            ; ENTER, L, K, J, H
 195++699E 08
 196++699F 20 00 0D 0E     db ' ',0,13,14,2          ; SPACE, SYM SHIFT, M, N, B
 196++69A3 02
 197++69A4
 198++69A4                  endmodule
# file closed: dos/console.asm
   8+ 69A4              		include "trdos.asm"
# file opened: dos/trdos.asm
   1++69A4              ;trdos driver (izzx)
   2++69A4                  MODULE Dos
   3++69A4              ; API methods
   4++69A4              ESX_GETSETDRV = #89
   5++69A4              ESX_FOPEN = #9A
   6++69A4              ESX_FCLOSE = #9B
   7++69A4              ESX_FSYNC = #9C
   8++69A4              ESX_FREAD = #9D
   9++69A4              ESX_FWRITE = #9E
  10++69A4
  11++69A4              ; File modes
  12++69A4              FMODE_READ = #01
  13++69A4              FMODE_WRITE = #06
  14++69A4              FMODE_CREATE = #0E
  15++69A4
  16++69A4                  ; MACRO esxCall func
  17++69A4                  ; rst #8 : db func
  18++69A4                  ; ENDM
  19++69A4
  20++69A4              ;id = 0 файл не открыт
  21++69A4              ;id = 1 файл для чтения
  22++69A4              ;id = 2 файл для записи
  23++69A4              ;id = 3 файл для записи тип TRD
  24++69A4              ;id = 4 файл для записи тип SCL
  25++69A4
  26++69A4              ; HL - filename in ASCIIZ
  27++69A4              loadBuffer:
  28++69A4 06 01            ld b, Dos.FMODE_READ
  28++69A6 CD C0 69       call Dos.fopen
  29++69A9 F5               push af
  30++69AA 21 F5 9A 01          ld hl, outputBuffer, bc, #ffff - outputBuffer
  30++69AE 0A 65
  30++69B0 CD AD 6A       call Dos.fread
  31++69B3 21 F5 9A             ld hl, outputBuffer
  31++69B6 09             add hl, bc
  31++69B7 AF             xor a
  31++69B8 77             ld (hl), a
  31++69B9 23             inc hl
  31++69BA 77             ld (hl), a
  32++69BB F1               pop af
  33++69BC CD 99 6A         call Dos.fclose
  34++69BF C9               ret
  35++69C0
  36++69C0
  37++69C0              ; Returns:
  38++69C0              ;  A - current drive
  39++69C0              ; getDefaultDrive: ;нигде не используется
  40++69C0                  ; ld a, 0 : esxCall ESX_GETSETDRV
  41++69C0                  ; ret
  42++69C0
  43++69C0
  44++69C0
  45++69C0              ; Opens file on default drive
  46++69C0              ; B - File mode
  47++69C0              ; HL - File name
  48++69C0              ; Returns:
  49++69C0              ;  A - file stream id
  50++69C0              fopen:
  51++69C0                  ; push bc : push hl
  52++69C0                  ; call getDefaultDrive
  53++69C0                  ; pop ix : pop bc
  54++69C0                  ; esxCall ESX_FOPEN
  55++69C0                  ; ret
  56++69C0 78           	ld a,b
  57++69C1 FE 01        	cp FMODE_READ ;если режим открытие файла
  58++69C3 28 06        	jr z,fopen_r
  59++69C5 FE 0E        	cp FMODE_CREATE
  60++69C7 28 39        	jr z,fopen_c ;если режим создание файла
  61++69C9 18 34        	jr fopen_err ;иначе выход
  62++69CB
  63++69CB              fopen_r	;открытие существующего файла на чтение (id=1)
  64++69CB CD 30 6E     			call format_name ;
  65++69CE 0E 13        			ld      c,#13 ;move file info to syst var
  66++69D0 CD 13 3D                 call    #3d13
  67++69D3 0E 0A                    ld      c,#0a ;find file
  68++69D5 CD 13 3D                 call    #3d13
  69++69D8 79                       ld      a,c
  70++69D9 FE FF        			cp 		#ff
  71++69DB 28 22        			jr 		z,fopen_err ;если не нашли файла
  72++69DD 0E 08                    ld      c,#08 ;read file title
  73++69DF CD 13 3D                 call    #3d13
  74++69E2                          ;ld      hl,loadadr ;куда
  75++69E2 ED 5B EB 5C              ld      de,(#5ceb) ;начало файла сектор дорожка
  76++69E6 ED 53 DC 6E              ld      (f_r_cur_trk),de
  77++69EA
  78++69EA 3A EA 5C                 ld      a,(#5cea)
  79++69ED 32 DE 6E                 ld      (f_r_len_sec),a ;длина в секторах
  80++69F0                          ;or      a
  81++69F0                          ;ret     z    ;выход если пустой
  82++69F0
  83++69F0 ED 5B E8 5C  			ld de,(#5CE8) ; длина файла или программной части для BASIC
  84++69F4 ED 53 DF 6E  			ld      (f_r_len),de
  85++69F8
  86++69F8                          ; ld      de,(fcurtrk) ;текущие сектор дорожка
  87++69F8                          ; ld      (#5cf4),de ;восстановим
  88++69F8 AF           			xor a
  89++69F9 3E 01        			ld 		a,1
  90++69FB 32 E1 6E     			ld (f_r_flag),a ;флаг что файл для чтения открыт
  91++69FE              			;id канала будет 1
  92++69FE C9           	ret
  93++69FF
  94++69FF              fopen_err
  95++69FF AF           	xor a ;если никакой файл не открыли, то id = 0
  96++6A00 37           	scf ;флаг ошибки
  97++6A01 C9           	ret
  98++6A02
  99++6A02
 100++6A02              fopen_c	;создание нового файла (id=2-4)
 101++6A02 CD 30 6E     	call format_name ;
 102++6A05              	;выясним, не образ ли это для разворачивания
 103++6A05 21 BF 6E         ld hl, trdExt1
 103++6A08 CD 27 62       call CompareBuff.search
 103++6A0B A7             and a
 103++6A0C 20 1D          jr nz, fopen_c_trd
 104++6A0E 21 C4 6E         ld hl, trdExt2
 104++6A11 CD 27 62       call CompareBuff.search
 104++6A14 A7             and a
 104++6A15 20 14          jr nz, fopen_c_trd
 105++6A17 21 C9 6E     	ld hl, sclExt1
 105++6A1A CD 27 62       call CompareBuff.search
 105++6A1D A7             and a
 105++6A1E 20 3A          jr nz, fopen_c_scl
 106++6A20 21 CE 6E         ld hl, sclExt2
 106++6A23 CD 27 62       call CompareBuff.search
 106++6A26 A7             and a
 106++6A27 20 31          jr nz, fopen_c_scl
 107++6A29
 108++6A29
 109++6A29              fopen_c_2	;создание произвольного файла
 110++6A29 18 D4        	jr 		fopen_err ;пока отключено
 111++6A2B
 112++6A2B              	; ld      c,#13 ;move file info to syst var
 113++6A2B                  ; call    #3d13
 114++6A2B              	; ld de,256 ;запишем пока 1 сектор
 115++6A2B              	; ld hl,#4000 ;возьмём случайные данные из экрана
 116++6A2B                  ; ld      c,#0b ;запись файла CODE
 117++6A2B                  ; call    #3d13
 118++6A2B                  ; ld      a,c
 119++6A2B              	; cp 		#ff
 120++6A2B              	; jr 		z,fopen_err ;если ошибка
 121++6A2B
 122++6A2B                  ; ld      de,(#5ceb) ;начало файла сектор дорожка
 123++6A2B                  ; ld      (f_w_cur_trk),de
 124++6A2B                  ; ld      a,(#5cea)
 125++6A2B                  ; ld      (f_w_len_sec),a ;длина в секторах
 126++6A2B              	; xor a ;id канала будет 2
 127++6A2B              	; ld a,2
 128++6A2B              	; ld (f_w_flag),a ;флаг что файл для записи открыт
 129++6A2B              	; ret
 130++6A2B
 131++6A2B
 132++6A2B
 133++6A2B
 134++6A2B
 135++6A2B              fopen_c_trd	;открытие файла для разворачивания образа trd (id=3)
 136++6A2B 3A 19 5D     	ld a,(#5D19) ;номер дисковода по умолчанию
 137++6A2E C6 41        	add a,"A"
 138++6A30 32 A5 6E     	ld (write_ima_d),a ;подставим букву в запросе
 139++6A33 21 90 6E         ld hl, write_ima
 140++6A36 CD E1 67         call DialogBox.msgBox ;предуреждение
 141++6A39              WAITKEY_trd
 142++6A39 3A 04 5C     	ld 		a,(23556)
 143++6A3C FE FF        	cp 255
 144++6A3E 28 F9        	JR Z,WAITKEY_trd	;ждём любую клавишу
 145++6A40
 146++6A40 11 00 00     	ld      de,0 ;начало сектор дорожка
 147++6A43 ED 53 F4 5C      ld      (#5cf4),de
 148++6A47 AF           	xor a
 149++6A48 32 F1 6E     	ld (sec_shift),a ;переменная
 150++6A4B 21 00 00     	ld hl,0
 151++6A4E 22 E6 6E     	ld (f_w_len+0),hl
 152++6A51 22 E8 6E     	ld (f_w_len+2),hl
 153++6A54 3E 03        	ld a,3 ;id канала
 154++6A56 32 E5 6E     	ld (f_w_flag),a ;флаг что trd для записи открыт
 155++6A59 C9           	ret
 156++6A5A
 157++6A5A
 158++6A5A
 159++6A5A
 160++6A5A              fopen_c_scl	;открытие файла для разворачивания образа scl (id=4)
 161++6A5A 3A 19 5D     	ld a,(#5D19) ;номер дисковода по умолчанию
 162++6A5D C6 41        	add a,"A"
 163++6A5F 32 A5 6E     	ld (write_ima_d),a ;подставим букву в запросе
 164++6A62 21 90 6E         ld hl, write_ima
 165++6A65 CD E1 67         call DialogBox.msgBox ;предуреждение
 166++6A68              WAITKEY_scl
 167++6A68 3A 04 5C     	ld 		a,(23556)
 168++6A6B FE FF        	cp 255
 169++6A6D 28 F9        	JR Z,WAITKEY_scl	;ждём любую клавишу
 170++6A6F
 171++6A6F 11 00 00     	ld      de,0 ;начало сектор дорожка
 172++6A72 ED 53 F4 5C      ld      (#5cf4),de
 173++6A76
 174++6A76 21 00 48     	ld hl,cat_buf ;очистить место для каталога дискеты
 175++6A79 11 01 48     	ld de,cat_buf+1
 176++6A7C 36 00        	ld (hl),0
 177++6A7E 01 FF 08     	ld bc,9*256-1
 178++6A81 ED B0        	ldir
 179++6A83
 180++6A83 CD A5 6C     	call scl_parse ;запуск цикла сборки образа
 181++6A86
 182++6A86 AF           	xor a
 183++6A87 32 F1 6E     	ld (sec_shift),a ;переменная
 184++6A8A              	;ld (scl_que),a
 185++6A8A 21 00 00     	ld hl,0
 186++6A8D 22 E6 6E     	ld (f_w_len+0),hl
 187++6A90 22 E8 6E     	ld (f_w_len+2),hl
 188++6A93 3E 04        	ld a,4 ;id канала
 189++6A95 32 E5 6E     	ld (f_w_flag),a ;флаг что scl для записи открыт
 190++6A98 C9           	ret
 191++6A99
 192++6A99
 193++6A99
 194++6A99              ; A - file stream id
 195++6A99              fclose:
 196++6A99                  ;esxCall ESX_FCLOSE
 197++6A99              	; push af
 198++6A99              ; WAITKEY2	XOR A:IN A,(#FE):CPL:AND #1F:JR Z,WAITKEY2
 199++6A99              	; pop af
 200++6A99 FE 04        	cp 4 ;если scl
 201++6A9B 20 08        	jr nz,fclose2
 202++6A9D 21 00 51     	ld hl,sec_buf ;
 203++6AA0 06 01        	ld b,1
 204++6AA2 CD 84 6C     	call scl_write_buf ;допишем остаток scl, если есть
 205++6AA5
 206++6AA5              fclose2
 207++6AA5 AF           	xor a ;как бы закрываем все файлы
 208++6AA6 32 E1 6E     	ld (f_r_flag),a
 209++6AA9 32 E5 6E     	ld (f_w_flag),a
 210++6AAC C9               ret
 211++6AAD
 212++6AAD
 213++6AAD
 214++6AAD
 215++6AAD              ; A - file stream id
 216++6AAD              ; BC - length
 217++6AAD              ; HL - buffer
 218++6AAD              ; Returns
 219++6AAD              ;  BC - length(how much was actually read)
 220++6AAD              fread: ;(id=1)
 221++6AAD                  ; push hl : pop ix
 222++6AAD                  ; esxCall ESX_FREAD
 223++6AAD              	; push af
 224++6AAD              	; ld a,4
 225++6AAD              	; out (254),a
 226++6AAD              ; WAITKEY	XOR A:IN A,(#FE):CPL:AND #1F:JR Z,WAITKEY
 227++6AAD              	; xor a
 228++6AAD              	; out (254),a
 229++6AAD              	; pop af
 230++6AAD
 231++6AAD FE 01        	cp 1 ;id = 1?
 232++6AAF 20 06        	jr nz,fread_no_chek ;выход если номер потока не = 1
 233++6AB1 3A E1 6E     	ld a,(f_r_flag)
 234++6AB4 B7           	or a
 235++6AB5 20 06        	jr nz,fread_chek ;файл уже открыт?
 236++6AB7              fread_no_chek ;выход с ошибкой
 237++6AB7 AF           	xor a
 238++6AB8 37           	scf ;флаг ошибки
 239++6AB9 01 00 00     	ld bc,0 ;ничего мы не считали
 240++6ABC C9           	ret
 241++6ABD
 242++6ABD              fread_chek
 243++6ABD ED 4B DD 6E  	ld bc,(f_r_len_sec-1) ;загружаем файл целиком, не смотря на то, сколько байт было запрошено
 244++6AC1 0E 05            ld      c,5 ;read читаем целыми секторами
 245++6AC3 ED 5B DC 6E  	ld de,(f_r_cur_trk)
 246++6AC7 CD 13 3D         call    #3d13
 247++6ACA ED 4B DF 6E  	ld bc,(f_r_len) ;возвратим сколько считали байт (длину файла)
 248++6ACE AF           	xor a ;флаги сбросим
 249++6ACF C9               ret
 250++6AD0
 251++6AD0              ; A - file stream id
 252++6AD0              ; BC - length
 253++6AD0              ; HL - buffer
 254++6AD0              ; Returns:
 255++6AD0              ;   BC - actually written bytes
 256++6AD0              fwrite: ;
 257++6AD0                  ; push hl : pop ix
 258++6AD0                  ; esxCall ESX_FWRITE
 259++6AD0
 260++6AD0              	; push af
 261++6AD0              	; ld a,2
 262++6AD0              	; out (254),a
 263++6AD0              ; WAITKEY1	XOR A:IN A,(#FE):CPL:AND #1F:JR Z,WAITKEY1
 264++6AD0              	; xor a
 265++6AD0              	; out (254),a
 266++6AD0              	; pop af
 267++6AD0
 268++6AD0 FE 02        	cp 2 ;id = 2?
 269++6AD2 28 0F        	jr z,fwrite_chek ;проверка id потока
 270++6AD4 FE 03        	cp 3 ;id = 3?
 271++6AD6 28 0D        	jr z,fwrite_chek_trd ;проверка id потока
 272++6AD8 FE 04        	cp 4 ;id = 4?
 273++6ADA CA BF 6B     	jp z,fwrite_chek_scl ;проверка id потока
 274++6ADD
 275++6ADD
 276++6ADD              fwrite_no_chek ;выход с ошибкой
 277++6ADD AF           	xor a
 278++6ADE 37           	scf ;флаг ошибки
 279++6ADF 01 00 00     	ld bc,0 ;ничего мы не записали
 280++6AE2 C9           	ret
 281++6AE3
 282++6AE3              fwrite_chek ;запись произвольного типа файла
 283++6AE3 18 F8        	jr fwrite_no_chek ;пока отключено
 284++6AE5              	; ld a,(f_w_flag)
 285++6AE5              	; or a
 286++6AE5              	; jr z,fwrite_no_chek ;файл уже открыт?
 287++6AE5              	; ld (temp_bc),bc
 288++6AE5              	; ;ld bc,(f_r_len_sec-1) ;
 289++6AE5                  ; ld      c,6 ;пишем целыми секторами
 290++6AE5              	; ld de,(f_w_cur_trk)
 291++6AE5                  ; call    #3d13
 292++6AE5              	; ld bc,(temp_bc) ;возвратим, что сколько запрашивали, столько и считали байт
 293++6AE5              	; xor a ;флаги сбросим
 294++6AE5                  ; ret
 295++6AE5
 296++6AE5
 297++6AE5
 298++6AE5
 299++6AE5
 300++6AE5              fwrite_chek_trd ;запись trd файла (разворачивание образа)
 301++6AE5              	; ld a,2
 302++6AE5              	; out (254),a
 303++6AE5              ; WAITKEY_t	XOR A:IN A,(#FE):CPL:AND #1F:JR Z,WAITKEY_t
 304++6AE5              	; xor a
 305++6AE5              	; out (254),a
 306++6AE5 3A E5 6E     	ld a,(f_w_flag)
 307++6AE8 B7           	or a
 308++6AE9 28 F2        	jr z,fwrite_no_chek ;файл уже открыт?
 309++6AEB ED 43 EB 6E  	ld (temp_bc),bc ;длина
 310++6AEF 22 ED 6E     	ld (temp_hl),hl ;адрес данных
 311++6AF2 78           	ld a,b
 312++6AF3 B1           	or c
 313++6AF4 28 E7        	jr z,fwrite_no_chek ; если длина 0, то выход
 314++6AF6
 315++6AF6              	; ld a,b
 316++6AF6              	; or a
 317++6AF6              	; jr nz,testt1
 318++6AF6              	; nop
 319++6AF6
 320++6AF6              ; testt1
 321++6AF6
 322++6AF6 AF           	xor a
 323++6AF7 32 F3 6E     	ld (sec_part),a ;обнулить переменные
 324++6AFA 32 F2 6E     	ld (sec_shift2),a
 325++6AFD 32 F3 6E     	ld (sec_shift2+1),a
 326++6B00 32 F4 6E     	ld (sec_shift_flag),a
 327++6B03 32 EA 6E     	ld (write_end_flag),a ;
 328++6B06
 329++6B06
 330++6B06 3A F1 6E     	ld a,(sec_shift)
 331++6B09 B7           	or a
 332++6B0A 28 43        	jr z,fwrite_trd3 ;если смещения нет, то первую часть пропустим
 333++6B0C
 334++6B0C
 335++6B0C 4F           	ld c,a
 336++6B0D 06 00        	ld b,0
 337++6B0F 2A EB 6E     	ld hl,(temp_bc) ;проверка заполнится ли целый сектор
 338++6B12 09           	add hl,bc
 339++6B13
 340++6B13 3E 01        	ld a,1
 341++6B15 32 EA 6E     	ld (write_end_flag),a ;флаг что не нужно дописывать остаток
 342++6B18
 343++6B18 7C           	ld a,h
 344++6B19 B7           	or a
 345++6B1A 20 05        	jr nz,fwrite_trd4
 346++6B1C 3E 01        	ld a,1
 347++6B1E 32 F4 6E     	ld (sec_shift_flag),a ;флаг что не заполнен сектор
 348++6B21
 349++6B21              fwrite_trd4
 350++6B21 21 00 51     	ld hl,sec_buf ;буфер последнего сектора
 351++6B24 09           	add hl,bc ;на этой точке остановились
 352++6B25 EB           	ex de,hl
 353++6B26 2A ED 6E     	ld hl,(temp_hl) ;присоединим начало данных в конец предыдущих
 354++6B29              	; ld a,c
 355++6B29              	; or a
 356++6B29              	; jr nz,fwrite_trd2
 357++6B29              	; inc b ;коррекция
 358++6B29              ; fwrite_trd2
 359++6B29              	; ld c,a
 360++6B29 AF           	xor a
 361++6B2A 91           	sub c
 362++6B2B 4F           	ld c,a ;сколько осталось перенести до заполнения сектора
 363++6B2C ED 43 F2 6E  	ld (sec_shift2),bc ;сохраним сколько добавили байт
 364++6B30 ED B0        	ldir
 365++6B32
 366++6B32 3A F4 6E     	ld a,(sec_shift_flag)
 367++6B35 B7           	or a
 368++6B36 20 17        	jr nz,fwrite_trd3 ;если сектор ещё не заполнен писать не будем
 369++6B38
 370++6B38 21 00 51     	ld hl,sec_buf
 371++6B3B ED 5B F4 5C  	ld de,(#5cf4)
 372++6B3F              	;ld (f_w_cur_trk),de	;запомним позицию
 373++6B3F 01 06 01         ld      bc,#0106 ;пишем 1 сектор из буфера
 374++6B42 CD 13 3D         call    #3d13
 375++6B45 79           	ld a,c
 376++6B46 FE FF        	cp 255
 377++6B48 CA DD 6A     	jp z,fwrite_no_chek ;выход если ошибка
 378++6B4B
 379++6B4B AF           	xor a
 380++6B4C 32 EA 6E     	ld (write_end_flag),a ;флаг что нужно дописывать остаток
 381++6B4F              	; ld de,(f_w_cur_trk) ;если сектор ещё не заполнен, останемся на старой позиции
 382++6B4F              	; ld (#5cf4),de
 383++6B4F              	; ld b,1 ;на сектор вперёд
 384++6B4F              	; ld de,(f_w_cur_trk)
 385++6B4F              	; call calc_next_pos
 386++6B4F              	; ld (f_w_cur_trk),de
 387++6B4F
 388++6B4F              fwrite_trd3
 389++6B4F 2A ED 6E     	ld hl,(temp_hl) ;запишем остаток данных
 390++6B52              	;ld a,(sec_shift)
 391++6B52              	;ld c,a
 392++6B52              	;ld b,0
 393++6B52 ED 4B F2 6E  	ld bc,(sec_shift2)
 394++6B56 09           	add hl,bc ;с этой точки пишем
 395++6B57 22 EF 6E     	ld (temp_hl2),hl ;сохраним начало записи второго сектора
 396++6B5A
 397++6B5A 2A EB 6E     	ld hl,(temp_bc) ;вычисление на чём остановимся в этот раз
 398++6B5D A7           	and a
 399++6B5E ED 42        	sbc hl,bc ;вычтем то, что добавили к первому сектору
 400++6B60 4D           	ld c,l
 401++6B61 44           	ld b,h
 402++6B62 30 02        	jr nc,fwrite_trd5
 403++6B64 06 00        	ld b,0 ;коррекция если вышел минус
 404++6B66              fwrite_trd5
 405++6B66 2A ED 6E     	ld hl,(temp_hl)
 406++6B69 09           	add hl,bc
 407++6B6A
 408++6B6A 11 F5 9A     	ld de,outputBuffer
 409++6B6D A7           	and a
 410++6B6E ED 52        	sbc hl,de
 411++6B70
 412++6B70 7D           	ld a,l
 413++6B71 32 F1 6E     	ld (sec_shift),a ;смещение на следующий раз
 414++6B74              	;ld hl,(temp_hl)
 415++6B74
 416++6B74
 417++6B74              	; or a
 418++6B74              	; jr z,fwrite_trd1
 419++6B74              	; inc b  ;коррекция количества секторов
 420++6B74
 421++6B74 78           	ld a,b ;нужна проверка на количество секторов!!!
 422++6B75 32 F3 6E     	ld (sec_part),a ;запомним сколько секторов во второй части
 423++6B78
 424++6B78              	;ld a,b
 425++6B78 B7           	or a
 426++6B79 28 16        	jr z,fwrite_trd1 ;если размер данных меньше сектора, то пропустим запись
 427++6B7B
 428++6B7B 2A EF 6E     	ld hl,(temp_hl2)
 429++6B7E              	;push bc
 430++6B7E ED 5B F4 5C  	ld de,(#5cf4)
 431++6B82 0E 06            ld      c,6 ;пишем целыми секторами
 432++6B84 CD 13 3D         call    #3d13
 433++6B87 79           	ld a,c
 434++6B88              	;pop bc
 435++6B88 FE FF        	cp 255
 436++6B8A CA DD 6A     	jp z,fwrite_no_chek ;выход если ошибка
 437++6B8D              	; ld de,(f_w_cur_trk)
 438++6B8D              	; call calc_next_pos
 439++6B8D              	; ld (f_w_cur_trk),de
 440++6B8D
 441++6B8D AF           	xor a
 442++6B8E 32 EA 6E     	ld (write_end_flag),a ;флаг что нужно дописывать остаток
 443++6B91
 444++6B91              fwrite_trd1
 445++6B91 3A EA 6E     	ld a,(write_end_flag) ;нужно записывать остаток?
 446++6B94 B7           	or a
 447++6B95 20 12        	jr nz,fwrite_trd_ex ;не нужно
 448++6B97
 449++6B97 2A EF 6E     	ld hl,(temp_hl2) ;сохраним незаписанный остаток
 450++6B9A 3A F3 6E     	ld a,(sec_part)
 451++6B9D 47           	ld b,a
 452++6B9E 0E 00        	ld c,0
 453++6BA0 09           	add hl,bc
 454++6BA1 11 00 51     	ld de,sec_buf
 455++6BA4 01 00 01     	ld bc,256
 456++6BA7 ED B0        	ldir
 457++6BA9              ;fwrite_trd2
 458++6BA9
 459++6BA9
 460++6BA9              fwrite_trd_ex
 461++6BA9 ED 4B EB 6E  	ld bc,(temp_bc) ;возвратим, что сколько запрашивали, столько и записали байт
 462++6BAD              	;посчитаем общую длину записанного
 463++6BAD 2A E6 6E     	ld hl,(f_w_len)
 464++6BB0 09           	add hl,bc
 465++6BB1 22 E6 6E     	ld (f_w_len),hl
 466++6BB4 30 07        	jr nc,fwrite_trd_ex1
 467++6BB6 2A E8 6E     	ld hl,(f_w_len+2)
 468++6BB9 23           	inc hl
 469++6BBA 22 E8 6E     	ld (f_w_len+2),hl
 470++6BBD
 471++6BBD              fwrite_trd_ex1
 472++6BBD AF           	xor a ;флаги сбросим
 473++6BBE C9               ret
 474++6BBF
 475++6BBF
 476++6BBF
 477++6BBF
 478++6BBF
 479++6BBF              ;------------------scl----------------------
 480++6BBF              fwrite_chek_scl ;запись scl файла (разворачивание образа)
 481++6BBF              	; ld a,2
 482++6BBF              	; out (254),a
 483++6BBF              ; WAITKEY_t	XOR A:IN A,(#FE):CPL:AND #1F:JR Z,WAITKEY_t
 484++6BBF              	; xor a
 485++6BBF              	; out (254),a
 486++6BBF 3A E5 6E     	ld a,(f_w_flag)
 487++6BC2 B7           	or a
 488++6BC3 CA DD 6A     	jp z,fwrite_no_chek ;файл уже открыт?
 489++6BC6 ED 43 EB 6E  	ld (temp_bc),bc ;длина
 490++6BCA 22 ED 6E     	ld (temp_hl),hl ;адрес данных
 491++6BCD 78           	ld a,b
 492++6BCE B1           	or c
 493++6BCF CA DD 6A     	jp z,fwrite_no_chek ; если длина 0, то выход
 494++6BD2
 495++6BD2              	; ld a,b
 496++6BD2              	; or a
 497++6BD2              	; jr nz,testt1
 498++6BD2              	; nop
 499++6BD2
 500++6BD2              ; testt1
 501++6BD2
 502++6BD2 AF           	xor a
 503++6BD3 32 F3 6E     	ld (sec_part),a ;обнулить переменные
 504++6BD6 32 F2 6E     	ld (sec_shift2),a
 505++6BD9 32 F3 6E     	ld (sec_shift2+1),a
 506++6BDC 32 F4 6E     	ld (sec_shift_flag),a
 507++6BDF 32 EA 6E     	ld (write_end_flag),a ;
 508++6BE2
 509++6BE2
 510++6BE2 3A F1 6E     	ld a,(sec_shift)
 511++6BE5 B7           	or a
 512++6BE6 28 38        	jr z,fwrite_scl3 ;если смещения нет, то первую часть пропустим
 513++6BE8
 514++6BE8
 515++6BE8 4F           	ld c,a
 516++6BE9 06 00        	ld b,0
 517++6BEB 2A EB 6E     	ld hl,(temp_bc) ;проверка заполнится ли целый сектор
 518++6BEE 09           	add hl,bc
 519++6BEF
 520++6BEF 3E 01        	ld a,1
 521++6BF1 32 EA 6E     	ld (write_end_flag),a ;флаг что не нужно дописывать остаток
 522++6BF4
 523++6BF4 7C           	ld a,h
 524++6BF5 B7           	or a
 525++6BF6 20 05        	jr nz,fwrite_scl4
 526++6BF8 3E 01        	ld a,1
 527++6BFA 32 F4 6E     	ld (sec_shift_flag),a ;флаг что не заполнен сектор
 528++6BFD
 529++6BFD              fwrite_scl4
 530++6BFD 21 00 51     	ld hl,sec_buf ;буфер последнего сектора
 531++6C00 09           	add hl,bc ;на этой точке остановились
 532++6C01 EB           	ex de,hl
 533++6C02 2A ED 6E     	ld hl,(temp_hl) ;присоединим начало данных в конец предыдущих
 534++6C05              	; ld a,c
 535++6C05              	; or a
 536++6C05              	; jr nz,fwrite_scl2
 537++6C05              	; inc b ;коррекция
 538++6C05              ; fwrite_scl2
 539++6C05              	; ld c,a
 540++6C05 AF           	xor a
 541++6C06 91           	sub c
 542++6C07 4F           	ld c,a ;сколько осталось перенести до заполнения сектора
 543++6C08 ED 43 F2 6E  	ld (sec_shift2),bc ;сохраним сколько добавили байт
 544++6C0C ED B0        	ldir
 545++6C0E
 546++6C0E 3A F4 6E     	ld a,(sec_shift_flag)
 547++6C11 B7           	or a
 548++6C12 20 0C        	jr nz,fwrite_scl3 ;если сектор ещё не заполнен писать не будем
 549++6C14
 550++6C14 21 00 51     	ld hl,sec_buf
 551++6C17              	;ld de,(#5cf4)
 552++6C17              	;ld (f_w_cur_trk),de	;запомним позицию
 553++6C17 06 01            ld      b,#01 ;пишем 1 сектор из буфера
 554++6C19 CD 84 6C         call    scl_write_buf
 555++6C1C              	; ld a,c
 556++6C1C              	; cp 255
 557++6C1C              	; jp z,fwrite_no_chek ;выход если ошибка
 558++6C1C
 559++6C1C AF           	xor a
 560++6C1D 32 EA 6E     	ld (write_end_flag),a ;флаг что нужно дописывать остаток
 561++6C20              	; ld de,(f_w_cur_trk) ;если сектор ещё не заполнен, останемся на старой позиции
 562++6C20              	; ld (#5cf4),de
 563++6C20              	; ld b,1 ;на сектор вперёд
 564++6C20              	; ld de,(f_w_cur_trk)
 565++6C20              	; call calc_next_pos
 566++6C20              	; ld (f_w_cur_trk),de
 567++6C20
 568++6C20              fwrite_scl3
 569++6C20 2A ED 6E     	ld hl,(temp_hl) ;запишем остаток данных
 570++6C23              	;ld a,(sec_shift)
 571++6C23              	;ld c,a
 572++6C23              	;ld b,0
 573++6C23 ED 4B F2 6E  	ld bc,(sec_shift2)
 574++6C27 09           	add hl,bc ;с этой точки пишем
 575++6C28 22 EF 6E     	ld (temp_hl2),hl ;сохраним начало записи второго сектора
 576++6C2B
 577++6C2B 2A EB 6E     	ld hl,(temp_bc) ;вычисление на чём остановимся в этот раз
 578++6C2E A7           	and a
 579++6C2F ED 42        	sbc hl,bc ;вычтем то, что добавили к первому сектору
 580++6C31 4D           	ld c,l
 581++6C32 44           	ld b,h
 582++6C33 30 02        	jr nc,fwrite_scl5
 583++6C35 06 00        	ld b,0 ;коррекция если вышел минус
 584++6C37              fwrite_scl5
 585++6C37 2A ED 6E     	ld hl,(temp_hl)
 586++6C3A 09           	add hl,bc
 587++6C3B
 588++6C3B 11 F5 9A     	ld de,outputBuffer
 589++6C3E A7           	and a
 590++6C3F ED 52        	sbc hl,de
 591++6C41
 592++6C41 7D           	ld a,l
 593++6C42 32 F1 6E     	ld (sec_shift),a ;смещение на следующий раз
 594++6C45              	;ld hl,(temp_hl)
 595++6C45
 596++6C45
 597++6C45              	; or a
 598++6C45              	; jr z,fwrite_scl1
 599++6C45              	; inc b  ;коррекция количества секторов
 600++6C45
 601++6C45 78           	ld a,b ;нужна проверка на количество секторов!!!
 602++6C46 32 F3 6E     	ld (sec_part),a ;запомним сколько секторов во второй части
 603++6C49
 604++6C49              	;ld a,b
 605++6C49 B7           	or a
 606++6C4A 28 0A        	jr z,fwrite_scl1 ;если размер данных меньше сектора, то пропустим запись
 607++6C4C
 608++6C4C 2A EF 6E     	ld hl,(temp_hl2)
 609++6C4F              	;push bc
 610++6C4F              	;ld de,(#5cf4)
 611++6C4F                  ;ld      c,6 ;пишем целыми секторами
 612++6C4F CD 84 6C         call    scl_write_buf
 613++6C52              	;ld a,c
 614++6C52              	;pop bc
 615++6C52              	; cp 255
 616++6C52              	; jp z,fwrite_no_chek ;выход если ошибка
 617++6C52              	; ld de,(f_w_cur_trk)
 618++6C52              	; call calc_next_pos
 619++6C52              	; ld (f_w_cur_trk),de
 620++6C52
 621++6C52 AF           	xor a
 622++6C53 32 EA 6E     	ld (write_end_flag),a ;флаг что нужно дописывать остаток
 623++6C56
 624++6C56              fwrite_scl1
 625++6C56 3A EA 6E     	ld a,(write_end_flag) ;нужно записывать остаток?
 626++6C59 B7           	or a
 627++6C5A 20 12        	jr nz,fwrite_scl_ex ;не нужно
 628++6C5C
 629++6C5C 2A EF 6E     	ld hl,(temp_hl2) ;сохраним незаписанный остаток
 630++6C5F 3A F3 6E     	ld a,(sec_part)
 631++6C62 47           	ld b,a
 632++6C63 0E 00        	ld c,0
 633++6C65 09           	add hl,bc
 634++6C66 11 00 51     	ld de,sec_buf
 635++6C69 01 00 01     	ld bc,256
 636++6C6C ED B0        	ldir
 637++6C6E              ;fwrite_scl2
 638++6C6E
 639++6C6E
 640++6C6E              fwrite_scl_ex
 641++6C6E ED 4B EB 6E  	ld bc,(temp_bc) ;возвратим, что сколько запрашивали, столько и записали байт
 642++6C72              	;посчитаем общую длину записанного
 643++6C72 2A E6 6E     	ld hl,(f_w_len)
 644++6C75 09           	add hl,bc
 645++6C76 22 E6 6E     	ld (f_w_len),hl
 646++6C79 30 07        	jr nc,fwrite_scl_ex1
 647++6C7B 2A E8 6E     	ld hl,(f_w_len+2)
 648++6C7E 23           	inc hl
 649++6C7F 22 E8 6E     	ld (f_w_len+2),hl
 650++6C82
 651++6C82              fwrite_scl_ex1
 652++6C82 AF           	xor a ;флаги сбросим
 653++6C83 C9               ret
 654++6C84
 655++6C84
 656++6C84
 657++6C84
 658++6C84
 659++6C84
 660++6C84              scl_write_buf ;заполнение промежуточного буфера
 661++6C84 C5           	push bc ;сколько пакетов указано в b
 662++6C85 11 00 53     	ld de,scl_buf ;перенесём сектор во временный буфер
 663++6C88 01 00 01     	ld bc,256
 664++6C8B ED B0        	ldir
 665++6C8D 22 15 6F     	ld (scl_temp_hl2),hl ;сохраним адрес данных
 666++6C90 3A FD 6E     	ld a,(scl_que) ;проверим флаг что нужны данные
 667++6C93 B7           	or a
 668++6C94 28 08        	jr z,scl_write_buf_ret ;не будем вызывать парсер если не нужны
 669++6C96 21 9E 6C     	ld hl,scl_write_buf_ret ;адрес возврата
 670++6C99 E5           	push hl
 671++6C9A 2A 0F 6F     	ld hl,(scl_parse_ret_adr) ;адрес для продолжения основного цикла сборки
 672++6C9D E9           	jp (hl) ;отдадим пакет 256 байт парсеру
 673++6C9E              scl_write_buf_ret
 674++6C9E 2A 15 6F     	ld hl,(scl_temp_hl2)
 675++6CA1 C1           	pop bc
 676++6CA2 10 E0        	djnz scl_write_buf
 677++6CA4
 678++6CA4 C9           	ret
 679++6CA5
 680++6CA5
 681++6CA5
 682++6CA5              scl_parse ;разбор образа scl в trd, основной цикл
 683++6CA5              	;получить первый сектор
 684++6CA5              ;запрос порции данных по 256 байт
 685++6CA5 22 13 6F     	ld (scl_temp_hl),hl
 686++6CA8 ED 53 17 6F  	ld (scl_temp_de),de
 687++6CAC ED 43 19 6F  	ld (scl_temp_bc),bc
 688++6CB0 3E 01        	ld a,1
 689++6CB2 32 FD 6E     	ld (scl_que),a ;включим флаг что нужны данные
 690++6CB5 21 BC 6C     	ld hl,scl_parse_ret ;сохраним адрес возврата
 691++6CB8 22 0F 6F     	ld (scl_parse_ret_adr),hl
 692++6CBB C9           	ret ;вернёмся для ожидания данных
 693++6CBC              scl_parse_ret
 694++6CBC AF           	xor a
 695++6CBD 32 FD 6E     	ld (scl_que),a
 696++6CC0 2A 13 6F     	ld hl,(scl_temp_hl)
 697++6CC3 ED 5B 17 6F  	ld de,(scl_temp_de)
 698++6CC7 ED 4B 19 6F  	ld bc,(scl_temp_bc)
 699++6CCB
 700++6CCB 11 00 53     	ld de,scl_buf ;проверка метки образа
 701++6CCE 21 F5 6E     	ld hl,scl_sign
 702++6CD1 06 08        	ld b,8
 703++6CD3              scl_parse_chk
 704++6CD3 1A           	ld a,(de)
 705++6CD4 BE           	cp (hl)
 706++6CD5 20 06        	jr nz,scl_parse_chk_no
 707++6CD7 23           	inc hl
 708++6CD8 13           	inc de
 709++6CD9 10 F8        	djnz scl_parse_chk
 710++6CDB 18 10        	jr scl_parse_chk_ok
 711++6CDD              scl_parse_chk_no ;если не совпало, значит плохой образ
 712++6CDD 21 FE 6E         ld hl, scl_err
 713++6CE0 CD E1 67         call DialogBox.msgBox ;предуреждение
 714++6CE3 AF           	xor a
 715++6CE4 32 FD 6E     	ld (scl_que),a ;выключим флаг что нужны данные
 716++6CE7 3E 04        	ld a,4 ;закроем файл
 717++6CE9 CD 99 6A     	call fclose
 718++6CEC C9           	ret
 719++6CED              scl_parse_chk_ok ;сигнатура правильная
 720++6CED
 721++6CED              ;формирование каталога
 722++6CED 3A 08 53     	ld a,(scl_buf+8)
 723++6CF0 32 12 6F     	ld (scl_files),a ;всего файлов
 724++6CF3 32 11 6F     	ld (scl_cat_cycl),a ;цикл
 725++6CF6 21 09 53     	ld hl,scl_buf+9 ;адрес первого заголовка
 726++6CF9 11 00 48     	ld de,cat_buf ;адрес формируемого каталога trd
 727++6CFC              scl_parse_cat2
 728++6CFC 06 0E        	ld b,14 ;14 байт одна запись
 729++6CFE              scl_parse_cat
 730++6CFE 7E           	ld a,(hl)
 731++6CFF 12           	ld (de),a
 732++6D00 13           	inc de
 733++6D01 2C           	inc l ;адрес увеличиваем только в пределах младшего регистра
 734++6D02 20 26        	jr nz,scl_parse_cat1
 735++6D04              	;тут пора запросить следующий сектор
 736++6D04              ;запрос порции данных по 256 байт
 737++6D04 22 13 6F     	ld (scl_temp_hl),hl
 738++6D07 ED 53 17 6F  	ld (scl_temp_de),de
 739++6D0B ED 43 19 6F  	ld (scl_temp_bc),bc
 740++6D0F 3E 01        	ld a,1
 741++6D11 32 FD 6E     	ld (scl_que),a ;включим флаг что нужны данные
 742++6D14 21 1B 6D     	ld hl,scl_parse_ret1 ;сохраним адрес возврата
 743++6D17 22 0F 6F     	ld (scl_parse_ret_adr),hl
 744++6D1A C9           	ret ;вернёмся для ожидания данных
 745++6D1B              scl_parse_ret1
 746++6D1B AF           	xor a
 747++6D1C 32 FD 6E     	ld (scl_que),a
 748++6D1F 2A 13 6F     	ld hl,(scl_temp_hl)
 749++6D22 ED 5B 17 6F  	ld de,(scl_temp_de)
 750++6D26 ED 4B 19 6F  	ld bc,(scl_temp_bc)
 751++6D2A
 752++6D2A              scl_parse_cat1
 753++6D2A 10 D2        	djnz scl_parse_cat
 754++6D2C 13           	inc de
 755++6D2D 13           	inc de
 756++6D2E 3A 11 6F     	ld a,(scl_cat_cycl)
 757++6D31 3D           	dec a
 758++6D32 32 11 6F     	ld (scl_cat_cycl),a
 759++6D35 20 C5        	jr nz,scl_parse_cat2
 760++6D37
 761++6D37 22 13 6F     	ld (scl_temp_hl),hl ;запомнить где остановились
 762++6D3A
 763++6D3A              ;подсчёт секторов и дорожек
 764++6D3A DD E5        	push ix
 765++6D3C 3A 12 6F     	ld a,(scl_files)
 766++6D3F 11 00 01     	ld de,#0100 ;данные с первой дорожки
 767++6D42 DD 21 00 48  	ld ix,cat_buf
 768++6D46 DD 73 0E     	ld (ix+14),e
 769++6D49 DD 72 0F     	ld (ix+15),d
 770++6D4C 21 00 00     	ld hl,0 ;общее количество секторов
 771++6D4F              scl_cacl
 772++6D4F 32 11 6F     	ld (scl_cat_cycl),a ;цикл
 773++6D52 DD 7E 0D     	ld a,(ix+13) ;длина файла в секторах
 774++6D55 4F           	ld c,a
 775++6D56 06 00        	ld b,0
 776++6D58 09           	add hl,bc ;секторов
 777++6D59
 778++6D59 01 10 00     	ld bc,16
 779++6D5C DD 09        	add ix,bc
 780++6D5E 47           	ld b,a
 781++6D5F CD 84 6E     	call calc_next_pos
 782++6D62 3A 11 6F     	ld a,(scl_cat_cycl)
 783++6D65 FE 01        	cp 1
 784++6D67 28 06        	jr z,scl_cacl2 ;в последний раз пропусим
 785++6D69 DD 73 0E     	ld (ix+14),e
 786++6D6C DD 72 0F     	ld (ix+15),d
 787++6D6F              scl_cacl2
 788++6D6F 3D           	dec a
 789++6D70 20 DD        	jr nz,scl_cacl
 790++6D72              	;теперь узнаем первый свободный сектор
 791++6D72 DD 7E 0D     	ld a,(ix+13) ;длина файла в секторах
 792++6D75 4F           	ld c,a
 793++6D76 06 00        	ld b,0
 794++6D78 09           	add hl,bc
 795++6D79              	; ld b,a
 796++6D79              	; call calc_next_pos
 797++6D79 ED 53 E1 50  	ld (cat_buf+8*256+#e1),de ;Первый свободный сектор и дорожка на дискете
 798++6D7D 11 F0 09     	ld de,16*159
 799++6D80 EB           	ex de,hl
 800++6D81 A7           	and a
 801++6D82 ED 52        	sbc hl,de
 802++6D84 22 E5 50     	ld (cat_buf+8*256+#e5),hl ;Число свободных секторов на диске
 803++6D87 DD E1        	pop ix
 804++6D89
 805++6D89
 806++6D89
 807++6D89              ;запись содержимого файлов
 808++6D89 3A 12 6F     	ld a,(scl_files) ;всего файлов
 809++6D8C 32 11 6F     	ld (scl_cat_cycl),a ;цикл
 810++6D8F 21 0D 48     	ld hl,cat_buf+13 ;адрес размер секторов файла
 811++6D92 22 1B 6F     	ld (cat_cur_adr),hl
 812++6D95
 813++6D95 21 00 01     	ld hl,#0100 ;начиная с первой дорожки
 814++6D98 22 F4 5C     	ld (#5cf4),hl
 815++6D9B              scl_parse_file2
 816++6D9B 2A 13 6F     	ld hl,(scl_temp_hl) ;адрес данных
 817++6D9E ED 5B 1B 6F  	ld de,(cat_cur_adr) ;адрес сектор дорожка файла
 818++6DA2              	;dec de
 819++6DA2 1A           	ld a,(de) ;количество секторов, цикл
 820++6DA3 4F           	ld c,a
 821++6DA4              scl_parse_file3
 822++6DA4 11 00 55     	ld de,scl_buf2 ;адрес ещё одного буфера
 823++6DA7 06 00        	ld b,0 ;256 байт один сектор, цикл
 824++6DA9              scl_parse_file
 825++6DA9 7E           	ld a,(hl)
 826++6DAA 12           	ld (de),a
 827++6DAB 13           	inc de
 828++6DAC 2C           	inc l ;адрес увеличиваем только в пределах младшего регистра
 829++6DAD 20 26        	jr nz,scl_parse_file1
 830++6DAF              	;тут пора запросить следующий сектор
 831++6DAF              ;запрос порции данных по 256 байт
 832++6DAF 22 13 6F     	ld (scl_temp_hl),hl
 833++6DB2 ED 53 17 6F  	ld (scl_temp_de),de
 834++6DB6 ED 43 19 6F  	ld (scl_temp_bc),bc
 835++6DBA 3E 01        	ld a,1
 836++6DBC 32 FD 6E     	ld (scl_que),a ;включим флаг что нужны данные
 837++6DBF 21 C6 6D     	ld hl,scl_parse_ret2 ;сохраним адрес возврата
 838++6DC2 22 0F 6F     	ld (scl_parse_ret_adr),hl
 839++6DC5 C9           	ret ;вернёмся для ожидания данных
 840++6DC6              scl_parse_ret2
 841++6DC6 AF           	xor a
 842++6DC7 32 FD 6E     	ld (scl_que),a
 843++6DCA 2A 13 6F     	ld hl,(scl_temp_hl)
 844++6DCD ED 5B 17 6F  	ld de,(scl_temp_de)
 845++6DD1 ED 4B 19 6F  	ld bc,(scl_temp_bc)
 846++6DD5
 847++6DD5              scl_parse_file1
 848++6DD5 10 D2        	djnz scl_parse_file
 849++6DD7 22 13 6F     	ld (scl_temp_hl),hl
 850++6DDA ED 43 19 6F  	ld (scl_temp_bc),bc
 851++6DDE
 852++6DDE 21 00 55     	ld hl,scl_buf2 ;;запишем один сектор
 853++6DE1 ED 5B F4 5C  	ld  de,(#5cf4)
 854++6DE5 01 06 01         ld      bc,#0106 ;
 855++6DE8 CD 13 3D         call    #3d13
 856++6DEB              	; ld a,c
 857++6DEB              	; cp 255
 858++6DEB              	; jp z,fwrite_no_chek ;выход если ошибка
 859++6DEB 2A 13 6F     	ld hl,(scl_temp_hl)
 860++6DEE ED 4B 19 6F  	ld bc,(scl_temp_bc)
 861++6DF2
 862++6DF2 0D           	dec c
 863++6DF3 20 AF        	jr nz,scl_parse_file3
 864++6DF5
 865++6DF5 2A 1B 6F     	ld hl,(cat_cur_adr) ;адрес сектор дорожка файла
 866++6DF8              	; ld e,(hl)
 867++6DF8              	; inc hl
 868++6DF8              	; ld d,(hl)
 869++6DF8 01 10 00     	ld bc,16
 870++6DFB 09           	add hl,bc ;на следующий файл
 871++6DFC 22 1B 6F     	ld (cat_cur_adr),hl
 872++6DFF
 873++6DFF
 874++6DFF 3A 11 6F     	ld a,(scl_cat_cycl)
 875++6E02 3D           	dec a
 876++6E03 32 11 6F     	ld (scl_cat_cycl),a
 877++6E06 20 93        	jr nz,scl_parse_file2	;на следующий файл
 878++6E08
 879++6E08
 880++6E08
 881++6E08              ;формирование системного сектора №9 (8)
 882++6E08              	;
 883++6E08              	;ld (cat_buf+8*256+#e1),a ;// #E1 Первый свободный сектор на дискете
 884++6E08              	;
 885++6E08              	;ld (cat_buf+8*256+#e2),a ;// #E2 Первый свободный трек
 886++6E08 3E 16        	ld a,#16
 887++6E0A 32 E3 50     	ld (cat_buf+8*256+#e3),a ;// #E3 16 80 дорожек, 2 стороны
 888++6E0D 3A 12 6F     	ld a,(scl_files)
 889++6E10 32 E4 50     	ld (cat_buf+8*256+#e4),a ;// #E4 Общее количество файлов записанных на диск
 890++6E13              	;
 891++6E13              	;ld (cat_buf+8*256+#e5),a ;// #Е5,Е6 Число свободных секторов на диске
 892++6E13              	;ld (cat_buf+8*256+#e6),a
 893++6E13 3E 10        	ld a,#10
 894++6E15 32 E7 50     	ld (cat_buf+8*256+#e7),a ;// #E7 Код  #10,определяющий принадлежность к TR-DOS
 895++6E18
 896++6E18 21 D3 6E     	ld hl,f_name ;запишем имя диска, взяв для этого имя файла
 897++6E1B 11 F5 50     	ld de,cat_buf+8*256+#f5 ;// #F5-#FC Имя диска в ASCII формате
 898++6E1E 01 08 00     	ld bc,8
 899++6E21 ED B0        	ldir
 900++6E23
 901++6E23 21 00 48     	ld hl,cat_buf ;запишем каталог на диск
 902++6E26 11 00 00     	ld de,0
 903++6E29 01 06 09         ld      bc,#0906 ;
 904++6E2C CD 13 3D         call    #3d13
 905++6E2F              	; ld a,c
 906++6E2F              	; cp 255
 907++6E2F              	; jp z,fwrite_no_chek ;выход если ошибка
 908++6E2F C9           	ret
 909++6E30
 910++6E30
 911++6E30              ;-----------scl end --------------------
 912++6E30
 913++6E30
 914++6E30
 915++6E30
 916++6E30
 917++6E30
 918++6E30
 919++6E30
 920++6E30
 921++6E30
 922++6E30              ; A - file stream id
 923++6E30              ; fsync:
 924++6E30              ;     esxCall ESX_FSYNC
 925++6E30                  ; ret
 926++6E30
 927++6E30
 928++6E30              ; HL - name (name.ext)
 929++6E30              ; Returns:
 930++6E30              ; HL - name (name    e)
 931++6E30              format_name ;подгоняет имя файла под стандарт trdos (8+1)
 932++6E30
 933++6E30              	;сначала попробуем убрать из пути подпапку, если она есть
 934++6E30 22 ED 6E     	ld (temp_hl),hl ;сохраним адрес исходного имени
 935++6E33 06 00        	ld b,#00 ;не больше 255 символов
 936++6E35              format_name5
 937++6E35 7E           	ld a,(hl)
 938++6E36 FE 2F        	cp "/" ;если есть подпапка
 939++6E38 28 0D        	jr z,format_name_path_yep
 940++6E3A 7E           	ld a,(hl)
 941++6E3B FE 2E        	cp "." ;если ещё не дошли до расширения
 942++6E3D 20 05        	jr nz,format_name6
 943++6E3F 2A ED 6E     	ld hl,(temp_hl) ;если дошли до расширения, то путей нет, вернёмся на начало имени
 944++6E42 18 04        	jr format_name_7 ;на выход
 945++6E44              format_name6
 946++6E44 23           	inc hl
 947++6E45 10 EE        	djnz format_name5
 948++6E47
 949++6E47              format_name_path_yep ;нашли
 950++6E47 23           	inc hl ;пропустим знак "/"
 951++6E48
 952++6E48              format_name_7
 953++6E48
 954++6E48
 955++6E48 E5           	push hl ;очистим место для нового имени
 956++6E49 21 D3 6E     	ld hl,f_name
 957++6E4C 11 D4 6E     	ld de,f_name+1
 958++6E4F 36 20        	ld (hl)," "
 959++6E51 01 08 00     	ld bc,8
 960++6E54 ED B0        	ldir
 961++6E56 E1           	pop hl
 962++6E57
 963++6E57 01 FF 09     	ld bc,#09ff ;длина имени 9 символов
 964++6E5A 11 D3 6E     	ld de,f_name ;куда
 965++6E5D              format_name2
 966++6E5D 7E           	ld a,(hl)
 967++6E5E FE 2E        	cp "."
 968++6E60 20 08        	jr nz,format_name1
 969++6E62 23           	inc hl
 970++6E63 7E           	ld a,(hl)
 971++6E64 32 DB 6E     	ld (f_name+8),a ; и в конце первую букву расширения
 972++6E67 EB           	ex de,hl ;сохраним адрес исходного расширения
 973++6E68 18 16        	jr format_name_e
 974++6E6A              format_name1
 975++6E6A ED A0        	ldi
 976++6E6C 10 EF        	djnz format_name2
 977++6E6E
 978++6E6E              	;если имя длинное, пропустим лишнее до расширения
 979++6E6E 06 00        	ld b,#00 ;не больше 255 символов
 980++6E70              format_name3
 981++6E70 7E           	ld a,(hl)
 982++6E71 FE 2E        	cp "."
 983++6E73 20 08        	jr nz,format_name4
 984++6E75 23           	inc hl
 985++6E76 7E           	ld a,(hl)
 986++6E77 32 DB 6E     	ld (f_name+8),a ; и в конце первую букву расширения
 987++6E7A EB           	ex de,hl ;сохраним адрес исходного расширения
 988++6E7B 18 03        	jr format_name_e
 989++6E7D              format_name4
 990++6E7D 23           	inc hl
 991++6E7E 10 F0        	djnz format_name3
 992++6E80
 993++6E80              format_name_e ;выход
 994++6E80 21 D3 6E     	ld hl,f_name ;вернём результат
 995++6E83 C9           	ret
 996++6E84
 997++6E84              ; DE - trk/sec
 998++6E84              ; B - sectors step
 999++6E84              ; Returns:
1000++6E84              ; DE - trk/sec
1001++6E84              calc_next_pos		;вперёд на N секторов
1002++6E84              			;ld b,4
1003++6E84              			;ld  de,(#5ceb)
1004++6E84              calc_next_pos2
1005++6E84 1C           			inc e
1006++6E85 7B           			ld a,e
1007++6E86 FE 10        			cp 16
1008++6E88 38 03        			jr c,calc_next_pos1
1009++6E8A 14           			inc d
1010++6E8B 1E 00        			ld e,0
1011++6E8D              calc_next_pos1
1012++6E8D              			;ld (#5ceb),de
1013++6E8D 10 F5        			djnz calc_next_pos2
1014++6E8F C9           			ret
1015++6E90
1016++6E90
1017++6E90              ;testt db "123.trd"
1018++6E90 49 6E 73 65  write_ima db "Insert disk to drive "
1018++6E94 72 74 20 64
1018++6E98 69 73 6B 20
1018++6E9C 74 6F 20 64
1018++6EA0 72 69 76 65
1018++6EA4 20
1019++6EA5 41 2E 20     write_ima_d db "A. "
1020++6EA8 41 6C 6C 20  		db "All data will be lost!",0
1020++6EAC 64 61 74 61
1020++6EB0 20 77 69 6C
1020++6EB4 6C 20 62 65
1020++6EB8 20 6C 6F 73
1020++6EBC 74 21 00
1021++6EBF
1022++6EBF 2E 74 72 64  trdExt1 db ".trd", 0
1022++6EC3 00
1023++6EC4 2E 54 52 44  trdExt2 db ".TRD", 0
1023++6EC8 00
1024++6EC9
1025++6EC9 2E 73 63 6C  sclExt1 db ".scl", 0
1025++6ECD 00
1026++6ECE 2E 53 43 4C  sclExt2 db ".SCL", 0
1026++6ED2 00
1027++6ED3
1028++6ED3 00 00 00...  f_name ds 9 ;имя файла
1029++6EDC 00 00        f_r_cur_trk dw 	 0 ;текущие сектор-дорожка файла на чтение
1030++6EDE 00           f_r_len_sec db 0 ;длина файла на чтение в секторах
1031++6EDF 00 00        f_r_len dw 0;длина файла в байтах
1032++6EE1 00           f_r_flag db 0 ;флаг что открыт файл на чтение
1033++6EE2
1034++6EE2 00 00        f_w_cur_trk dw 	 0 ;текущие сектор-дорожка файла на запись
1035++6EE4 00           f_w_len_sec db 0 ;длина файла на запись в секторах
1036++6EE5 00           f_w_flag db 0 ;флаг что открыт файл на запись
1037++6EE6 00 00 00 00  f_w_len ds 4 ;длина записанных данных
1038++6EEA 00           write_end_flag db 0 ;флаг что нужно записать остаток
1039++6EEB
1040++6EEB 00 00        temp_bc dw 0 ;хранение регистра
1041++6EED 00 00        temp_hl dw 0 ;хранение регистра
1042++6EEF 00 00        temp_hl2 dw 0 ;хранение регистра
1043++6EF1
1044++6EF1 00           sec_shift db 0 ;указатель на каком байте остановлена запись
1045++6EF2 00           sec_shift2 db 0 ;указатель на каком байте остановлена запись (остаток)
1046++6EF3 00           sec_part db 0 ;сколько секторов во второй порции для записи
1047++6EF4 00           sec_shift_flag db 0 ;флаг что буфер сектора не заполнен
1048++6EF5
1049++6EF5              ;секция scl
1050++6EF5 53 49 4E 43  scl_sign db "SINCLAIR" ;метка
1050++6EF9 4C 41 49 52
1051++6EFD 00           scl_que db 0 ;флаг запроса порции данных
1052++6EFE 53 43 4C 20  scl_err db "SCL image error!",0
1052++6F02 69 6D 61 67
1052++6F06 65 20 65 72
1052++6F0A 72 6F 72 21
1052++6F0E 00
1053++6F0F 00 00        scl_parse_ret_adr dw 0; адрес возврата в цикл
1054++6F11 00           scl_cat_cycl db 0 ;переменная цикла
1055++6F12 00           scl_files db 0 ;всего файлов
1056++6F13 00 00        scl_temp_hl dw 0;;хранение регистра
1057++6F15 00 00        scl_temp_hl2 dw 0;
1058++6F17 00 00        scl_temp_de dw 0;
1059++6F19 00 00        scl_temp_bc dw 0;
1060++6F1B 00 00        cat_cur_adr dw 0;
1061++6F1D              ;scl end
1062++6F1D 00 00 00...  	align 256 ;временно
1063++7000              	;по адресу #4000 шрифт
1064++7000              cat_buf equ #4800 ;буфер для кататога диска 9*256
1065++7000              sec_buf equ cat_buf + 9*256 ;буфер сектора для записи 256
1066++7000              scl_buf equ sec_buf + 512 ;промежуточный буфер 256
1067++7000              scl_buf2 equ scl_buf + 512 ;промежуточный буфер 256
1068++7000
1069++7000                  ENDMODULE
# file closed: dos/trdos.asm
   9+ 7000              	ENDIF
  10+ 7000
  11+ 7000              	IFDEF ESXDOS
  12+ 7000 ~               		include "console.asm"
  13+ 7000 ~               		include "esxdos.asm"
  14+ 7000              	ENDIF
  15+ 7000
  16+ 7000              	IFDEF P3DOS
  17+ 7000 ~               		include "console.asm"
  18+ 7000 ~               		include "p3dos.asm"
  19+ 7000              	ENDIF
  20+ 7000
# file closed: dos/index.asm
  32  7000                  include "gopher/engine/history/index.asm"
# file opened: gopher/engine/history/index.asm
   1+ 7000                  include "controler.asm"
# file opened: gopher/engine/history/controler.asm
   1++7000                  module History
   2++7000              back:
   3++7000 3A 43 71         ld a, (depth)
   3++7003 FE 01          cp 1
   3++7005 CA 17 70       jp z, load
   4++7008 21 92 74 11      ld hl, historyBlock + HistoryRecord, de, historyBlock, bc, (total - 1) * HistoryRecord
   4++700C 44 71 01 38
   4++7010 0D
   4++7011 ED B0          ldir ; Move history up
   5++7013 21 43 71         ld hl, depth
   5++7016 35             dec (hl)
   6++7017              ; Loads current resource
   7++7017              load:
   8++7017 21 34 70         ld hl, .msg
   8++701A CD EA 67       call DialogBox.msgNoWait
   9++701D AF               xor a
   9++701E 21 F5 9A 11    ld hl, outputBuffer, de, outputBuffer + 1
   9++7022 F6 9A
  10++7024              	IFDEF MSX
  11++7024 ~                	ld bc, (ramtop)
  12++7024 ~                	dec bc
  13++7024              	ELSE
  14++7024 01 09 65         	ld bc, #ffff - outputBuffer - 1
  15++7027              	ENDIF
  16++7027
  17++7027 77               ld (hl), a
  18++7028 ED B0            ldir
  19++702A
  20++702A 3A 44 71         ld a, (historyBlock.isFile)
  20++702D A7             and a
  20++702E C2 2D 87       jp nz, Fetcher.fetchFromFS
  21++7031 C3 E0 86         jp Fetcher.fetchFromNet
  22++7034
  23++7034 20 20 20 20  .msg db "    Loading resource! Please wait! It will be here soon!", 0
  23++7038 4C 6F 61 64
  23++703C 69 6E 67 20
  23++7040 72 65 73 6F
  23++7044 75 72 63 65
  23++7048 21 20 50 6C
  23++704C 65 61 73 65
  23++7050 20 77 61 69
  23++7054 74 21 20 49
  23++7058 74 20 77 69
  23++705C 6C 6C 20 62
  23++7060 65 20 68 65
  23++7064 72 65 20 73
  23++7068 6F 6F 6E 21
  23++706C 00
  24++706D
  25++706D              home:
  26++706D 21 21 71         ld hl, homePage
  27++7070              ; HL - gopher row
  28++7070              navigate:
  29++7070 54 5D            ld de, hl
  30++7072 CD 59 85         call UrlEncoder.isValidGopherRow
  31++7075 30 A0            jr nc, load ; Not valid - reload last
  32++7077 62 6B            ld hl, de
  33++7079 E5               push hl
  34++707A
  35++707A E5               push hl
  36++707B 21 C9 81 11      ld hl, HistoryEnd - HistoryRecord, de, HistoryEnd, bc,  HistoryRecord * total
  36++707F 17 85 01 86
  36++7083 10
  36++7084 ED B8          lddr
  37++7086
  38++7086 ED 5B 8A 74      ld de, (Render.position), (historyBlock.position + HistoryRecord), de
  38++708A ED 53 D8 77
  39++708E                  ; Clean up struct
  40++708E AF               xor a
  40++708F 21 44 71 11    ld hl, historyBlock, de, historyBlock + 1, bc, historyBlockSize - 1, (hl), a
  40++7093 45 71 01 4D
  40++7097 03 77
  40++7099 ED B0          ldir
  41++709B E1               pop hl
  42++709C
  43++709C                  ; Fill record
  44++709C 54 5D            ld de, hl
  45++709E CD 18 85         call UrlEncoder.isFile
  46++70A1 EB               ex hl, de
  47++70A2 11 44 71         ld de, historyBlock
  48++70A5 12               ld (de), a
  48++70A6 13             inc de
  49++70A7 7E               ld a, (hl)
  49++70A8 E5 D5          push hl, de
  49++70AA CD C3 62       call Render.getIcon
  49++70AD D1 E1          pop de, hl
  50++70AF 12               ld (de), a
  50++70B0 13             inc de
  51++70B1 3E 09            ld a, 9
  52++70B3
  53++70B3                  IFDEF MSX
  54++70B3 ~                	ld bc, #ff
  55++70B3                  ELSE
  56++70B3 01 FF 0F         	ld bc, #fff
  57++70B6                  ENDIF
  58++70B6
  59++70B6 ED B1            cpir
  60++70B8              .locatorCopy
  61++70B8 7E               ld a, (hl)
  61++70B9 FE 09          cp 9
  61++70BB 28 05          jr z, 1f
  62++70BD 12               ld (de), a
  62++70BE 23 13          inc hl, de
  63++70C0 18 F6            jr .locatorCopy
  64++70C2              1
  65++70C2 23               inc hl
  65++70C3 AF             xor a
  65++70C4 12             ld (de), a
  66++70C5 11 45 73         ld de, historyBlock.host
  67++70C8              .hostCopy
  68++70C8 7E               ld a, (hl)
  68++70C9 FE 09          cp 9
  68++70CB 28 05          jr z, 1f
  69++70CD 12               ld (de), a
  69++70CE 23 13          inc hl, de
  70++70D0 18 F6            jr .hostCopy
  71++70D2              1
  72++70D2 23               inc hl
  72++70D3 AF             xor a
  72++70D4 12             ld (de), a
  73++70D5 11 85 73         ld de, historyBlock.port
  74++70D8              .portCopy
  75++70D8 7E               ld a, (hl)
  76++70D9 FE 09            cp 9
  76++70DB 28 11          jr z, 1f
  77++70DD FE 0D            cp 13
  77++70DF 28 0D          jr z, 1f
  78++70E1 FE 0A            cp 10
  78++70E3 28 09          jr z, 1f
  79++70E5 FE 00            cp 0
  79++70E7 28 05          jr z, 1f
  80++70E9 12               ld (de), a
  80++70EA 23 13          inc hl, de
  81++70EC 18 EA            jr .portCopy
  82++70EE AF           1   xor a
  82++70EF 12             ld (de), a
  83++70F0 21 91 67 11      ld hl, DialogBox.inputBuffer, de, historyBlock.search, bc, #ff
  83++70F4 8B 73 01 FF
  83++70F8 00
  83++70F9 ED B0          ldir
  84++70FB 11 00 00 ED      ld de, 0, (historyBlock.position), de
  84++70FF 53 8A 74
  85++7102 E1               pop hl
  86++7103 3A 43 71         ld a, (depth)
  86++7106 FE 05          cp total
  86++7108 30 04          jr nc, 1f
  87++710A 3C               inc a
  87++710B 32 43 71       ld (depth), a
  88++710E              1
  89++710E 3A 45 71         ld a,(historyBlock.mediaType)
  89++7111 FE 19          cp MIME_DOWNLOAD
  89++7113 CA C5 87       jp z, Gopher.download
  90++7116
  91++7116                  ifdef GS
  92++7116 ~                ld a,(historyBlock.mediaType)
  93++7116 ~                cp MIME_MOD
  94++7116 ~                jp nz,load
  95++7116 ~                ld a,(GeneralSound.GSdownType)
  96++7116 ~                xor 1
  97++7116 ~                jp z, downMod2file
  98++7116 ~
  99++7116 ~            downMod2GS
 100++7116 ~                jp Gopher.loadMod
 101++7116 ~            downMod2file
 102++7116 ~                jp Gopher.download
 103++7116                  else
 104++7116 3A 45 71         ld a,(historyBlock.mediaType)
 104++7119 FE 0D          cp MIME_MOD
 104++711B CA C5 87       jp z, Gopher.download
 105++711E                  endif
 106++711E
 107++711E C3 17 70         jp load
 108++7121
 109++7121              homePage:
 110++7121              	IFDEF MSX
 111++7121 ~                	db "1Home", TAB, "index.gph"
 112++7121 ~                	db TAB, "file", TAB, "70", CR, LF, 0
 113++7121                  ELSE
 114++7121 31 48 6F 6D      	db "1Home", TAB, "browser/index.gph"
 114++7125 65 09 62 72
 114++7129 6F 77 73 65
 114++712D 72 2F 69 6E
 114++7131 64 65 78 2E
 114++7135 67 70 68
 115++7138 09 66 69 6C      	db TAB, "file", TAB, "70", CR, LF, 0
 115++713C 65 09 37 30
 115++7140 0D 0A 00
 116++7143                  ENDIF
 117++7143                  endmodule
# file closed: gopher/engine/history/controler.asm
   2+ 7143                  include "model.asm"
# file opened: gopher/engine/history/model.asm
   1++7143              total   equ 5
   2++7143 00           depth   db 0
   3++7144
   4++7144              historyBlock:
   5++7144 00           .isFile    db  0
   6++7145 00           .mediaType db  0
   7++7146 00 00 00...  .locator   ds  #1ff
   8++7345 00 00 00...  .host      ds  64
   9++7385 00 00 00...  .port      ds  6
  10++738B 00 00 00...  .search    ds  #ff
  11++748A 00 00        .position  dw  #0000    ;position
  12++748C
  13++748C 00 00 00 00      db 0,0,0,0,0,0  ;cursor_position page_offset
  13++7490 00 00
  14++7492
  15++7492              historyBlockSize = $ - historyBlock
  16++7492
  17++7492              HistoryRecord EQU $ - historyBlock
  18++7492                  dup total
  19++7492 00 00 00... >    ds HistoryRecord
  19++77E0 00 00 00... >    ds HistoryRecord
  19++7B2E 00 00 00... >    ds HistoryRecord
  19++7E7C 00 00 00... >    ds HistoryRecord
  19++81CA 00 00 00... >    ds HistoryRecord
  20++8518                  edup
  21++8518              HistoryEnd equ $ - 1
  22++8518
# file closed: gopher/engine/history/model.asm
# file closed: gopher/engine/history/index.asm
  33  8518                  include "gopher/engine/urlencoder.asm"
# file opened: gopher/engine/urlencoder.asm
   1+ 8518                  MODULE UrlEncoder
   2+ 8518              ; HL - pointer to line in gopher page
   3+ 8518              ; C - flag set when it's file
   4+ 8518              isFile:
   5+ 8518              .findServerLoop
   6+ 8518 7E               ld a, (hl)
   6+ 8519 A7             and a
   6+ 851A 28 3B          jr z, .notFile
   6+ 851C 23             inc hl
   7+ 851D FE 0D            cp 13
   7+ 851F 28 36          jr z, .notFile
   8+ 8521 FE 09            cp 9
   8+ 8523 28 02          jr z, .skipPath
   9+ 8525 18 F1            jr .findServerLoop
  10+ 8527              .skipPath
  11+ 8527 7E               ld a, (hl)
  11+ 8528 A7             and a
  11+ 8529 28 2C          jr z, .notFile
  11+ 852B 23             inc hl
  12+ 852C FE 0D            cp 13
  12+ 852E 28 27          jr z, .notFile
  13+ 8530 FE 09            cp 9
  13+ 8532 28 02          jr z, .compareServer
  14+ 8534 18 F1            jr .skipPath
  15+ 8536              .compareServer
  16+ 8536 7E               ld a, (hl)
  16+ 8537 FE 66          cp "f"
  16+ 8539 20 1C          jr nz, .notFile
  16+ 853B 23             inc hl
  17+ 853C 7E               ld a, (hl)
  17+ 853D FE 69          cp "i"
  17+ 853F 20 16          jr nz, .notFile
  17+ 8541 23             inc hl
  18+ 8542 7E               ld a, (hl)
  18+ 8543 FE 6C          cp "l"
  18+ 8545 20 10          jr nz, .notFile
  18+ 8547 23             inc hl
  19+ 8548 7E               ld a, (hl)
  19+ 8549 FE 65          cp "e"
  19+ 854B 20 0A          jr nz, .notFile
  19+ 854D 23             inc hl
  20+ 854E 7E               ld a, (hl)
  20+ 854F FE 09          cp 9
  20+ 8551 20 04          jr nz, .notFile
  20+ 8553 23             inc hl
  21+ 8554 3E 01            ld a, 1
  22+ 8556 C9               ret
  23+ 8557              .notFile
  24+ 8557 AF               xor a
  25+ 8558 C9               ret
  26+ 8559
  27+ 8559              ; Is enough fields to encode
  28+ 8559              ; HL - pointer to line in gopher page
  29+ 8559              ; C - flag set when there is enough fields
  30+ 8559              isValidGopherRow:
  31+ 8559 7E               ld a, (hl)
  31+ 855A A7             and a
  31+ 855B 28 FA          jr z, isFile.notFile
  31+ 855D 23             inc hl
  32+ 855E FE 0D            cp 13
  32+ 8560 28 F5          jr z, isFile.notFile
  33+ 8562 FE 09            cp 9
  33+ 8564 28 02          jr z, .skipPath
  34+ 8566 18 F1            jr isValidGopherRow
  35+ 8568              .skipPath
  36+ 8568 7E               ld a, (hl)
  36+ 8569 A7             and a
  36+ 856A 28 EB          jr z, isFile.notFile
  36+ 856C 23             inc hl
  37+ 856D FE 0D            cp 13
  37+ 856F 28 E6          jr z, isFile.notFile
  38+ 8571 FE 09            cp 9
  38+ 8573 28 02          jr z, .skipHost
  39+ 8575 18 F1            jr .skipPath
  40+ 8577              .skipHost
  41+ 8577 7E               ld a, (hl)
  41+ 8578 A7             and a
  41+ 8579 28 DC          jr z, isFile.notFile
  41+ 857B 23             inc hl
  42+ 857C FE 0D            cp 13
  42+ 857E 28 D7          jr z, isFile.notFile
  43+ 8580 FE 09            cp 9
  43+ 8582 28 02           jr z, .isValid
  44+ 8584 18 F1            jr .skipHost
  45+ 8586              .isValid:
  46+ 8586 37               scf
  47+ 8587 C9               ret
  48+ 8588
  49+ 8588              extractPath:
  50+ 8588 21 46 71 11      ld hl, historyBlock.locator, de, nameBuffer, bc, #ff
  50+ 858C A0 85 01 FF
  50+ 8590 00
  50+ 8591 ED B0          ldir
  51+ 8593 C9               ret
  52+ 8594
  53+ 8594              extractHostName:
  54+ 8594 21 45 73 11      ld hl, historyBlock.host, de, hostName, bc, 64
  54+ 8598 A0 86 01 40
  54+ 859C 00
  54+ 859D ED B0          ldir
  55+ 859F C9               ret
  56+ 85A0
  57+ 85A0                  ENDMODULE
  58+ 85A0
  59+ 85A0 00 00 00...  nameBuffer ds #ff, 0
  60+ 869F
  61+ 869F 00                    db 0
  62+ 86A0 00 00 00...  hostName ds 64
# file closed: gopher/engine/urlencoder.asm
  34  86E0                  include "gopher/engine/fetcher.asm"
# file opened: gopher/engine/fetcher.asm
   1+ 86E0                  MODULE Fetcher
   2+ 86E0
   3+ 86E0              fetchFromNet:
   4+ 86E0
   5+ 86E0              	IFDEF MSX
   6+ 86E0 ~                	call Gopher.makeRequest
   6+ 86E0 ~              jr nz, .error
   7+ 86E0                  ELSE
   8+ 86E0 CD 9A 87         	call Gopher.makeRequest
   8+ 86E3 38 06          jr c, .error
   9+ 86E5                  ENDIF
  10+ 86E5
  11+ 86E5 CD B2 87         call Gopher.loadBuffer
  12+ 86E8 C3 39 87         jp MediaProcessor.processResource
  13+ 86EB              .error
  14+ 86EB 21 F4 86         ld hl, .err
  14+ 86EE CD E1 67       call DialogBox.msgBox
  15+ 86F1 C3 00 70         jp History.back
  16+ 86F4
  17+ 86F4 44 6F 63 75  .err db "Document fetch error! Check your connection or hostname!", 0
  17+ 86F8 6D 65 6E 74
  17+ 86FC 20 66 65 74
  17+ 8700 63 68 20 65
  17+ 8704 72 72 6F 72
  17+ 8708 21 20 43 68
  17+ 870C 65 63 6B 20
  17+ 8710 79 6F 75 72
  17+ 8714 20 63 6F 6E
  17+ 8718 6E 65 63 74
  17+ 871C 69 6F 6E 20
  17+ 8720 6F 72 20 68
  17+ 8724 6F 73 74 6E
  17+ 8728 61 6D 65 21
  17+ 872C 00
  18+ 872D
  19+ 872D
  20+ 872D              fetchFromFS:
  21+ 872D CD 88 85         call UrlEncoder.extractPath
  22+ 8730              loadFile
  23+ 8730              	IFDEF MSX
  24+ 8730 ~                ld de, nameBuffer, a, FMODE_NO_WRITE
  25+ 8730 ~                call Dos.fopen
  26+ 8730 ~                ld a, b, (.fp), a
  27+ 8730 ~                ld de, outputBuffer, hl, (ramtop)
  28+ 8730 ~                call Dos.fread
  29+ 8730 ~                ld a, (.fp), b, a
  30+ 8730 ~                call Dos.fclose
  31+ 8730 ~                jp MediaProcessor.processResource
  32+ 8730 ~            .fp db 0
  33+ 8730              	ELSE
  34+ 8730 21 A0 85         ld hl, nameBuffer
  35+ 8733 CD A4 69         call Dos.loadBuffer
  36+ 8736 C3 39 87         jp MediaProcessor.processResource
  37+ 8739              	ENDIF
  38+ 8739                  ENDMODULE
# file closed: gopher/engine/fetcher.asm
  35  8739                  include "gopher/engine/media-processor.asm"
# file opened: gopher/engine/media-processor.asm
   1+ 8739                  MODULE MediaProcessor
   2+ 8739              processResource:
   3+ 8739 CD 94 85         call UrlEncoder.extractHostName
   4+ 873C 3A 45 71         ld a, (historyBlock.mediaType)
   5+ 873F FE 0E            cp MIME_MUSIC
   5+ 8741 28 13          jr z, processPT
   6+ 8743 FE 1A            cp MIME_LINK
   6+ 8745 28 15          jr z, processPage
   7+ 8747 FE B3            cp MIME_INPUT
   7+ 8749 28 11          jr z, processPage
   8+ 874B FE 01            cp MIME_IMAGE
   8+ 874D CA D0 9A       jp z, ScreenViewer.display
   9+ 8750              	ifdef GS
  10+ 8750 ~                cp MIME_MOD
  10+ 8750 ~              jr z, processMOD
  11+ 8750              	endif
  12+ 8750              ; Fallback to plain text
  13+ 8750              processText:
  14+ 8750 CD 6E 66         call Render.renderPlainTextScreen
  15+ 8753 C3 9E 66         jp   Render.plainTextLoop
  16+ 8756
  17+ 8756              processPT:
  18+ 8756 CD 8A 8E         call VortexProcessor.play
  19+ 8759 C3 00 70         jp History.back
  20+ 875C
  21+ 875C                  ifdef GS
  22+ 875C ~            processMOD:
  23+ 875C ~                call ModProcessor.play
  24+ 875C ~                jp History.back
  25+ 875C              	endif
  26+ 875C
  27+ 875C              processPage:
  28+ 875C 3A 35 67         ld a, (Render.play_next)
  28+ 875F A7             and a
  28+ 8760 20 06          jr nz, .playNext
  29+ 8762 CD E5 64         call Render.renderGopherScreen
  30+ 8765 C3 23 65         jp   Render.workLoop
  31+ 8768              .playNext
  32+ 8768 21 8C 74         ld hl, Render.cursor_position
  33+ 876B 34               inc (hl)
  34+ 876C C3 0D 65         jp Render.checkBorder
  35+ 876F
  36+ 876F
  37+ 876F                  ENDMODULE
# file closed: gopher/engine/media-processor.asm
  36  876F                  include "gopher/gopher.asm"
# file opened: gopher/gopher.asm
   1+ 876F                  module Gopher
   2+ 876F              ; HL - gopher row
   3+ 876F              extractRequest:
   4+ 876F 21 46 71         ld hl, historyBlock.locator
   5+ 8772 11 C2 88         ld de, requestbuffer
   6+ 8775              .loop
   7+ 8775 7E               ld a, (hl)
   8+ 8776 12               ld (de), a
   9+ 8777 23               inc hl
  10+ 8778 13               inc de
  11+ 8779 FE 00            cp 0
  12+ 877B 28 02            jr z, .search
  13+ 877D 18 F6            jr .loop
  14+ 877F              .search
  15+ 877F 1B               dec de
  16+ 8780 3A 45 71         ld a, (historyBlock.mediaType)
  17+ 8783 FE B3            cp MIME_INPUT
  18+ 8785 20 10            jr nz, .exit
  19+ 8787 21 8B 73         ld hl, historyBlock.search
  20+ 878A 3E 09            ld a, TAB
  21+ 878C 12               ld (de), a
  22+ 878D 13               inc de
  23+ 878E              .searchCopy
  24+ 878E 7E               ld a, (hl)
  25+ 878F A7               and a
  25+ 8790 28 05          jr z, .exit
  26+ 8792 12               ld (de), a
  27+ 8793 23               inc hl
  27+ 8794 13             inc de
  28+ 8795 18 F7            jr .searchCopy
  29+ 8797              .exit
  30+ 8797 AF               xor a
  31+ 8798 12               ld (de), a
  32+ 8799 C9               ret
  33+ 879A
  34+ 879A
  35+ 879A              makeRequest:
  36+ 879A CD 6F 87         call extractRequest
  37+ 879D
  38+ 879D 21 45 73         ld hl, historyBlock.host
  39+ 87A0 11 85 73         ld de, historyBlock.port
  40+ 87A3 CD 68 8C         call Wifi.openTCP
  41+ 87A6 D8               ret c
  42+ 87A7
  43+ 87A7 21 C2 88         ld hl, requestbuffer
  44+ 87AA CD 59 8D         call Wifi.tcpSendZ
  45+ 87AD AF               xor a
  45+ 87AE 32 3A 8B       ld (Wifi.closed), a
  46+ 87B1 C9               ret
  47+ 87B2
  48+ 87B2
  49+ 87B2              loadBuffer:
  50+ 87B2 21 F5 9A         ld hl, outputBuffer
  51+ 87B5 22 38 8B         ld (Wifi.buffer_pointer), hl
  52+ 87B8              .loop
  53+ 87B8 CD A9 8D         call Wifi.getPacket
  54+ 87BB 3A 3A 8B         ld a, (Wifi.closed)
  54+ 87BE A7             and a
  54+ 87BF C0             ret nz
  55+ 87C0 CD C6 8C         call Wifi.continue
  56+ 87C3 18 F3            jr .loop
  57+ 87C5
  58+ 87C5                  ifdef GS
  59+ 87C5 ~            loadMod:
  60+ 87C5 ~                xor a
  60+ 87C5 ~              call GeneralSound.init
  61+ 87C5 ~                ld hl, .progress
  61+ 87C5 ~              call DialogBox.msgNoWait
  62+ 87C5 ~                call makeRequest
  62+ 87C5 ~              jp c, Fetcher.fetchFromNet.error
  63+ 87C5 ~                call GeneralSound.loadModule
  64+ 87C5 ~            .loop
  65+ 87C5 ~                ld hl, outputBuffer, (Wifi.buffer_pointer), hl
  66+ 87C5 ~                call Wifi.getPacket
  67+ 87C5 ~                ld a, (Wifi.closed)
  67+ 87C5 ~              and a
  67+ 87C5 ~              jr nz, .exit
  68+ 87C5 ~                ld hl, outputBuffer, bc, (Wifi.bytes_avail)
  69+ 87C5 ~            .loadLoop
  70+ 87C5 ~                ld a, b
  70+ 87C5 ~              or c
  70+ 87C5 ~              and a
  70+ 87C5 ~              jr z, .nextFrame
  71+ 87C5 ~                ld a, (hl)
  71+ 87C5 ~              call GeneralSound.sendByte
  72+ 87C5 ~                dec bc
  73+ 87C5 ~                inc hl
  74+ 87C5 ~                jr .loadLoop
  75+ 87C5 ~            .nextFrame
  76+ 87C5 ~                call pulsing
  77+ 87C5 ~                call Wifi.continue
  78+ 87C5 ~                jr .loop
  79+ 87C5 ~            .exit
  80+ 87C5 ~                call GeneralSound.finishLoadingModule
  81+ 87C5 ~                ;jp History.back
  82+ 87C5 ~            	jp MediaProcessor.processResource
  83+ 87C5 ~            .progress db "MOD downloading directly to GS!", 0
  84+ 87C5                  endif
  85+ 87C5
  86+ 87C5              download:
  87+ 87C5 11 46 71         ld de, historyBlock.locator
  88+ 87C8 62 6B            ld hl, de
  89+ 87CA              .findFileName
  90+ 87CA 1A               ld a, (de)
  90+ 87CB 13             inc de
  91+ 87CC FE 2F            cp '/'
  91+ 87CE 20 02          jr nz, .skip
  92+ 87D0 62 6B            ld hl, de
  93+ 87D2              .skip
  94+ 87D2 A7               and a
  94+ 87D3 20 F5          jr nz, .findFileName
  95+ 87D5              .copy
  96+ 87D5                  ;; HL - filename pointer
  97+ 87D5 11 91 67         ld de, DialogBox.inputBuffer
  98+ 87D8              .copyFileName
  99+ 87D8 7E               ld a, (hl)
  99+ 87D9 A7             and a
  99+ 87DA 28 05          jr z, .finishCopy
 100+ 87DC
 101+ 87DC 12               ld (de), a
 101+ 87DD 23 13          inc hl, de
 102+ 87DF 18 F7            jr .copyFileName
 103+ 87E1              .finishCopy
 104+ 87E1 12               ld (de), a
 105+ 87E2 CD 3A 67         call DialogBox.inputBox.noclear
 106+ 87E5 3A 91 67         ld a, (DialogBox.namedownload)
 106+ 87E8 A7             and a
 106+ 87E9 CA 00 70       jp z, History.back
 107+ 87EC
 108+ 87EC CD 9A 87         call makeRequest
 108+ 87EF DA EB 86       jp c, Fetcher.fetchFromNet.error
 109+ 87F2
 110+ 87F2 06 0E 21 91      ld b, Dos.FMODE_CREATE, hl, DialogBox.namedownload
 110+ 87F6 67
 111+ 87F7 CD C0 69         call Dos.fopen
 112+ 87FA 32 9B 88         ld (.fp), a
 113+ 87FD
 114+ 87FD 21 76 88         ld hl, .progress
 114+ 8800 CD EA 67       call DialogBox.msgNoWait
 115+ 8803              .loop
 116+ 8803 21 F5 9A 22      ld hl, outputBuffer, (Wifi.buffer_pointer), hl
 116+ 8807 38 8B
 117+ 8809 CD A9 8D         call Wifi.getPacket
 118+ 880C 3A 3A 8B         ld a, (Wifi.closed)
 118+ 880F A7             and a
 118+ 8810 20 15          jr nz, .exit
 119+ 8812
 120+ 8812 3A 9B 88 21      ld a, (.fp), hl, outputBuffer, bc, (Wifi.bytes_avail)
 120+ 8816 F5 9A ED 4B
 120+ 881A 36 8B
 121+ 881C CD D0 6A         call Dos.fwrite
 122+ 881F CD 9E 88         call pulsing
 123+ 8822 CD C6 8C         call Wifi.continue
 124+ 8825 18 DC            jr .loop
 125+ 8827              .exit
 126+ 8827 3A 9B 88         ld a, (.fp)
 127+ 882A CD 99 6A         call Dos.fclose
 128+ 882D C3 00 70         jp History.back
 129+ 8830              .error
 130+ 8830 3A 9B 88         ld a, (.fp)
 131+ 8833 CD 99 6A         call Dos.fclose
 132+ 8836 21 3F 88         ld hl, .err
 133+ 8839 CD E1 67         call DialogBox.msgBox
 134+ 883C C3 00 70         jp History.back
 135+ 883F
 136+ 883F 4F 70 65 72  .err db "Operation failed! Sorry! Check filename or disk space!",0
 136+ 8843 61 74 69 6F
 136+ 8847 6E 20 66 61
 136+ 884B 69 6C 65 64
 136+ 884F 21 20 53 6F
 136+ 8853 72 72 79 21
 136+ 8857 20 43 68 65
 136+ 885B 63 6B 20 66
 136+ 885F 69 6C 65 6E
 136+ 8863 61 6D 65 20
 136+ 8867 6F 72 20 64
 136+ 886B 69 73 6B 20
 136+ 886F 73 70 61 63
 136+ 8873 65 21 00
 137+ 8876 44 6F 77 6E  .progress db "Downloading in progress! Wait a bit!", 0
 137+ 887A 6C 6F 61 64
 137+ 887E 69 6E 67 20
 137+ 8882 69 6E 20 70
 137+ 8886 72 6F 67 72
 137+ 888A 65 73 73 21
 137+ 888E 20 57 61 69
 137+ 8892 74 20 61 20
 137+ 8896 62 69 74 21
 137+ 889A 00
 138+ 889B 00           .fp db 0
 139+ 889C 00           socket db 0
 140+ 889D 20           pulsator db " "
 141+ 889E              pulsing
 142+ 889E 11 01 0B         ld de, #0B01
 142+ 88A1 CD 88 61       call TextMode.gotoXY
 143+ 88A4 3A 9D 88         ld a, (pulsator)
 144+ 88A7 FE 2A            cp '*'
 145+ 88A9 CA B7 88         jp z, printasterix
 146+ 88AC 3E 2A            ld a, '*'
 147+ 88AE 32 9D 88         ld (pulsator),a
 148+ 88B1 3E 20            ld a,' '
 149+ 88B3 CD 8E 60         call TextMode.putC
 150+ 88B6 C9               ret
 151+ 88B7              printasterix
 152+ 88B7 3E 20            ld a, ' '
 153+ 88B9 32 9D 88         ld (pulsator),a
 154+ 88BC 3E 2A            ld a,'*'
 155+ 88BE CD 8E 60         call TextMode.putC
 156+ 88C1 C9               ret
 157+ 88C2
 158+ 88C2 00 00 00...  requestbuffer ds #1ff
 159+ 8AC1                  endmodule
 160+ 8AC1
# file closed: gopher/gopher.asm
  37  8AC1                  include "drivers/index.asm"
# file opened: drivers/index.asm
   1+ 8AC1                  IFDEF UNO
   2+ 8AC1 ~                	include "uno-uart.asm"
   3+ 8AC1                  ENDIF
   4+ 8AC1
   5+ 8AC1                  IFDEF UNOUART
   6+ 8AC1 ~                	include "uno-uart.asm"
   7+ 8AC1                  ENDIF
   8+ 8AC1
   9+ 8AC1                  IFDEF MB03
  10+ 8AC1 ~                	include "mb03-uart.asm"
  11+ 8AC1                  ENDIF
  12+ 8AC1
  13+ 8AC1                  IFDEF AY
  14+ 8AC1 ~                	include "ay-uart.asm"
  15+ 8AC1                  ENDIF
  16+ 8AC1
  17+ 8AC1                  IFDEF ZW
  18+ 8AC1                  	include "zx-wifi.asm"
# file opened: drivers/zx-wifi.asm
   1++8AC1              ; This driver works with 16c550 uart that's support AFE
   2++8AC1                  module Uart
   3++8AC1              ; Make init shorter and readable:-)
   4++8AC1                  macro outp port, value
   5++8AC1 ~            	ld b, port
   6++8AC1 ~            	ld c, #EF
   7++8AC1 ~                ld a, value
   8++8AC1 ~                out (c), a
   9++8AC1                  endm
  10++8AC1
  11++8AC1              ; Internal port constants
  12++8AC1              RBR_THR = #F8
  13++8AC1              IER     = RBR_THR + 1
  14++8AC1              IIR_FCR = RBR_THR + 2
  15++8AC1              LCR     = RBR_THR + 3
  16++8AC1              MCR     = RBR_THR + 4
  17++8AC1              LSR     = RBR_THR + 5
  18++8AC1              MSR     = RBR_THR + 6
  19++8AC1              SR      = RBR_THR + 7
  20++8AC1
  21++8AC1
  22++8AC1              init:
  23++8AC1                  IFDEF GZ
  24++8AC1                  outp MCR,     #0d  // Assert RTS
  24++8AC1 06 FC       >	ld b, MCR
  24++8AC3 0E EF       >	ld c, #EF
  24++8AC5 3E 0D       >    ld a, #0d
  24++8AC7 ED 79       >    out (c), a
  25++8AC9                  outp IIR_FCR, #87  // Enable fifo 8 level, and clear it
  25++8AC9 06 FA       >	ld b, IIR_FCR
  25++8ACB 0E EF       >	ld c, #EF
  25++8ACD 3E 87       >    ld a, #87
  25++8ACF ED 79       >    out (c), a
  26++8AD1                  outp LCR,     #83  // 8n1, DLAB=1
  26++8AD1 06 FB       >	ld b, LCR
  26++8AD3 0E EF       >	ld c, #EF
  26++8AD5 3E 83       >    ld a, #83
  26++8AD7 ED 79       >    out (c), a
  27++8AD9                  outp RBR_THR, 12  //(divider 12)
  27++8AD9 06 F8       >	ld b, RBR_THR
  27++8ADB 0E EF       >	ld c, #EF
  27++8ADD 3E 0C       >    ld a, 12
  27++8ADF ED 79       >    out (c), a
  28++8AE1                  outp IER,     #00  // (divider 0). Divider is 16 bit, so we get (#0002 divider)
  28++8AE1 06 F9       >	ld b, IER
  28++8AE3 0E EF       >	ld c, #EF
  28++8AE5 3E 00       >    ld a, #00
  28++8AE7 ED 79       >    out (c), a
  29++8AE9
  30++8AE9                  outp LCR,     #03 // 8n1, DLAB=0
  30++8AE9 06 FB       >	ld b, LCR
  30++8AEB 0E EF       >	ld c, #EF
  30++8AED 3E 03       >    ld a, #03
  30++8AEF ED 79       >    out (c), a
  31++8AF1                  outp IER,     #00 // Disable int
  31++8AF1 06 F9       >	ld b, IER
  31++8AF3 0E EF       >	ld c, #EF
  31++8AF5 3E 00       >    ld a, #00
  31++8AF7 ED 79       >    out (c), a
  32++8AF9                  outp MCR,     #2f // Enable AFE
  32++8AF9 06 FC       >	ld b, MCR
  32++8AFB 0E EF       >	ld c, #EF
  32++8AFD 3E 2F       >    ld a, #2f
  32++8AFF ED 79       >    out (c), a
  33++8B01 C9               ret
  34++8B02                  ELSE
  35++8B02 ~                outp MCR,     #0d  // Assert RTS
  36++8B02 ~                outp IIR_FCR, #87  // Enable fifo 8 level, and clear it
  37++8B02 ~                outp LCR,     #83  // 8n1, DLAB=1
  38++8B02 ~                outp RBR_THR, 1  // 115200 (divider 1)
  39++8B02 ~                outp IER,     #00  // (divider 0). Divider is 16 bit, so we get (#0002 divider)
  40++8B02 ~
  41++8B02 ~                outp LCR,     #03 // 8n1, DLAB=0
  42++8B02 ~                outp IER,     #00 // Disable int
  43++8B02 ~                outp MCR,     #2f // Enable AFE
  44++8B02 ~                ret
  45++8B02                  ENDIF
  46++8B02              retry_rec_count_max equ 50 ;ждать 1 байт максимум столько прерываний
  47++8B02
  48++8B02              ; Flag C <- Data available
  49++8B02              ; isAvailable:
  50++8B02                  ; ld a, LSR
  51++8B02                  ; in a, (#EF)
  52++8B02                  ; rrca
  53++8B02                  ; ret
  54++8B02
  55++8B02              ; Non-blocking read
  56++8B02              ; Flag C <- is byte was readen
  57++8B02              ; A <- byte
  58++8B02              ; read1:
  59++8B02                  ; ld a, LSR
  60++8B02                  ; in a, (#EF)
  61++8B02                  ; rrca
  62++8B02                  ; ret nc
  63++8B02                  ; ld a, RBR_THR
  64++8B02                  ; in a, (#EF)
  65++8B02                  ; scf
  66++8B02                  ; ret
  67++8B02
  68++8B02              ; Tries read byte with timeout
  69++8B02              ; Flag C <- is byte read
  70++8B02              ; A <- byte
  71++8B02              read:
  72++8B02 AF           	xor a ;4
  73++8B03 32 78 5C     	ld (#5C78),a ;обнулить счётчик ожидания ;13
  74++8B06              .wait
  75++8B06 3E FD            ld a, LSR
  76++8B08 DB EF            in a, (#EF)
  77++8B0A 0F               rrca
  78++8B0B 30 05        	jr nc, .readW
  79++8B0D 3E F8            ld a, RBR_THR
  80++8B0F DB EF            in a, (#EF)
  81++8B11 C9           	ret
  82++8B12              .readW
  83++8B12 3A 78 5C     	ld a,(#5C78)
  84++8B15 FE 32        	cp retry_rec_count_max
  85++8B17 38 ED        	jr c, .wait ;ещё попытка
  86++8B19 AF           	xor a ;выключим флаг переноса если время вышло
  87++8B1A C9           	ret
  88++8B1B
  89++8B1B
  90++8B1B
  91++8B1B
  92++8B1B              ; Blocking read
  93++8B1B              ; A <- Byte
  94++8B1B              ; readB:
  95++8B1B                  ; ld a, LSR
  96++8B1B                  ; in a, (#EF)
  97++8B1B                  ; rrca
  98++8B1B                  ; jr nc, readB
  99++8B1B              	; ld a, RBR_THR
 100++8B1B                  ; in a, (#EF)
 101++8B1B                  ; ret
 102++8B1B
 103++8B1B              ; A -> byte to send
 104++8B1B              write:
 105++8B1B F5               push af
 106++8B1C              .wait
 107++8B1C 3E FD        	ld a, LSR
 108++8B1E DB EF            in a, (#EF)
 109++8B20 E6 20            and #20
 110++8B22 28 F8            jr z, .wait
 111++8B24 F1               pop af
 112++8B25 06 F8        	ld b, RBR_THR
 113++8B27 0E EF        	ld c, #EF
 114++8B29 ED 79            out (c), a
 115++8B2B C9               ret
 116++8B2C
 117++8B2C                  endmodule
# file closed: drivers/zx-wifi.asm
  19+ 8B2C                  ENDIF
  20+ 8B2C
  21+ 8B2C              	include "utils.asm"
# file opened: drivers/utils.asm
   1++8B2C              ;;; Macroses!!!!
   2++8B2C                  MACRO EspSend Text
   3++8B2C ~                ld hl, .txtB
   4++8B2C ~                ld e, (.txtE - .txtB)
   5++8B2C ~                call espSend
   6++8B2C ~                jr .txtE
   7++8B2C ~            .txtB
   8++8B2C ~                db Text
   9++8B2C ~            .txtE
  10++8B2C                  ENDM
  11++8B2C
  12++8B2C                  MACRO EspCmd Text
  13++8B2C ~                ld hl, .txtB
  14++8B2C ~                ld e, (.txtE - .txtB)
  15++8B2C ~                call espSend
  16++8B2C ~                jr .txtE
  17++8B2C ~            .txtB
  18++8B2C ~                db Text
  19++8B2C ~                db 13, 10
  20++8B2C ~            .txtE
  21++8B2C                  ENDM
  22++8B2C
  23++8B2C                  MACRO EspCmdOkErr text
  24++8B2C ~                EspCmd text
  25++8B2C ~                call checkOkErr
  26++8B2C                  ENDM
  27++8B2C
  28++8B2C              ; IN DE - string pointer
  29++8B2C              ; OUT HL - string len
  30++8B2C              strLen:
  31++8B2C 21 00 00         ld hl, 0
  32++8B2F              .loop
  33++8B2F 1A               ld a, (de)
  33++8B30 A7             and a
  33++8B31 C8             ret z
  34++8B32 13 23            inc de, hl
  35++8B34 18 F9            jr .loop
# file closed: drivers/utils.asm
  22+ 8B36
  23+ 8B36              	IFDEF NEDOOSATM
  24+ 8B36 ~            		include "atm-uart.asm"
  25+ 8B36              	ENDIF
  26+ 8B36
  27+ 8B36              	IFDEF NEDOOSEVO
  28+ 8B36 ~            		include "evo-uart.asm"
  29+ 8B36                     	ENDIF
  30+ 8B36
  31+ 8B36              	IFDEF NEDONET
  32+ 8B36 ~            		include "nedowifi.asm"
  33+ 8B36              	ELSE
  34+ 8B36              		include "wifi.asm"
# file opened: drivers/wifi.asm
   1++8B36                  MODULE Wifi
   2++8B36 00 00        bytes_avail dw 0
   3++8B38 00 00        buffer_pointer dw 0
   4++8B3A 01           closed db 1
   5++8B3B              ; Initialize Wifi chip to work
   6++8B3B              init:
   7++8B3B
   8++8B3B 21 2D 8C         ld hl, .uartIniting
   8++8B3E CD 83 60       call TextMode.printZ
   9++8B41 CD C1 8A         call Uart.init
  10++8B44 21 3E 8C         ld hl, .chipIniting
  10++8B47 CD 83 60       call TextMode.printZ
  11++8B4A
  12++8B4A                  EspCmdOkErr "ATE0"
  12++8B4A             >    EspCmd "ATE0"
  12++8B4A 21 54 8B    >    ld hl, .txtB
  12++8B4D 1E 06       >    ld e, (.txtE - .txtB)
  12++8B4F CD 3C 8D    >    call espSend
  12++8B52 18 06       >    jr .txtE
  12++8B54             >.txtB
  12++8B54 41 54 45 30 >    db "ATE0"
  12++8B58 0D 0A       >    db 13, 10
  12++8B5A             >.txtE
  12++8B5A CD C7 8C    >    call checkOkErr
  13++8B5D DA 0D 8C         jp c, .initError
  14++8B60
  15++8B60                  IFDEF AUTH
  16++8B60 21 58 9B 06      ld hl, creds, b, Dos.FMODE_READ
  16++8B64 01
  16++8B65 CD C0 69       call Dos.fopen
  17++8B68 F5               push af
  18++8B69 21 69 9B 01      ld hl,outputBuffer2, bc, 255
  18++8B6D FF 00
  18++8B6F CD AD 6A       call Dos.fread
  19++8B72 F1               pop af
  20++8B73 CD 99 6A         call Dos.fclose
  21++8B76
  22++8B76 21 56 8C         ld hl, .doneInit1
  22++8B79 CD 83 60       call TextMode.printZ
  23++8B7C                  ;ld hl, outputBuffer2 : call TextMode.printZ
  24++8B7C
  25++8B7C 21 69 9B         ld hl,outputBuffer2
  26++8B7F CD 46 8D         call espSendT
  27++8B82 3E 0D            ld a, 13
  27++8B84 CD 1B 8B       call Uart.write
  28++8B87 3E 0A            ld a, 10
  28++8B89 CD 1B 8B       call Uart.write
  29++8B8C CD C7 8C         call checkOkErr
  30++8B8F DA 0D 8C         jp c, .initError
  31++8B92                  ENDIF
  32++8B92
  33++8B92                 	EspCmdOkErr "AT+CIPSERVER=0"
  33++8B92             >    EspCmd "AT+CIPSERVER=0"
  33++8B92 21 9C 8B    >    ld hl, .txtB
  33++8B95 1E 10       >    ld e, (.txtE - .txtB)
  33++8B97 CD 3C 8D    >    call espSend
  33++8B9A 18 10       >    jr .txtE
  33++8B9C             >.txtB
  33++8B9C 41 54 2B 43 >    db "AT+CIPSERVER=0"
  33++8BA0 49 50 53 45 >
  33++8BA4 52 56 45 52 >
  33++8BA8 3D 30       >
  33++8BAA 0D 0A       >    db 13, 10
  33++8BAC             >.txtE
  33++8BAC CD C7 8C    >    call checkOkErr
  34++8BAF                  EspCmdOkErr "AT+CIPCLOSE" ; Close if there some connection was. Don't care about result
  34++8BAF             >    EspCmd "AT+CIPCLOSE"
  34++8BAF 21 B9 8B    >    ld hl, .txtB
  34++8BB2 1E 0D       >    ld e, (.txtE - .txtB)
  34++8BB4 CD 3C 8D    >    call espSend
  34++8BB7 18 0D       >    jr .txtE
  34++8BB9             >.txtB
  34++8BB9 41 54 2B 43 >    db "AT+CIPCLOSE"
  34++8BBD 49 50 43 4C >
  34++8BC1 4F 53 45    >
  34++8BC4 0D 0A       >    db 13, 10
  34++8BC6             >.txtE
  34++8BC6 CD C7 8C    >    call checkOkErr
  35++8BC9                  EspCmdOkErr "AT+CIPMUX=0" ; Single connection mode
  35++8BC9             >    EspCmd "AT+CIPMUX=0"
  35++8BC9 21 D3 8B    >    ld hl, .txtB
  35++8BCC 1E 0D       >    ld e, (.txtE - .txtB)
  35++8BCE CD 3C 8D    >    call espSend
  35++8BD1 18 0D       >    jr .txtE
  35++8BD3             >.txtB
  35++8BD3 41 54 2B 43 >    db "AT+CIPMUX=0"
  35++8BD7 49 50 4D 55 >
  35++8BDB 58 3D 30    >
  35++8BDE 0D 0A       >    db 13, 10
  35++8BE0             >.txtE
  35++8BE0 CD C7 8C    >    call checkOkErr
  36++8BE3 DA 0D 8C         jp c, .initError
  37++8BE6
  38++8BE6                  EspCmdOkErr "AT+CIPDINFO=0" ; Disable additional info
  38++8BE6             >    EspCmd "AT+CIPDINFO=0"
  38++8BE6 21 F0 8B    >    ld hl, .txtB
  38++8BE9 1E 0F       >    ld e, (.txtE - .txtB)
  38++8BEB CD 3C 8D    >    call espSend
  38++8BEE 18 0F       >    jr .txtE
  38++8BF0             >.txtB
  38++8BF0 41 54 2B 43 >    db "AT+CIPDINFO=0"
  38++8BF4 49 50 44 49 >
  38++8BF8 4E 46 4F 3D >
  38++8BFC 30          >
  38++8BFD 0D 0A       >    db 13, 10
  38++8BFF             >.txtE
  38++8BFF CD C7 8C    >    call checkOkErr
  39++8C02 DA 0D 8C         jp c, .initError
  40++8C05
  41++8C05 21 4F 8C         ld hl, .doneInit
  41++8C08 CD 83 60       call TextMode.printZ
  42++8C0B
  43++8C0B B7               or a
  44++8C0C C9               ret
  45++8C0D              .initError
  46++8C0D 21 15 8C         ld hl, .errMsg
  46++8C10 CD E1 67       call DialogBox.msgBox
  47++8C13 37               scf
  48++8C14 C9               ret
  49++8C15 57 69 46 69  .errMsg      db "WiFi chip init failed!", "\r", 0
  49++8C19 20 63 68 69
  49++8C1D 70 20 69 6E
  49++8C21 69 74 20 66
  49++8C25 61 69 6C 65
  49++8C29 64 21 0D 00
  50++8C2D 55 61 72 74  .uartIniting db "Uart initing...", "\r", 0
  50++8C31 20 69 6E 69
  50++8C35 74 69 6E 67
  50++8C39 2E 2E 2E 0D
  50++8C3D 00
  51++8C3E 43 68 69 70  .chipIniting db "Chip initing...", "\r", 0
  51++8C42 20 69 6E 69
  51++8C46 74 69 6E 67
  51++8C4A 2E 2E 2E 0D
  51++8C4E 00
  52++8C4F 44 6F 6E 65  .doneInit    db "Done!","\r", 0
  52++8C53 21 0D 00
  53++8C56 43 6F 6E 6E  .doneInit1   db "Connecting to AP","\r", 0
  53++8C5A 65 63 74 69
  53++8C5E 6E 67 20 74
  53++8C62 6F 20 41 50
  53++8C66 0D 00
  54++8C68                  IFNDEF PROXY
  55++8C68              ; HL - host pointer in gopher row
  56++8C68              ; DE - port pointer in gopher row
  57++8C68              openTCP:
  58++8C68 D5               push de
  59++8C69 E5               push hl
  60++8C6A                  EspCmdOkErr "AT+CIPCLOSE" ; Don't care about result. Just close if it didn't happens before
  60++8C6A             >    EspCmd "AT+CIPCLOSE"
  60++8C6A 21 74 8C    >    ld hl, .txtB
  60++8C6D 1E 0D       >    ld e, (.txtE - .txtB)
  60++8C6F CD 3C 8D    >    call espSend
  60++8C72 18 0D       >    jr .txtE
  60++8C74             >.txtB
  60++8C74 41 54 2B 43 >    db "AT+CIPCLOSE"
  60++8C78 49 50 43 4C >
  60++8C7C 4F 53 45    >
  60++8C7F 0D 0A       >    db 13, 10
  60++8C81             >.txtE
  60++8C81 CD C7 8C    >    call checkOkErr
  61++8C84                  EspSend 'AT+CIPSTART="TCP","'
  61++8C84 21 8E 8C    >    ld hl, .txtB
  61++8C87 1E 13       >    ld e, (.txtE - .txtB)
  61++8C89 CD 3C 8D    >    call espSend
  61++8C8C 18 13       >    jr .txtE
  61++8C8E             >.txtB
  61++8C8E 41 54 2B 43 >    db 'AT+CIPSTART="TCP","'
  61++8C92 49 50 53 54 >
  61++8C96 41 52 54 3D >
  61++8C9A 22 54 43 50 >
  61++8C9E 22 2C 22    >
  61++8CA1             >.txtE
  62++8CA1 E1               pop hl
  63++8CA2 CD 46 8D         call espSendT
  64++8CA5                  EspSend '",'
  64++8CA5 21 AF 8C    >    ld hl, .txtB
  64++8CA8 1E 02       >    ld e, (.txtE - .txtB)
  64++8CAA CD 3C 8D    >    call espSend
  64++8CAD 18 02       >    jr .txtE
  64++8CAF             >.txtB
  64++8CAF 22 2C       >    db '",'
  64++8CB1             >.txtE
  65++8CB1 E1               pop hl
  66++8CB2 CD 46 8D         call espSendT
  67++8CB5 3E 0D            ld a, 13
  67++8CB7 CD 1B 8B       call Uart.write
  68++8CBA 3E 0A            ld a, 10
  68++8CBC CD 1B 8B       call Uart.write
  69++8CBF AF               xor a
  69++8CC0 32 3A 8B       ld (closed), a
  70++8CC3 C3 C7 8C         jp checkOkErr
  71++8CC6
  72++8CC6              continue:
  73++8CC6 C9               ret
  74++8CC7                  ENDIF
  75++8CC7
  76++8CC7
  77++8CC7
  78++8CC7              checkOkErr:
  79++8CC7 CD 02 8B         call Uart.read
  80++8CCA FE 4F            cp 'O'
  80++8CCC CA DC 8C       jp z, .okStart ; OK
  81++8CCF FE 45            cp 'E'
  81++8CD1 CA F1 8C       jp z, .errStart ; ERROR
  82++8CD4 FE 46            cp 'F'
  82++8CD6 CA 16 8D       jp z, .failStart ; FAIL
  83++8CD9 C3 C7 8C         jp checkOkErr
  84++8CDC              .okStart
  85++8CDC CD 02 8B         call Uart.read
  85++8CDF FE 4B          cp 'K'
  85++8CE1 C2 C7 8C       jp nz, checkOkErr
  86++8CE4 CD 02 8B         call Uart.read
  86++8CE7 FE 0D          cp 13
  86++8CE9 C2 C7 8C       jp nz, checkOkErr
  87++8CEC CD 33 8D         call .flushToLF
  88++8CEF B7               or a
  89++8CF0 C9               ret
  90++8CF1              .errStart
  91++8CF1 CD 02 8B         call Uart.read
  91++8CF4 FE 52          cp 'R'
  91++8CF6 C2 C7 8C       jp nz, checkOkErr
  92++8CF9 CD 02 8B         call Uart.read
  92++8CFC FE 52          cp 'R'
  92++8CFE C2 C7 8C       jp nz, checkOkErr
  93++8D01 CD 02 8B         call Uart.read
  93++8D04 FE 4F          cp 'O'
  93++8D06 C2 C7 8C       jp nz, checkOkErr
  94++8D09 CD 02 8B         call Uart.read
  94++8D0C FE 52          cp 'R'
  94++8D0E C2 C7 8C       jp nz, checkOkErr
  95++8D11 CD 33 8D         call .flushToLF
  96++8D14 37               scf
  97++8D15 C9               ret
  98++8D16              .failStart
  99++8D16 CD 02 8B         call Uart.read
  99++8D19 FE 41          cp 'A'
  99++8D1B C2 C7 8C       jp nz, checkOkErr
 100++8D1E CD 02 8B         call Uart.read
 100++8D21 FE 49          cp 'I'
 100++8D23 C2 C7 8C       jp nz, checkOkErr
 101++8D26 CD 02 8B         call Uart.read
 101++8D29 FE 4C          cp 'L'
 101++8D2B C2 C7 8C       jp nz, checkOkErr
 102++8D2E CD 33 8D         call .flushToLF
 103++8D31 37               scf
 104++8D32 C9               ret
 105++8D33              .flushToLF
 106++8D33 CD 02 8B         call Uart.read
 107++8D36 FE 0A            cp 10
 107++8D38 C2 33 8D       jp nz, .flushToLF
 108++8D3B C9               ret
 109++8D3C
 110++8D3C              ; Send buffer to UART
 111++8D3C              ; HL - buff
 112++8D3C              ; E - count
 113++8D3C              espSend:
 114++8D3C 7E               ld a, (hl)
 114++8D3D CD 1B 8B       call Uart.write
 115++8D40 23               inc hl
 116++8D41 1D               dec e
 117++8D42 C2 3C 8D         jp nz, espSend
 118++8D45 C9               ret
 119++8D46
 120++8D46              ; HL - string that ends with one of the terminator(CR/LF/TAB/NULL)
 121++8D46              espSendT:
 122++8D46 7E               ld a, (hl)
 123++8D47
 124++8D47 A7               and a
 124++8D48 C8             ret z
 125++8D49 FE 09            cp 9
 125++8D4B C8             ret z
 126++8D4C FE 0D            cp 13
 126++8D4E C8             ret z
 127++8D4F FE 0A            cp 10
 127++8D51 C8             ret z
 128++8D52
 129++8D52 CD 1B 8B         call Uart.write
 130++8D55 23               inc hl
 131++8D56 C3 46 8D         jp espSendT
 132++8D59
 133++8D59              ; HL - stringZ to send
 134++8D59              ; Adds CR LF
 135++8D59              tcpSendZ:
 136++8D59 E5               push hl
 137++8D5A                  EspSend "AT+CIPSEND="
 137++8D5A 21 64 8D    >    ld hl, .txtB
 137++8D5D 1E 0B       >    ld e, (.txtE - .txtB)
 137++8D5F CD 3C 8D    >    call espSend
 137++8D62 18 0B       >    jr .txtE
 137++8D64             >.txtB
 137++8D64 41 54 2B 43 >    db "AT+CIPSEND="
 137++8D68 49 50 53 45 >
 137++8D6C 4E 44 3D    >
 137++8D6F             >.txtE
 138++8D6F D1               pop de
 138++8D70 D5             push de
 139++8D71 CD 2C 8B         call strLen
 140++8D74 23               inc hl
 140++8D75 23             inc hl ; +CRLF
 141++8D76 CD 44 8E         call hlToNumEsp
 142++8D79 3E 0D            ld a, 13
 142++8D7B CD 1B 8B       call Uart.write
 143++8D7E 3E 0A            ld a, 10
 143++8D80 CD 1B 8B       call Uart.write
 144++8D83 CD C7 8C         call checkOkErr
 144++8D86 D8             ret c
 145++8D87              .wait
 146++8D87 CD 02 8B         call Uart.read
 146++8D8A FE 3E          cp '>'
 146++8D8C C2 87 8D       jp nz, .wait
 147++8D8F E1               pop hl
 148++8D90              .loop
 149++8D90 7E               ld a, (hl)
 149++8D91 A7             and a
 149++8D92 CA 9C 8D       jp z, .exit
 150++8D95 CD 1B 8B         call Uart.write
 151++8D98 23               inc hl
 152++8D99 C3 90 8D         jp .loop
 153++8D9C              .exit
 154++8D9C 3E 0D            ld a, 13
 154++8D9E CD 1B 8B       call Uart.write
 155++8DA1 3E 0A            ld a, 10
 155++8DA3 CD 1B 8B       call Uart.write
 156++8DA6 C3 C7 8C         jp checkOkErr
 157++8DA9
 158++8DA9              getPacket:
 159++8DA9 CD 02 8B         call Uart.read
 160++8DAC FE 2B            cp '+'
 160++8DAE CA DF 8D       jp z, .ipdBegun    ; "+IPD," packet
 161++8DB1 FE 4F            cp 'O'
 161++8DB3 CA B9 8D       jp z, .closedBegun ; It enough to check "OSED\n" :-)
 162++8DB6 C3 A9 8D         jp getPacket
 163++8DB9              .closedBegun
 164++8DB9 CD 02 8B         call Uart.read
 164++8DBC FE 53          cp 'S'
 164++8DBE C2 A9 8D       jp nz, getPacket
 165++8DC1 CD 02 8B         call Uart.read
 165++8DC4 FE 45          cp 'E'
 165++8DC6 C2 A9 8D       jp nz, getPacket
 166++8DC9 CD 02 8B         call Uart.read
 166++8DCC FE 44          cp 'D'
 166++8DCE C2 A9 8D       jp nz, getPacket
 167++8DD1 CD 02 8B         call Uart.read
 167++8DD4 FE 0D          cp 13
 167++8DD6 C2 A9 8D       jp nz, getPacket
 168++8DD9 3E 01 32 3A      ld a, 1, (closed), a
 168++8DDD 8B
 169++8DDE C9               ret
 170++8DDF              .ipdBegun
 171++8DDF CD 02 8B         call Uart.read
 171++8DE2 FE 49          cp 'I'
 171++8DE4 C2 A9 8D       jp nz, getPacket
 172++8DE7 CD 02 8B         call Uart.read
 172++8DEA FE 50          cp 'P'
 172++8DEC C2 A9 8D       jp nz, getPacket
 173++8DEF CD 02 8B         call Uart.read
 173++8DF2 FE 44          cp 'D'
 173++8DF4 C2 A9 8D       jp nz, getPacket
 174++8DF7 CD 02 8B         call Uart.read ; Comma
 175++8DFA CD 2A 8E         call .count_ipd_lenght
 175++8DFD 22 36 8B       ld (bytes_avail), hl
 176++8E00 44 4D            ld bc, hl
 177++8E02 2A 38 8B         ld hl, (buffer_pointer)
 178++8E05              .readp
 179++8E05 7C               ld a, h
 179++8E06 FE FE          cp #fe
 179++8E08 D2 1E 8E       jp nc, .skipbuff
 180++8E0B C5 E5            push bc, hl
 181++8E0D CD 02 8B         call Uart.read
 182++8E10 E1 C1            pop hl, bc
 183++8E12 77               ld (hl), a
 184++8E13 0B               dec bc
 184++8E14 23             inc hl
 185++8E15 78               ld a, b
 185++8E16 B1             or c
 185++8E17 C2 05 8E       jp nz, .readp
 186++8E1A 22 38 8B         ld (buffer_pointer), hl
 187++8E1D C9               ret
 188++8E1E              .skipbuff
 189++8E1E C5               push bc
 190++8E1F CD 02 8B         call Uart.read
 191++8E22 C1               pop bc
 192++8E23 0B               dec bc
 192++8E24 78             ld a, b
 192++8E25 B1             or c
 192++8E26 C2 1E 8E       jp nz, .skipbuff
 193++8E29 C9               ret
 194++8E2A              .count_ipd_lenght
 195++8E2A 21 00 00     		ld hl,0			; count lenght
 196++8E2D E5           .cil1	push  hl
 197++8E2E CD 02 8B             call Uart.read
 198++8E31 E1                   pop hl
 199++8E32 FE 3A        		cp ':'
 199++8E34 C8             ret z
 200++8E35 D6 30        		sub 0x30
 200++8E37 4D             ld c,l
 200++8E38 44             ld b,h
 200++8E39 29             add hl,hl
 200++8E3A 29             add hl,hl
 200++8E3B 09             add hl,bc
 200++8E3C 29             add hl,hl
 200++8E3D 4F             ld c,a
 200++8E3E 06 00          ld b,0
 200++8E40 09             add hl,bc
 201++8E41 C3 2D 8E     		jp .cil1
 202++8E44
 203++8E44              ; Based on: https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispHL
 204++8E44              ; HL - number
 205++8E44              ; It will be written to UART
 206++8E44              hlToNumEsp:
 207++8E44 01 F0 D8     	ld	bc,-10000
 208++8E47 CD 5D 8E     	call	.n1
 209++8E4A 01 18 FC     	ld	bc,-1000
 210++8E4D CD 5D 8E     	call	.n1
 211++8E50 01 9C FF     	ld	bc,-100
 212++8E53 CD 5D 8E     	call	.n1
 213++8E56 0E F6        	ld	c,-10
 214++8E58 CD 5D 8E     	call	.n1
 215++8E5B 0E FF        	ld	c,-1
 216++8E5D 3E 2F        .n1	ld	a,'0'-1
 217++8E5F 3C           .n2	inc	a
 218++8E60 09           	add	hl,bc
 219++8E61 DA 5F 8E     	jp	c, .n2
 220++8E64 ED 42        	sbc	hl,bc
 221++8E66 C5               push bc
 222++8E67 CD 1B 8B     	call Uart.write
 223++8E6A C1               pop bc
 224++8E6B C9               ret
 225++8E6C              flushToLF1
 226++8E6C CD 02 8B         call Uart.read
 227++8E6F FE 0A            cp 10
 227++8E71 C2 6C 8E       jp nz, flushToLF1
 228++8E74 C9               ret
 229++8E75                  ENDMODULE
# file closed: drivers/wifi.asm
  35+ 8E75              	ENDIF
  36+ 8E75
  37+ 8E75              ;	IFDEF NEDOOS
  38+ 8E75              ;       	include "nedoos.asm"
  39+ 8E75              ;	ENDIF
  40+ 8E75
  41+ 8E75              	include "proxy.asm"
# file opened: drivers/proxy.asm
   1++8E75                  IFDEF PROXY
   2++8E75 ~                MODULE Wifi
   3++8E75 ~            ; Same singature as wifi.openTCP
   4++8E75 ~            ; HL - host pointer in gopher row
   5++8E75 ~            ; DE - port pointer in gopher row
   6++8E75 ~            openTCP:
   7++8E75 ~                push de
   8++8E75 ~                push hl
   9++8E75 ~
  10++8E75 ~                xor a
  10++8E75 ~              ld hl, hostBuff, de, hostBuff + 1, bc, 102, (hl), a
  10++8E75 ~              ldir
  11++8E75 ~
  12++8E75 ~                EspCmdOkErr "AT+CIPCLOSE"
  13++8E75 ~                EspCmdOkErr 'AT+CIPSTART="TCP","138.68.76.243",6912' // Replace here for yourown proxy. If you wish
  14++8E75 ~                jr c, .error
  15++8E75 ~                pop hl
  15++8E75 ~              ld de, hostBuff
  16++8E75 ~            .copyHost
  17++8E75 ~                ld a, (hl)
  17++8E75 ~              and a
  17++8E75 ~              jr z, 1F
  17++8E75 ~              and a
  17++8E75 ~              jr z, 1F
  18++8E75 ~                ld (de), a
  18++8E75 ~              inc hl, de
  19++8E75 ~                jr .copyHost
  20++8E75 ~            1   xor a
  20++8E75 ~              ld (de), a
  21++8E75 ~                pop hl
  21++8E75 ~              ld de, portBuff
  22++8E75 ~            .copyPort
  23++8E75 ~                ld a, (hl)
  23++8E75 ~              and a
  23++8E75 ~              jr z, 1F
  23++8E75 ~              and a
  23++8E75 ~              jr z, 1F
  24++8E75 ~                ld (de), a
  24++8E75 ~              inc hl, de
  25++8E75 ~                jr .copyPort
  26++8E75 ~            1   ld hl, hostBuff
  26++8E75 ~              call tcpSendZ
  27++8E75 ~                ld hl, portBuff
  27++8E75 ~              call tcpSendZ
  28++8E75 ~                xor a
  28++8E75 ~              ld (closed), a
  29++8E75 ~                ret
  30++8E75 ~            .error
  31++8E75 ~                pop hl
  31++8E75 ~              pop de
  32++8E75 ~                ret
  33++8E75 ~
  34++8E75 ~            continue:
  35++8E75 ~                EspCmdOkErr "AT+CIPSEND=1"
  36++8E75 ~                ret c
  37++8E75 ~            .wait
  38++8E75 ~                call Uart.read
  38++8E75 ~              cp '>'
  38++8E75 ~              jr nz, .wait
  39++8E75 ~                ld a, 'c'
  39++8E75 ~              call Uart.write
  40++8E75 ~                jp checkOkErr
  41++8E75 ~
  42++8E75 ~            hostBuff ds 96
  43++8E75 ~            portBuff ds 7
  44++8E75 ~                ENDMODULE
  45++8E75                  ENDIF
# file closed: drivers/proxy.asm
  42+ 8E75              	include "memory.asm"
# file opened: drivers/memory.asm
   1++8E75                  module Memory
   2++8E75              BANKM = #5b5c
   3++8E75              MEM_PORT = #7ffd
   4++8E75
   5++8E75              init:
   6++8E75 F3               di
   7++8E76 FD CB 01 A6      res 4, (iy + 1)
   8++8E7A
   9++8E7A AF               xor a
   9++8E7B CD 7F 8E       call setPage
  10++8E7E C9               ret
  11++8E7F
  12++8E7F              ; a - page
  13++8E7F              setPage:
  14++8E7F F6 18            or #18
  14++8E81 32 5C 5B       ld (BANKM), a
  15++8E84 01 FD 7F         ld bc, MEM_PORT
  15++8E87 ED 79          out (c), a
  16++8E89 C9               ret
  17++8E8A
  18++8E8A                  endmodule
# file closed: drivers/memory.asm
  43+ 8E8A              	include "general-sound.asm"
# file opened: drivers/general-sound.asm
   1++8E8A                  ifdef GS
   2++8E8A ~                macro GS_WaitCommand
   3++8E8A ~            .wait
   4++8E8A ~                in a, (GeneralSound.CMD)
   5++8E8A ~                rrca
   6++8E8A ~                jr c, .wait
   7++8E8A ~                endm
   8++8E8A ~
   9++8E8A ~                macro GS_WaitData
  10++8E8A ~            .wait
  11++8E8A ~                in a, (GeneralSound.CMD)
  12++8E8A ~                rlca
  13++8E8A ~                jr c, .wait
  14++8E8A ~                endm
  15++8E8A ~
  16++8E8A ~                macro GS_SendCommand nn
  17++8E8A ~                ld a, nn
  17++8E8A ~              out (GeneralSound.CMD), a
  18++8E8A ~                endm
  19++8E8A ~
  20++8E8A ~                module GeneralSound
  21++8E8A ~            ;; Control ports
  22++8E8A ~            CMD  = 187
  23++8E8A ~            DATA = 179
  24++8E8A ~
  25++8E8A ~            ;; Commands
  26++8E8A ~            CMD_WARM_RESET      = #F3
  27++8E8A ~            CMD_COLD_RESET      = #F4
  28++8E8A ~            CMD_LOAD_MODULE     = #30
  29++8E8A ~            CMD_PLAY_MODULE     = #31
  30++8E8A ~            CMD_STOP_MODULE     = #32
  31++8E8A ~            CMD_CONTINUE_MODULE = #33
  32++8E8A ~            CMD_OPEN_STREAM     = #D1
  33++8E8A ~            CMD_CLOSE_STREAM    = #D2
  34++8E8A ~
  35++8E8A ~            ; A - 0 warm reset, other - cold
  36++8E8A ~            init:
  37++8E8A ~                and a
  37++8E8A ~              jr nz, .cold
  38++8E8A ~                GS_SendCommand CMD_WARM_RESET
  39++8E8A ~                ret
  40++8E8A ~            .cold
  41++8E8A ~                GS_SendCommand CMD_COLD_RESET
  42++8E8A ~                ret
  43++8E8A ~
  44++8E8A ~            ;; Initializes loading module
  45++8E8A ~            loadModule:
  46++8E8A ~                GS_SendCommand CMD_LOAD_MODULE
  47++8E8A ~                GS_WaitCommand
  48++8E8A ~                GS_SendCommand CMD_OPEN_STREAM
  49++8E8A ~                GS_WaitCommand
  50++8E8A ~                ret
  51++8E8A ~
  52++8E8A ~            ;; Use it for streaming mod file
  53++8E8A ~            sendByte:
  54++8E8A ~                out (DATA), a
  55++8E8A ~                GS_WaitData
  56++8E8A ~                ret
  57++8E8A ~
  58++8E8A ~            ;; Call it when module was loaded
  59++8E8A ~            finishLoadingModule:
  60++8E8A ~                GS_SendCommand CMD_CLOSE_STREAM
  61++8E8A ~                GS_WaitCommand
  62++8E8A ~            rewind:
  63++8E8A ~                ld a, 1
  63++8E8A ~              out (DATA), a
  64++8E8A ~                GS_SendCommand CMD_PLAY_MODULE
  65++8E8A ~                GS_WaitCommand
  66++8E8A ~                ld a, 1, (state),a
  67++8E8A ~                ret
  68++8E8A ~
  69++8E8A ~            ;; Works like pause too
  70++8E8A ~            stopModule:
  71++8E8A ~                xor a
  71++8E8A ~              ld (state), a
  72++8E8A ~                GS_SendCommand CMD_STOP_MODULE
  73++8E8A ~                ret
  74++8E8A ~
  75++8E8A ~            continueModule:
  76++8E8A ~                ld a, 1
  76++8E8A ~              ld (state), a
  77++8E8A ~                GS_SendCommand CMD_CONTINUE_MODULE
  78++8E8A ~                ret
  79++8E8A ~
  80++8E8A ~            ; Pauses resumes
  81++8E8A ~            toggleModule:
  82++8E8A ~                call Console.waitForKeyUp
  83++8E8A ~                ld a, (state)
  83++8E8A ~              and a
  84++8E8A ~                jr z, continueModule
  85++8E8A ~                jr stopModule
  86++8E8A ~
  87++8E8A ~            toggleDownload:
  88++8E8A ~                ld a,(GSdownType)
  89++8E8A ~                xor 1
  90++8E8A ~                ld (GSdownType),a
  91++8E8A ~                ret
  92++8E8A ~
  93++8E8A ~            GSdownType  db 0
  94++8E8A ~            state db 0
  95++8E8A ~                endmodule
  96++8E8A ~
  97++8E8A                  endif
# file closed: drivers/general-sound.asm
  44+ 8E8A
# file closed: drivers/index.asm
  38  8E8A                  IFNDEF NEDOOS
  39  8E8A                  include "player/vortex-processor.asm"
# file opened: player/vortex-processor.asm
   1+ 8E8A                  MODULE VortexProcessor
   2+ 8E8A              	IFDEF MSX
   3+ 8E8A ~            play:
   4+ 8E8A ~                call Console.peekC
   4+ 8E8A ~              and a
   5+ 8E8A ~                jr nz, play
   6+ 8E8A ~
   7+ 8E8A ~                ld hl, message
   7+ 8E8A ~              call DialogBox.msgNoWait
   8+ 8E8A ~
   9+ 8E8A ~                ld hl, outputBuffer
   9+ 8E8A ~              call VTPL.INIT
  10+ 8E8A ~            .loop
  11+ 8E8A ~                halt
  11+ 8E8A ~              di
  11+ 8E8A ~              call VTPL.PLAY
  11+ 8E8A ~              ei
  12+ 8E8A ~                call Console.peekC
  12+ 8E8A ~              and a
  12+ 8E8A ~              jp nz, .stop
  13+ 8E8A ~                jr nc, .loop
  14+ 8E8A ~            .stop
  15+ 8E8A ~                call VTPL.MUTE
  16+ 8E8A ~            .wlp
  17+ 8E8A ~                call Console.peekC
  17+ 8E8A ~              and a
  18+ 8E8A ~                jr nz, .wlp
  19+ 8E8A ~                ret
  20+ 8E8A ~
  21+ 8E8A ~            message db "Press key to stop...", 0
  22+ 8E8A ~                ENDMODULE
  23+ 8E8A ~                include "msxplayer.asm"
  24+ 8E8A              	ELSE
  25+ 8E8A              play:
  26+ 8E8A CD 19 68         call Console.waitForKeyUp
  27+ 8E8D
  28+ 8E8D 21 C5 8E         ld hl, message
  28+ 8E90 CD EA 67       call DialogBox.msgNoWait
  29+ 8E93
  30+ 8E93 21 F5 9A         ld hl, outputBuffer
  30+ 8E96 CD 1B 8F       call VTPL.INIT
  31+ 8E99
  32+ 8E99
  33+ 8E99 3E 01 32 35      ld a, 1, (Render.play_next), a
  33+ 8E9D 67
  34+ 8E9E
  35+ 8E9E                  IFDEF GS
  36+ 8E9E ~                call GeneralSound.stopModule
  37+ 8E9E                  ENDIF
  38+ 8E9E              .loop
  39+ 8E9E 76               halt
  39+ 8E9F F3             di
  39+ 8EA0 CD 3E 97       call VTPL.PLAY
  39+ 8EA3 FB             ei
  40+ 8EA4 AF               xor a
  40+ 8EA5 DB FE          in a, (#fe)
  40+ 8EA7 2F             cpl
  40+ 8EA8 E6 1F          and 31
  40+ 8EAA C2 BF 8E       jp nz, .stopKey
  41+ 8EAD 3A E4 8E         ld a, (VTPL.SETUP)
  41+ 8EB0 17             rla
  41+ 8EB1 30 EB          jr nc, .loop
  42+ 8EB3 3E 01 32 35      ld a, 1, (Render.play_next), a
  42+ 8EB7 67
  43+ 8EB8              .stop
  44+ 8EB8 CD 09 8F         call VTPL.MUTE
  45+ 8EBB
  46+ 8EBB                  IFDEF AY
  47+ 8EBB ~                call restoreAyState
  48+ 8EBB                  ENDIF
  49+ 8EBB
  50+ 8EBB CD 19 68         call Console.waitForKeyUp
  51+ 8EBE C9               ret
  52+ 8EBF              .stopKey
  53+ 8EBF AF               xor a
  53+ 8EC0 32 35 67       ld (Render.play_next), a
  54+ 8EC3 18 F3            jr .stop
  55+ 8EC5
  56+ 8EC5                  IFDEF AY
  57+ 8EC5 ~            restoreAyState:
  58+ 8EC5 ~                ld a, #07
  59+ 8EC5 ~                ld bc, #fffd
  60+ 8EC5 ~                out (c), a
  61+ 8EC5 ~                ld a, #fc
  62+ 8EC5 ~                ld b, #bf
  63+ 8EC5 ~                out (c), a ; Enable read mode
  64+ 8EC5 ~
  65+ 8EC5 ~                ld a, #0e
  66+ 8EC5 ~                ld bc, #fffd
  67+ 8EC5 ~                out (c), a
  68+ 8EC5 ~                ret
  69+ 8EC5              	ENDIF
  70+ 8EC5 50 72 65 73  message db "Press key to stop...", 0
  70+ 8EC9 73 20 6B 65
  70+ 8ECD 79 20 74 6F
  70+ 8ED1 20 73 74 6F
  70+ 8ED5 70 2E 2E 2E
  70+ 8ED9 00
  71+ 8EDA                  ENDMODULE
  72+ 8EDA                  include "player.asm"
# file opened: player/player.asm
   1++8EDA              ;Universal PT2'n'PT3 Turbo Sound player for ZX Spectrum
   2++8EDA              ;(c)2004-2007 S.V.Bulba <vorobey@mail.khstu.ru>
   3++8EDA              ;Specially for AlCo
   4++8EDA              ;http://bulba.untergrund.net/ (http://bulba.at.kz/)
   5++8EDA              	MODULE VTPL
   6++8EDA              ;Release number
   7++8EDA              Release EQU "0"
   8++8EDA              ;Conditional assembly
   9++8EDA              ;1) Current position counters at (Vars1+0) and (Vars2+0)
  10++8EDA              CurPosCounter=0
  11++8EDA              ;2) Allow channels allocation bits at (START+10)
  12++8EDA              ACBBAC=0
  13++8EDA              ;3) Allow loop checking and disabling
  14++8EDA              LoopChecker=1
  15++8EDA              ;4) Insert official identificator
  16++8EDA              Id=0
  17++8EDA              ;5) Set IY for correct return to ZX Basic
  18++8EDA              Basic=1
  19++8EDA
  20++8EDA              ;Features
  21++8EDA              ;--------
  22++8EDA              ;-Can be compiled at any address (i.e. no need rounding ORG
  23++8EDA              ; address).
  24++8EDA              ;-Variables (VARS) can be located at any address (not only after
  25++8EDA              ; code block).
  26++8EDA              ;-INIT subprogram checks PT3-module version and rightly
  27++8EDA              ; generates both note and volume tables outside of code block
  28++8EDA              ; (in VARS).
  29++8EDA              ;-Two portamento (spc. command 3xxx) algorithms (depending of
  30++8EDA              ; PT3 module version).
  31++8EDA              ;-New 1.XX and 2.XX special command behaviour (only for PT v3.7
  32++8EDA              ; and higher).
  33++8EDA              ;-Any Tempo value are accepted (including Tempo=1 and Tempo=2).
  34++8EDA              ;-TS modes: 2xPT3, 2xPT2 and PT v3.7 TS standard.
  35++8EDA              ;-Fully compatible with Ay_Emul PT3 and PT2 players codes.
  36++8EDA              ;-See also notes at the end of this source code.
  37++8EDA
  38++8EDA              ;Limitations
  39++8EDA              ;-----------
  40++8EDA              ;-Can run in RAM only (self-modified code is used).
  41++8EDA              ;-PT2 position list must be end by #FF marker only.
  42++8EDA
  43++8EDA              ;Warning!!! PLAY subprogram can crash if no module are loaded
  44++8EDA              ;into RAM or INIT subprogram was not called before.
  45++8EDA
  46++8EDA              ;Call MUTE or INIT one more time to mute sound after stopping
  47++8EDA              ;playing
  48++8EDA
  49++8EDA              ;Test codes (commented)
  50++8EDA              ;	LD A,32 ;SinglePT3(TS if TSPT3.7),ABC,Looped
  51++8EDA              ;	LD (START+10),A
  52++8EDA              ;	LD HL,#8000 ;Mod1
  53++8EDA              ;	LD DE,#A000 ;Mod2 (optional)
  54++8EDA              ;	CALL START+3
  55++8EDA              ;	EI
  56++8EDA              ;_LP	HALT
  57++8EDA              ;	CALL START+5
  58++8EDA              ;	XOR A
  59++8EDA              ;	IN A,(#FE)
  60++8EDA              ;	CPL
  61++8EDA              ;	AND 15
  62++8EDA              ;	JR Z,_LP
  63++8EDA              ;	JR START+8
  64++8EDA
  65++8EDA              TonA	EQU 0
  66++8EDA              TonB	EQU 2
  67++8EDA              TonC	EQU 4
  68++8EDA              Noise	EQU 6
  69++8EDA              Mixer	EQU 7
  70++8EDA              AmplA	EQU 8
  71++8EDA              AmplB	EQU 9
  72++8EDA              AmplC	EQU 10
  73++8EDA              Env	EQU 11
  74++8EDA              EnvTp	EQU 13
  75++8EDA
  76++8EDA              ;Entry and other points
  77++8EDA              ;START initialize playing of modules at MDLADDR (single module)
  78++8EDA              ;START+3 initialization with module address in HL and DE (TS)
  79++8EDA              ;START+5 play one quark
  80++8EDA              ;START+8 mute
  81++8EDA              ;START+10 setup and status flags
  82++8EDA
  83++8EDA              START:
  84++8EDA 21 F5 9A     	LD HL,outputBuffer ;DE - address of 2nd module for TS
  85++8EDD 18 3C        	JR INIT
  86++8EDF C3 3E 97     	JP PLAY
  87++8EE2 18 25        	JR MUTE
  88++8EE4 00           SETUP	DB 0 ;set bit0, if you want to play without looping
  89++8EE5              	     ;(optional);
  90++8EE5              	     ;set bit1 for PT2 and reset for PT3 before
  91++8EE5              	     ;calling INIT;
  92++8EE5              	     ;bits2-3: %00-ABC, %01-ACB, %10-BAC (optional);
  93++8EE5              	     ;bits4-5: %00-no TS, %01-2 modules TS, %10-
  94++8EE5              	     ;autodetect PT3 TS-format by AlCo (PT 3.7+);
  95++8EE5              	     ;Remark: old PT3 TS-format by AlCo (PT 3.6) is not
  96++8EE5              	     ;documented and must be converted to new standard.
  97++8EE5              	     ;bit6 is set each time, when loop point of 2nd TS
  98++8EE5              	     ;module is passed (optional).
  99++8EE5              	     ;bit7 is set each time, when loop point of 1st TS
 100++8EE5              	     ;or of single module is passed (optional).
 101++8EE5
 102++8EE5              ;Identifier
 103++8EE5              	IF Id
 104++8EE5 ~            	DB "=UniPT2/PT3/TS-Player r.",Release,"="
 105++8EE5              	ENDIF
 106++8EE5
 107++8EE5              	IF LoopChecker
 108++8EE5 21 E4 8E     CHECKLP	LD HL,SETUP
 109++8EE8 FD CB 9E 46  	BIT 0,(IY-100+VRS.ModNum)
 110++8EEC 28 04        	JR Z,CHL1
 111++8EEE CB F6        	SET 6,(HL)
 112++8EF0 18 02        	JR CHL2
 113++8EF2 CB FE        CHL1	SET 7,(HL)
 114++8EF4 CB 46        CHL2	BIT 0,(HL)
 115++8EF6 C8           	RET Z
 116++8EF7 E1           	POP HL
 117++8EF8 FD 34 09     	INC (IY-100+VRS.DelyCnt)
 118++8EFB FD 34 BA     	INC (IY-100+VRS.ChanA+CHP.NtSkCn)
 119++8EFE AF           	XOR A
 120++8EFF FD 77 1D     	LD (IY-100+VRS.AYREGS+AmplA),A
 121++8F02 FD 77 1E     	LD (IY-100+VRS.AYREGS+AmplB),A
 122++8F05 FD 77 1F     	LD (IY-100+VRS.AYREGS+AmplC),A
 123++8F08 C9           	RET
 124++8F09              	ENDIF
 125++8F09
 126++8F09 AF           MUTE: XOR A
 127++8F0A 67           	LD H,A
 128++8F0B 6F           	LD L,A
 129++8F0C 32 93 98     	LD (VARS1+VRS.AYREGS+AmplA),A
 130++8F0F 22 94 98     	LD (VARS1+VRS.AYREGS+AmplB),HL
 131++8F12 32 1A 99     	LD (VARS2+VRS.AYREGS+AmplA),A
 132++8F15 22 1B 99     	LD (VARS2+VRS.AYREGS+AmplB),HL
 133++8F18 C3 56 97     	JP ROUT
 134++8F1B
 135++8F1B              INIT:
 136++8F1B              ;HL - AddressOfModule
 137++8F1B              ;DE - AddresOf2ndModule
 138++8F1B D5           	PUSH DE
 139++8F1C E5           	PUSH HL
 140++8F1D 21 11 98     	LD HL,VARS
 141++8F20 36 00        	LD (HL),0
 142++8F22 11 12 98     	LD DE,VARS+1
 143++8F25 01 0E 01     	LD BC,VAR0END-VARS-1
 144++8F28 ED B0        	LDIR
 145++8F2A 23           	INC HL
 146++8F2B 22 74 98     	LD (VARS1+VRS.AdInPtA),HL ;ptr to zero
 147++8F2E 22 FB 98     	LD (VARS2+VRS.AdInPtA),HL
 148++8F31
 149++8F31 E1           	POP HL
 150++8F32 FD 21 76 98  	LD IY,VARS1+100
 151++8F36 3A E4 8E     	LD A,(START+10)
 152++8F39 E6 02        	AND 2
 153++8F3B C2 C4 8F     	JP NZ,I_PT2
 154++8F3E
 155++8F3E CD 11 91     	CALL INITPT3
 156++8F41 21 18 1F     	LD HL,(e_-SamCnv-2)*256+#18
 157++8F44 22 E4 94     	LD (SamCnv),HL
 158++8F47 3E BA        	LD A,#BA
 159++8F49 32 AF 94     	LD (OrnCP),A
 160++8F4C 32 DB 94     	LD (SamCP),A
 161++8F4F 3E 7B        	LD A,#7B
 162++8F51 32 B2 94     	LD (OrnLD),A
 163++8F54 32 DE 94     	LD (SamLD),A
 164++8F57 3E 87        	LD A,#87
 165++8F59 32 D5 94     	LD (SamClc2),A
 166++8F5C E1           	POP HL
 167++8F5D              	;Use version and ton table of 1st module
 168++8F5D DD 7E A9     	LD A,(IX+13-100) ;EXTRACT VERSION NUMBER
 169++8F60 D6 30        	SUB #30
 170++8F62 38 04        	JR C,L20
 171++8F64 FE 0A        	CP 10
 172++8F66 38 02        	JR C,L21
 173++8F68 3E 06        L20	LD A,6
 174++8F6A 32 82 93     L21	LD (Version),A
 175++8F6D F5           	PUSH AF ;VolTable version
 176++8F6E FE 04        	CP 4
 177++8F70 DD 7E FF     	LD A,(IX+99-100) ;TONE TABLE NUMBER
 178++8F73 17           	RLA
 179++8F74 E6 07        	AND 7
 180++8F76 F5           	PUSH AF ;NoteTable number
 181++8F77
 182++8F77 FD 21 FD 98  	LD IY,VARS2+100
 183++8F7B 3A E4 8E     	LD A,(START+10)
 184++8F7E E6 30        	AND 48
 185++8F80 28 37        	JR Z,NOTS
 186++8F82 FE 10        	CP 16
 187++8F84 28 27        	JR Z,TwoPT3s
 188++8F86 3A 82 93     	LD A,(Version)
 189++8F89 FE 07        	CP 7
 190++8F8B 38 2C        	JR C,NOTS
 191++8F8D DD 7E FE     	LD A,(IX+98-100) ;ALCO TS MARKER
 192++8F90 FE 20        	CP #20
 193++8F92 28 25        	JR Z,NOTS
 194++8F94 21 12 98     	LD HL,VARS1
 195++8F97 11 99 98     	LD DE,VARS2
 196++8F9A 01 87 00     	LD BC,VRS
 197++8F9D ED B0        	LDIR
 198++8F9F FD CB 9E CE  	SET 1,(IY-100+VRS.ModNum)
 199++8FA3 4F           	LD C,A
 200++8FA4 87           	ADD A,A
 201++8FA5 81           	ADD A,C
 202++8FA6 D6 02        	SUB 2
 203++8FA8 32 49 96     	LD (TSSub),A
 204++8FAB 18 03        	JR AlCoTS_
 205++8FAD CD 11 91     TwoPT3s	CALL INITPT3
 206++8FB0 3E 01        AlCoTS_	LD A,1
 207++8FB2 32 11 98     	LD (is_ts),A
 208++8FB5 FD CB 9E C6  	SET 0,(IY-100+VRS.ModNum)
 209++8FB9
 210++8FB9 01 CE 92     NOTS	LD BC,PT3PD
 211++8FBC 21 00 00     	LD HL,0
 212++8FBF 11 D9 97     	LD DE,PT3EMPTYORN
 213++8FC2 18 48        	JR INITCOMMON
 214++8FC4
 215++8FC4 CD 49 91     I_PT2	CALL INITPT2
 216++8FC7 21 CB 51     	LD HL,#51CB
 217++8FCA 22 E4 94     	LD (SamCnv),HL
 218++8FCD 3E BB        	LD A,#BB
 219++8FCF 32 AF 94     	LD (OrnCP),A
 220++8FD2 32 DB 94     	LD (SamCP),A
 221++8FD5 3E 7A        	LD A,#7A
 222++8FD7 32 B2 94     	LD (OrnLD),A
 223++8FDA 32 DE 94     	LD (SamLD),A
 224++8FDD 3E 80        	LD A,#80
 225++8FDF 32 D5 94     	LD (SamClc2),A
 226++8FE2 E1           	POP HL
 227++8FE3 3E 05        	LD A,5
 228++8FE5 32 82 93     	LD (Version),A
 229++8FE8 F5           	PUSH AF
 230++8FE9 3E 02        	LD A,2
 231++8FEB F5           	PUSH AF
 232++8FEC
 233++8FEC 3A E4 8E     	LD A,(START+10)
 234++8FEF E6 30        	AND 48
 235++8FF1 28 10        	JR Z,NOTS2
 236++8FF3
 237++8FF3 FD 21 FD 98  	LD IY,VARS2+100
 238++8FF7 3E 01        	LD A,1
 239++8FF9 32 11 98     	LD (is_ts),A
 240++8FFC FD CB 9E C6  	SET 0,(IY-100+VRS.ModNum)
 241++9000 CD 49 91     	CALL INITPT2
 242++9003
 243++9003 01 08 92     NOTS2	LD BC,PT2PD
 244++9006 21 87 86     	LD HL,#8687
 245++9009 11 2F 99     	LD DE,PT2EMPTYORN
 246++900C
 247++900C              INITCOMMON
 248++900C
 249++900C              	IF Basic
 250++900C FD 21 3A 5C  	LD IY,#5C3A
 251++9010              	ENDIF
 252++9010
 253++9010 ED 43 B9 91  	LD (PTDEC),BC
 254++9014 22 4B 96     	LD (PsCalc),HL
 255++9017 D5           	PUSH DE
 256++9018
 257++9018              ;note table data depacker
 258++9018              ;(c) Ivan Roshin
 259++9018 11 DC 97     	LD DE,T_PACK
 260++901B 01 81 99     	LD BC,T1_+(2*49)-1
 261++901E 1A           TP_0	LD A,(DE)
 262++901F 13           	INC DE
 263++9020 FE 1E        	CP 15*2
 264++9022 30 06        	JR NC,TP_1
 265++9024 67           	LD H,A
 266++9025 1A           	LD A,(DE)
 267++9026 6F           	LD L,A
 268++9027 13           	INC DE
 269++9028 18 07        	JR TP_2
 270++902A D5           TP_1	PUSH DE
 271++902B 16 00        	LD D,0
 272++902D 5F           	LD E,A
 273++902E 19           	ADD HL,DE
 274++902F 19           	ADD HL,DE
 275++9030 D1           	POP DE
 276++9031 7C           TP_2	LD A,H
 277++9032 02           	LD (BC),A
 278++9033 0B           	DEC BC
 279++9034 7D           	LD A,L
 280++9035 02           	LD (BC),A
 281++9036 0B           	DEC BC
player.asm(282): warning: value 0x1F0 is truncated to 8bit value: 0xF0
 282++9037 D6 F0        	SUB #F8*2
 283++9039 20 E3        	JR NZ,TP_0
 284++903B
 285++903B 3C           	INC A
 286++903C 32 7F 98     	LD (VARS1+VRS.DelyCnt),A
 287++903F 32 06 99     	LD (VARS2+VRS.DelyCnt),A
 288++9042 21 01 F0     	LD HL,#F001 ;H - CHP.Volume, L - CHP.NtSkCn
 289++9045 22 30 98     	LD (VARS1+VRS.ChanA+CHP.NtSkCn),HL
 290++9048 22 4D 98     	LD (VARS1+VRS.ChanB+CHP.NtSkCn),HL
 291++904B 22 6A 98     	LD (VARS1+VRS.ChanC+CHP.NtSkCn),HL
 292++904E 22 B7 98     	LD (VARS2+VRS.ChanA+CHP.NtSkCn),HL
 293++9051 22 D4 98     	LD (VARS2+VRS.ChanB+CHP.NtSkCn),HL
 294++9054 22 F1 98     	LD (VARS2+VRS.ChanC+CHP.NtSkCn),HL
 295++9057 E1           	POP HL
 296++9058 22 22 98     	LD (VARS1+VRS.ChanA+CHP.OrnPtr),HL
 297++905B 22 3F 98     	LD (VARS1+VRS.ChanB+CHP.OrnPtr),HL
 298++905E 22 5C 98     	LD (VARS1+VRS.ChanC+CHP.OrnPtr),HL
 299++9061 22 A9 98     	LD (VARS2+VRS.ChanA+CHP.OrnPtr),HL
 300++9064 22 C6 98     	LD (VARS2+VRS.ChanB+CHP.OrnPtr),HL
 301++9067 22 E3 98     	LD (VARS2+VRS.ChanC+CHP.OrnPtr),HL
 302++906A
 303++906A F1           	POP AF
 304++906B
 305++906B              ;NoteTableCreator (c) Ivan Roshin
 306++906B              ;A - NoteTableNumber*2+VersionForNoteTable
 307++906B              ;(xx1b - 3.xx..3.4r, xx0b - 3.4x..3.6x..VTII1.0)
 308++906B
 309++906B 21 89 97     	LD HL,NT_DATA
 310++906E 16 00        	LD D,0
 311++9070 87           	ADD A,A
 312++9071 5F           	LD E,A
 313++9072 19           	ADD HL,DE
 314++9073 5E           	LD E,(HL)
 315++9074 23           	INC HL
 316++9075 CB 3B        	SRL E
 317++9077 9F           	SBC A,A
 318++9078 E6 A7        	AND #A7 ;#00 (NOP) or #A7 (AND A)
 319++907A 32 A2 90     	LD (L3),A
 320++907D EB           	EX DE,HL
 321++907E 01 20 99     	LD BC,T1_
 322++9081 09           	ADD HL,BC
 323++9082
 324++9082 1A           	LD A,(DE)
player.asm(325): warning: value 0x9799 is truncated to 8bit value: 0x99
 325++9083 C6 99        	ADD A,T_
 326++9085 4F           	LD C,A
 327++9086 CE 97        	ADC A,T_/256
 328++9088 91           	SUB C
 329++9089 47           	LD B,A
 330++908A C5           	PUSH BC
 331++908B 11 10 9A     	LD DE,NT_
 332++908E D5           	PUSH DE
 333++908F
 334++908F 06 0C        	LD B,12
 335++9091 C5           L1	PUSH BC
 336++9092 4E           	LD C,(HL)
 337++9093 23           	INC HL
 338++9094 E5           	PUSH HL
 339++9095 46           	LD B,(HL)
 340++9096
 341++9096 D5           	PUSH DE
 342++9097 EB           	EX DE,HL
 343++9098 11 17 00     	LD DE,23
 344++909B DD 26 08     	LD IXH,8
 345++909E
 346++909E CB 38        L2	SRL B
 347++90A0 CB 19        	RR C
 348++90A2 19           L3	DB #19	;AND A or NOP
 349++90A3 79           	LD A,C
 350++90A4 8A           	ADC A,D	;=ADC 0
 351++90A5 77           	LD (HL),A
 352++90A6 23           	INC HL
 353++90A7 78           	LD A,B
 354++90A8 8A           	ADC A,D
 355++90A9 77           	LD (HL),A
 356++90AA 19           	ADD HL,DE
 357++90AB DD 25        	DEC IXH
 358++90AD 20 EF        	JR NZ,L2
 359++90AF
 360++90AF D1           	POP DE
 361++90B0 13           	INC DE
 362++90B1 13           	INC DE
 363++90B2 E1           	POP HL
 364++90B3 23           	INC HL
 365++90B4 C1           	POP BC
 366++90B5 10 DA        	DJNZ L1
 367++90B7
 368++90B7 E1           	POP HL
 369++90B8 D1           	POP DE
 370++90B9
 371++90B9 7B           	LD A,E
player.asm(372): warning: value 0x97A5 is truncated to 8bit value: 0xA5
 372++90BA FE A5        	CP TCOLD_1
 373++90BC 20 05        	JR NZ,CORR_1
 374++90BE 3E FD        	LD A,#FD
 375++90C0 32 3E 9A     	LD (NT_+#2E),A
 376++90C3
 377++90C3 1A           CORR_1	LD A,(DE)
 378++90C4 A7           	AND A
 379++90C5 28 11        	JR Z,TC_EXIT
 380++90C7 1F           	RRA
 381++90C8 F5           	PUSH AF
 382++90C9 87           	ADD A,A
 383++90CA 4F           	LD C,A
 384++90CB 09           	ADD HL,BC
 385++90CC F1           	POP AF
 386++90CD 30 02        	JR NC,CORR_2
 387++90CF 35           	DEC (HL)
 388++90D0 35           	DEC (HL)
 389++90D1 34           CORR_2	INC (HL)
 390++90D2 A7           	AND A
 391++90D3 ED 42        	SBC HL,BC
 392++90D5 13           	INC DE
 393++90D6 18 EB        	JR CORR_1
 394++90D8
 395++90D8              TC_EXIT
 396++90D8
 397++90D8 F1           	POP AF
 398++90D9
 399++90D9              ;VolTableCreator (c) Ivan Roshin
 400++90D9              ;A - VersionForVolumeTable (0..4 - 3.xx..3.4x;
 401++90D9              			   ;5.. - 2.x,3.5x..3.6x..VTII1.0)
 402++90D9
 403++90D9 FE 05        	CP 5
 404++90DB 21 11 00     	LD HL,#11
 405++90DE 54           	LD D,H
 406++90DF 5C           	LD E,H
 407++90E0 3E 17        	LD A,#17
 408++90E2 30 03        	JR NC,M1
 409++90E4 2D           	DEC L
 410++90E5 5D           	LD E,L
 411++90E6 AF           	XOR A
 412++90E7 32 F8 90     M1      LD (M2),A
 413++90EA
 414++90EA DD 21 20 99  	LD IX,VT_+16
 415++90EE
 416++90EE 0E 0F        	LD C,#F
 417++90F0 E5           INITV2  PUSH HL
 418++90F1
 419++90F1 19           	ADD HL,DE
 420++90F2 EB           	EX DE,HL
 421++90F3 ED 62        	SBC HL,HL
 422++90F5
 423++90F5 06 10        	LD B,#10
 424++90F7 7D           INITV1  LD A,L
 425++90F8 7D           M2      DB #7D
 426++90F9 7C           	LD A,H
 427++90FA CE 00        	ADC A,0
 428++90FC DD 77 00     	LD (IX),A
 429++90FF DD 23        	INC IX
 430++9101 19           	ADD HL,DE
 431++9102 10 F3        	DJNZ INITV1
 432++9104
 433++9104 E1           	POP HL
 434++9105 7B           	LD A,E
 435++9106 FE 77        	CP #77
 436++9108 20 01        	JR NZ,M3
 437++910A 1C           	INC E
 438++910B 0D           M3      DEC C
 439++910C 20 E2        	JR NZ,INITV2
 440++910E
 441++910E C3 56 97     	JP ROUT
 442++9111
 443++9111 CD 84 91     INITPT3	CALL SETMDAD
 444++9114 E5           	PUSH HL
 445++9115 11 64 00     	LD DE,100
 446++9118 19           	ADD HL,DE
 447++9119 7E           	LD A,(HL)
 448++911A FD 77 08     	LD (IY-100+VRS.Delay),A
 449++911D E5           	PUSH HL
 450++911E DD E1        	POP IX
 451++9120 19           	ADD HL,DE
 452++9121 CD 92 91     	CALL SETCPPT
 453++9124 DD 5E 02     	LD E,(IX+102-100)
 454++9127 23           	INC HL
 455++9128
 456++9128              	IF CurPosCounter
 457++9128 ~            	LD (IY-100+VRS.PosSub),L
 458++9128              	ENDIF
 459++9128
 460++9128 19           	ADD HL,DE
 461++9129 CD 99 91     	CALL SETLPPT
 462++912C D1           	POP DE
 463++912D DD 6E 03     	LD L,(IX+103-100)
 464++9130 DD 66 04     	LD H,(IX+104-100)
 465++9133 19           	ADD HL,DE
 466++9134 CD 7D 91     	CALL SETPTPT
 467++9137 21 A9 00     	LD HL,169
 468++913A 19           	ADD HL,DE
 469++913B CD 8B 91     	CALL SETORPT
 470++913E 21 69 00     	LD HL,105
 471++9141 19           	ADD HL,DE
 472++9142
 473++9142 FD 75 FA     SETSMPT LD (IY-100+VRS.SamPtrs),L
 474++9145 FD 74 FB     	LD (IY-100+VRS.SamPtrs+1),H
 475++9148 C9           	RET
 476++9149
 477++9149 7E           INITPT2	LD A,(HL)
 478++914A FD 77 08     	LD (IY-100+VRS.Delay),A
 479++914D E5           	PUSH HL
 480++914E E5           	PUSH HL
 481++914F E5           	PUSH HL
 482++9150 23           	INC HL
 483++9151 23           	INC HL
 484++9152 7E           	LD A,(HL)
 485++9153 23           	INC HL
 486++9154 CD 42 91     	CALL SETSMPT
 487++9157 5E           	LD E,(HL)
 488++9158 23           	INC HL
 489++9159 56           	LD D,(HL)
 490++915A E1           	POP HL
 491++915B A7           	AND A
 492++915C ED 52        	SBC HL,DE
 493++915E CD 84 91     	CALL SETMDAD
 494++9161 E1           	POP HL
 495++9162 11 43 00     	LD DE,67
 496++9165 19           	ADD HL,DE
 497++9166 CD 8B 91     	CALL SETORPT
 498++9169 1E 20        	LD E,32
 499++916B 19           	ADD HL,DE
 500++916C 4E           	LD C,(HL)
 501++916D 23           	INC HL
 502++916E 46           	LD B,(HL)
 503++916F 1E 1E        	LD E,30
 504++9171 19           	ADD HL,DE
 505++9172 CD 92 91     	CALL SETCPPT
 506++9175 5F           	LD E,A
 507++9176 23           	INC HL
 508++9177
 509++9177              	IF CurPosCounter
 510++9177 ~            	LD (IY-100+VRS.PosSub),L
 511++9177              	ENDIF
 512++9177
 513++9177 19           	ADD HL,DE
 514++9178 CD 99 91     	CALL SETLPPT
 515++917B E1           	POP HL
 516++917C 09           	ADD HL,BC
 517++917D
 518++917D FD 75 FC     SETPTPT	LD (IY-100+VRS.PatsPtr),L
 519++9180 FD 74 FD     	LD (IY-100+VRS.PatsPtr+1),H
 520++9183 C9           	RET
 521++9184
 522++9184 FD 75 F6     SETMDAD	LD (IY-100+VRS.MODADDR),L
 523++9187 FD 74 F7     	LD (IY-100+VRS.MODADDR+1),H
 524++918A C9           	RET
 525++918B
 526++918B FD 75 F8     SETORPT	LD (IY-100+VRS.OrnPtrs),L
 527++918E FD 74 F9     	LD (IY-100+VRS.OrnPtrs+1),H
 528++9191 C9           	RET
 529++9192
 530++9192 FD 75 04     SETCPPT	LD (IY-100+VRS.CrPsPtr),L
 531++9195 FD 74 05     	LD (IY-100+VRS.CrPsPtr+1),H
 532++9198 C9           	RET
 533++9199
 534++9199 FD 75 06     SETLPPT	LD (IY-100+VRS.LPosPtr),L
 535++919C FD 74 07     	LD (IY-100+VRS.LPosPtr+1),H
 536++919F C9           	RET
 537++91A0
 538++91A0 FD 75 13     SETENBS	LD (IY-100+VRS.EnvBase),L
 539++91A3 FD 74 14     	LD (IY-100+VRS.EnvBase+1),H
 540++91A6 C9           	RET
 541++91A7
 542++91A7 FD 75 0C     SETESLD	LD (IY-100+VRS.CurESld),L
 543++91AA FD 74 0D     	LD (IY-100+VRS.CurESld+1),H
 544++91AD C9           	RET
 545++91AE
 546++91AE FD E5        GETIX	PUSH IY
 547++91B0 DD E1        	POP IX
 548++91B2 DD 19        	ADD IX,DE
 549++91B4 C9           	RET
 550++91B5
 551++91B5 CD AE 91     PTDECOD CALL GETIX
 552++91B8              PTDEC	EQU $+1
 553++91B8 C3 C3 C3     	JP #C3C3
 554++91BB
 555++91BB              ;PT2 pattern decoder
 556++91BB CD 51 94     PD2_SAM	CALL SETSAM
 557++91BE 18 4A        	JR PD2_LOOP
 558++91C0
 559++91C0 DD 77 08     PD2_EOff LD (IX-12+CHP.Env_En),A
 560++91C3 18 45        	JR PD2_LOOP
 561++91C5
 562++91C5 DD 36 08 10  PD2_ENV	LD (IX-12+CHP.Env_En),16
 563++91C9 FD 77 22     	LD (IY-100+VRS.AYREGS+EnvTp),A
 564++91CC 0A           	LD A,(BC)
 565++91CD 03           	INC BC
 566++91CE 6F           	LD L,A
 567++91CF 0A           	LD A,(BC)
 568++91D0 03           	INC BC
 569++91D1 67           	LD H,A
 570++91D2 CD A0 91     	CALL SETENBS
 571++91D5 18 33        	JR PD2_LOOP
 572++91D7
 573++91D7 CD 32 94     PD2_ORN	CALL SETORN
 574++91DA 18 2E        	JR PD2_LOOP
 575++91DC
 576++91DC 3C           PD2_SKIP INC A
 577++91DD DD 77 05     	LD (IX-12+CHP.NNtSkp),A
 578++91E0 18 28        	JR PD2_LOOP
 579++91E2
 580++91E2 0F           PD2_VOL	RRCA
 581++91E3 0F           	RRCA
 582++91E4 0F           	RRCA
 583++91E5 0F           	RRCA
 584++91E6 DD 77 10     	LD (IX-12+CHP.Volume),A
 585++91E9 18 1F        	JR PD2_LOOP
 586++91EB
 587++91EB CD 02 94     PD2_DEL	CALL C_DELAY
 588++91EE 18 1A        	JR PD2_LOOP
 589++91F0
 590++91F0 DD CB 09 D6  PD2_GLIS SET 2,(IX-12+CHP.Flags)
 591++91F4 3C           	INC A
 592++91F5 DD 77 0A     	LD (IX-12+CHP.TnSlDl),A
 593++91F8 DD 77 F9     	LD (IX-12+CHP.TSlCnt),A
 594++91FB 0A           	LD A,(BC)
 595++91FC 03           	INC BC
 596++91FD DD 77 0B             LD (IX-12+CHP.TSlStp),A
 597++9200 87           	ADD A,A
 598++9201 9F           	SBC A,A
 599++9202 DD 77 0C             LD (IX-12+CHP.TSlStp+1),A
 600++9205 37           	SCF
 601++9206 18 01        	JR PD2_LP2
 602++9208
 603++9208 A7           PT2PD	AND A
 604++9209
 605++9209 08           PD2_LP2	EX AF,AF'
 606++920A
 607++920A 0A           PD2_LOOP LD A,(BC)
 608++920B 03           	INC BC
 609++920C C6 20        	ADD A,#20
 610++920E 28 3F        	JR Z,PD2_REL
 611++9210 38 A9        	JR C,PD2_SAM
 612++9212 C6 60        	ADD A,96
 613++9214 38 3E        	JR C,PD2_NOTE
 614++9216 3C           	INC A
 615++9217 28 A7        	JR Z,PD2_EOff
 616++9219 C6 0F        	ADD A,15
 617++921B CA 31 93     	JP Z,PD_FIN
 618++921E 38 A5        	JR C,PD2_ENV
 619++9220 C6 10        	ADD A,#10
 620++9222 38 B3        	JR C,PD2_ORN
 621++9224 C6 40        	ADD A,#40
 622++9226 38 B4        	JR C,PD2_SKIP
 623++9228 C6 10        	ADD A,#10
 624++922A 38 B6        	JR C,PD2_VOL
 625++922C 3C           	INC A
 626++922D 28 BC        	JR Z,PD2_DEL
 627++922F 3C           	INC A
 628++9230 28 BE        	JR Z,PD2_GLIS
 629++9232 3C           	INC A
 630++9233 28 0A        	JR Z,PD2_PORT
 631++9235 3C           	INC A
 632++9236 28 12        	JR Z,PD2_STOP
 633++9238 0A           	LD A,(BC)
 634++9239 03           	INC BC
 635++923A DD 77 F7     	LD (IX-12+CHP.CrNsSl),A
 636++923D 18 CB        	JR PD2_LOOP
 637++923F
 638++923F DD CB 09 96  PD2_PORT RES 2,(IX-12+CHP.Flags)
 639++9243 0A           	LD A,(BC)
 640++9244 03           	INC BC
 641++9245 03           	INC BC ;ignoring precalc delta to right sound
 642++9246 03           	INC BC
 643++9247 37           	SCF
 644++9248 18 BF        	JR PD2_LP2
 645++924A
 646++924A DD 77 F9     PD2_STOP LD (IX-12+CHP.TSlCnt),A
 647++924D 18 BB        	JR PD2_LOOP
 648++924F
 649++924F DD 77 09     PD2_REL	LD (IX-12+CHP.Flags),A
 650++9252 18 2C        	JR PD2_EXIT
 651++9254
 652++9254 6F           PD2_NOTE LD L,A
 653++9255 DD 7E 06     	LD A,(IX-12+CHP.Note)
 654++9258 32 6B 93     	LD (PrNote+1),A
 655++925B DD 75 06     	LD (IX-12+CHP.Note),L
 656++925E AF           	XOR A
 657++925F DD 77 F9     	LD (IX-12+CHP.TSlCnt),A
 658++9262 DD CB 09 C6  	SET 0,(IX-12+CHP.Flags)
 659++9266 08           	EX AF,AF'
 660++9267 30 16        	JR NC,NOGLIS2
 661++9269 DD CB 09 56  	BIT 2,(IX-12+CHP.Flags)
 662++926D 20 0C        	JR NZ,NOPORT2
 663++926F 32 91 93     	LD (LoStep),A
 664++9272 87           	ADD A,A
 665++9273 9F           	SBC A,A
 666++9274 08           	EX AF,AF'
 667++9275 67           	LD H,A
 668++9276 6F           	LD L,A
 669++9277 3C           	INC A
 670++9278 CD 4C 93     	CALL SETPORT
 671++927B DD 36 F9 01  NOPORT2	LD (IX-12+CHP.TSlCnt),1
 672++927F AF           NOGLIS2	XOR A
 673++9280
 674++9280
 675++9280 DD 77 F5     PD2_EXIT LD (IX-12+CHP.PsInSm),A
 676++9283 DD 77 F4     	LD (IX-12+CHP.PsInOr),A
 677++9286 DD 77 FA     	LD (IX-12+CHP.CrTnSl),A
 678++9289 DD 77 FB     	LD (IX-12+CHP.CrTnSl+1),A
 679++928C C3 31 93     	JP PD_FIN
 680++928F
 681++928F              ;PT3 pattern decoder
 682++928F DD 36 08 00  PD_OrSm	LD (IX-12+CHP.Env_En),0
 683++9293 CD 32 94     	CALL SETORN
 684++9296 0A           PD_SAM_	LD A,(BC)
 685++9297 03           	INC BC
 686++9298 0F           	RRCA
 687++9299
 688++9299 CD 51 94     PD_SAM	CALL SETSAM
 689++929C 18 3F        	JR PD_LOOP
 690++929E
 691++929E 0F           PD_VOL	RRCA
 692++929F 0F           	RRCA
 693++92A0 0F           	RRCA
 694++92A1 0F           	RRCA
 695++92A2 DD 77 10     	LD (IX-12+CHP.Volume),A
 696++92A5 18 39        	JR PD_LP2
 697++92A7
 698++92A7 DD 77 08     PD_EOff	LD (IX-12+CHP.Env_En),A
 699++92AA DD 77 F4     	LD (IX-12+CHP.PsInOr),A
 700++92AD 18 31        	JR PD_LP2
 701++92AF
 702++92AF 3D           PD_SorE	DEC A
 703++92B0 20 07        	JR NZ,PD_ENV
 704++92B2 0A           	LD A,(BC)
 705++92B3 03           	INC BC
 706++92B4 DD 77 05     	LD (IX-12+CHP.NNtSkp),A
 707++92B7 18 27        	JR PD_LP2
 708++92B9
 709++92B9 CD 17 94     PD_ENV	CALL SETENV
 710++92BC 18 22        	JR PD_LP2
 711++92BE
 712++92BE CD 32 94     PD_ORN	CALL SETORN
 713++92C1 18 1A        	JR PD_LOOP
 714++92C3
 715++92C3 DD 77 08     PD_ESAM	LD (IX-12+CHP.Env_En),A
 716++92C6 DD 77 F4     	LD (IX-12+CHP.PsInOr),A
 717++92C9 C4 17 94     	CALL NZ,SETENV
 718++92CC 18 C8        	JR PD_SAM_
 719++92CE
 720++92CE DD 7E 06     PT3PD	LD A,(IX-12+CHP.Note)
 721++92D1 32 6B 93     	LD (PrNote+1),A
 722++92D4 DD 6E FA     	LD L,(IX-12+CHP.CrTnSl)
 723++92D7 DD 66 FB     	LD H,(IX-12+CHP.CrTnSl+1)
 724++92DA 22 88 93     	LD (PrSlide+1),HL
 725++92DD
 726++92DD 11 10 20     PD_LOOP	LD DE,#2010
 727++92E0 0A           PD_LP2	LD A,(BC)
 728++92E1 03           	INC BC
 729++92E2 83           	ADD A,E
 730++92E3 38 AA        	JR C,PD_OrSm
 731++92E5 82           	ADD A,D
 732++92E6 28 49        	JR Z,PD_FIN
 733++92E8 38 AF        	JR C,PD_SAM
 734++92EA 83           	ADD A,E
 735++92EB 28 25        	JR Z,PD_REL
 736++92ED 38 AF        	JR C,PD_VOL
 737++92EF 83           	ADD A,E
 738++92F0 28 B5        	JR Z,PD_EOff
 739++92F2 38 BB        	JR C,PD_SorE
 740++92F4 C6 60        	ADD A,96
 741++92F6 38 20        	JR C,PD_NOTE
 742++92F8 83           	ADD A,E
 743++92F9 38 C3        	JR C,PD_ORN
 744++92FB 82           	ADD A,D
 745++92FC 38 0F        	JR C,PD_NOIS
 746++92FE 83           	ADD A,E
 747++92FF 38 C2        	JR C,PD_ESAM
 748++9301 87           	ADD A,A
 749++9302 5F           	LD E,A
player.asm(750): warning: value 0x1738D is truncated to 16bit value: 0x738D
 750++9303 21 8D 73     	LD HL,SPCCOMS+#FF20-#2000
 751++9306 19           	ADD HL,DE
 752++9307 5E           	LD E,(HL)
 753++9308 23           	INC HL
 754++9309 56           	LD D,(HL)
 755++930A D5           	PUSH DE
 756++930B 18 D0        	JR PD_LOOP
 757++930D
 758++930D FD 77 10     PD_NOIS	LD (IY-100+VRS.Ns_Base),A
 759++9310 18 CE        	JR PD_LP2
 760++9312
 761++9312 DD CB 09 86  PD_REL	RES 0,(IX-12+CHP.Flags)
 762++9316 18 08        	JR PD_RES
 763++9318
 764++9318 DD 77 06     PD_NOTE	LD (IX-12+CHP.Note),A
 765++931B DD CB 09 C6  	SET 0,(IX-12+CHP.Flags)
 766++931F AF           	XOR A
 767++9320
 768++9320 ED 73 2F 93  PD_RES	LD (PDSP_+1),SP
 769++9324 DD F9        	LD SP,IX
 770++9326 67           	LD H,A
 771++9327 6F           	LD L,A
 772++9328 E5           	PUSH HL
 773++9329 E5           	PUSH HL
 774++932A E5           	PUSH HL
 775++932B E5           	PUSH HL
 776++932C E5           	PUSH HL
 777++932D E5           	PUSH HL
 778++932E 31 31 31     PDSP_	LD SP,#3131
 779++9331
 780++9331 DD 7E 05     PD_FIN	LD A,(IX-12+CHP.NNtSkp)
 781++9334 DD 77 0F     	LD (IX-12+CHP.NtSkCn),A
 782++9337 C9           	RET
 783++9338
 784++9338 0A           C_PORTM LD A,(BC)
 785++9339 03           	INC BC
 786++933A              ;SKIP PRECALCULATED TONE DELTA (BECAUSE
 787++933A              ;CANNOT BE RIGHT AFTER PT3 COMPILATION)
 788++933A 03           	INC BC
 789++933B 03           	INC BC
 790++933C 08           	EX AF,AF'
 791++933D 0A           	LD A,(BC) ;SIGNED TONE STEP
 792++933E 03           	INC BC
 793++933F 32 91 93     	LD (LoStep),A
 794++9342 0A           	LD A,(BC)
 795++9343 03           	INC BC
 796++9344 A7           	AND A
 797++9345 08           	EX AF,AF'
 798++9346 DD 6E FA     	LD L,(IX-12+CHP.CrTnSl)
 799++9349 DD 66 FB     	LD H,(IX-12+CHP.CrTnSl+1)
 800++934C
 801++934C              ;Set portamento variables
 802++934C              ;A - Delay; A' - Hi(Step); ZF' - (A'=0); HL - CrTnSl
 803++934C
 804++934C DD CB 09 96  SETPORT	RES 2,(IX-12+CHP.Flags)
 805++9350 DD 77 0A     	LD (IX-12+CHP.TnSlDl),A
 806++9353 DD 77 F9     	LD (IX-12+CHP.TSlCnt),A
 807++9356 E5           	PUSH HL
 808++9357 11 10 9A     	LD DE,NT_
 809++935A DD 7E 06     	LD A,(IX-12+CHP.Note)
 810++935D DD 77 07     	LD (IX-12+CHP.SlToNt),A
 811++9360 87           	ADD A,A
 812++9361 6F           	LD L,A
 813++9362 26 00        	LD H,0
 814++9364 19           	ADD HL,DE
 815++9365 7E           	LD A,(HL)
 816++9366 23           	INC HL
 817++9367 66           	LD H,(HL)
 818++9368 6F           	LD L,A
 819++9369 E5           	PUSH HL
 820++936A 3E 3E        PrNote	LD A,#3E
 821++936C DD 77 06     	LD (IX-12+CHP.Note),A
 822++936F 87           	ADD A,A
 823++9370 6F           	LD L,A
 824++9371 26 00        	LD H,0
 825++9373 19           	ADD HL,DE
 826++9374 5E           	LD E,(HL)
 827++9375 23           	INC HL
 828++9376 56           	LD D,(HL)
 829++9377 E1           	POP HL
 830++9378 ED 52        	SBC HL,DE
 831++937A DD 75 0D     	LD (IX-12+CHP.TnDelt),L
 832++937D DD 74 0E     	LD (IX-12+CHP.TnDelt+1),H
 833++9380 D1           	POP DE
 834++9381              Version EQU $+1
 835++9381 3E 3E        	LD A,#3E
 836++9383 FE 06        	CP 6
 837++9385 38 09        	JR C,OLDPRTM ;Old 3xxx for PT v3.5-
 838++9387 11 11 11     PrSlide	LD DE,#1111
 839++938A DD 73 FA     	LD (IX-12+CHP.CrTnSl),E
 840++938D DD 72 FB     	LD (IX-12+CHP.CrTnSl+1),D
 841++9390              LoStep	EQU $+1
 842++9390 3E 3E        OLDPRTM	LD A,#3E
 843++9392 08           	EX AF,AF'
 844++9393 28 01        	JR Z,NOSIG
 845++9395 EB           	EX DE,HL
 846++9396 ED 52        NOSIG	SBC HL,DE
 847++9398 F2 A0 93     	JP P,SET_STP
 848++939B 2F           	CPL
 849++939C 08           	EX AF,AF'
 850++939D ED 44        	NEG
 851++939F 08           	EX AF,AF'
 852++93A0 DD 77 0C     SET_STP	LD (IX-12+CHP.TSlStp+1),A
 853++93A3 08           	EX AF,AF'
 854++93A4 DD 77 0B     	LD (IX-12+CHP.TSlStp),A
 855++93A7 DD 36 FE 00  	LD (IX-12+CHP.COnOff),0
 856++93AB C9           	RET
 857++93AC
 858++93AC DD CB 09 D6  C_GLISS	SET 2,(IX-12+CHP.Flags)
 859++93B0 0A           	LD A,(BC)
 860++93B1 03           	INC BC
 861++93B2 DD 77 0A     	LD (IX-12+CHP.TnSlDl),A
 862++93B5 A7           	AND A
 863++93B6 20 07        	JR NZ,GL36
 864++93B8 3A 82 93     	LD A,(Version) ;AlCo PT3.7+
 865++93BB FE 07        	CP 7
 866++93BD 9F           	SBC A,A
 867++93BE 3C           	INC A
 868++93BF DD 77 F9     GL36	LD (IX-12+CHP.TSlCnt),A
 869++93C2 0A           	LD A,(BC)
 870++93C3 03           	INC BC
 871++93C4 08           	EX AF,AF'
 872++93C5 0A           	LD A,(BC)
 873++93C6 03           	INC BC
 874++93C7 18 D7        	JR SET_STP
 875++93C9
 876++93C9 0A           C_SMPOS	LD A,(BC)
 877++93CA 03           	INC BC
 878++93CB DD 77 F5     	LD (IX-12+CHP.PsInSm),A
 879++93CE C9           	RET
 880++93CF
 881++93CF 0A           C_ORPOS	LD A,(BC)
 882++93D0 03           	INC BC
 883++93D1 DD 77 F4     	LD (IX-12+CHP.PsInOr),A
 884++93D4 C9           	RET
 885++93D5
 886++93D5 0A           C_VIBRT	LD A,(BC)
 887++93D6 03           	INC BC
 888++93D7 DD 77 FF     	LD (IX-12+CHP.OnOffD),A
 889++93DA DD 77 FE     	LD (IX-12+CHP.COnOff),A
 890++93DD 0A           	LD A,(BC)
 891++93DE 03           	INC BC
 892++93DF DD 77 00     	LD (IX-12+CHP.OffOnD),A
 893++93E2 AF           	XOR A
 894++93E3 DD 77 F9     	LD (IX-12+CHP.TSlCnt),A
 895++93E6 DD 77 FA     	LD (IX-12+CHP.CrTnSl),A
 896++93E9 DD 77 FB     	LD (IX-12+CHP.CrTnSl+1),A
 897++93EC C9           	RET
 898++93ED
 899++93ED 0A           C_ENGLS	LD A,(BC)
 900++93EE 03           	INC BC
 901++93EF FD 77 0E     	LD (IY-100+VRS.Env_Del),A
 902++93F2 FD 77 0F     	LD (IY-100+VRS.CurEDel),A
 903++93F5 0A           	LD A,(BC)
 904++93F6 03           	INC BC
 905++93F7 6F           	LD L,A
 906++93F8 0A           	LD A,(BC)
 907++93F9 03           	INC BC
 908++93FA 67           	LD H,A
 909++93FB FD 75 0A     	LD (IY-100+VRS.ESldAdd),L
 910++93FE FD 74 0B     	LD (IY-100+VRS.ESldAdd+1),H
 911++9401 C9           	RET
 912++9402
 913++9402 0A           C_DELAY	LD A,(BC)
 914++9403 03           	INC BC
 915++9404 FD 77 08     	LD (IY-100+VRS.Delay),A
 916++9407 21 9B 98     	LD HL,VARS2+VRS.ModNum ;if AlCo_TS
 917++940A CB 4E        	BIT 1,(HL)
 918++940C C8           	RET Z
 919++940D 32 7E 98     	LD (VARS1+VRS.Delay),A
 920++9410 32 7F 98     	LD (VARS1+VRS.DelyCnt),A
 921++9413 32 05 99     	LD (VARS2+VRS.Delay),A
 922++9416 C9           	RET
 923++9417
 924++9417 DD 73 08     SETENV	LD (IX-12+CHP.Env_En),E
 925++941A FD 77 22     	LD (IY-100+VRS.AYREGS+EnvTp),A
 926++941D 0A           	LD A,(BC)
 927++941E 03           	INC BC
 928++941F 67           	LD H,A
 929++9420 0A           	LD A,(BC)
 930++9421 03           	INC BC
 931++9422 6F           	LD L,A
 932++9423 CD A0 91     	CALL SETENBS
 933++9426 AF           	XOR A
 934++9427 DD 77 F4     	LD (IX-12+CHP.PsInOr),A
 935++942A FD 77 0F     	LD (IY-100+VRS.CurEDel),A
 936++942D 67           	LD H,A
 937++942E 6F           	LD L,A
 938++942F C3 A7 91     	JP SETESLD
 939++9432
 940++9432 87           SETORN	ADD A,A
 941++9433 5F           	LD E,A
 942++9434 16 00        	LD D,0
 943++9436 DD 72 F4     	LD (IX-12+CHP.PsInOr),D
 944++9439 FD 6E F8     	LD L,(IY-100+VRS.OrnPtrs)
 945++943C FD 66 F9     	LD H,(IY-100+VRS.OrnPtrs+1)
 946++943F 19           	ADD HL,DE
 947++9440 5E           	LD E,(HL)
 948++9441 23           	INC HL
 949++9442 56           	LD D,(HL)
 950++9443 FD 6E F6     	LD L,(IY-100+VRS.MODADDR)
 951++9446 FD 66 F7     	LD H,(IY-100+VRS.MODADDR+1)
 952++9449 19           	ADD HL,DE
 953++944A DD 75 01     	LD (IX-12+CHP.OrnPtr),L
 954++944D DD 74 02     	LD (IX-12+CHP.OrnPtr+1),H
 955++9450 C9           C_NOP	RET
 956++9451
 957++9451 87           SETSAM	ADD A,A
 958++9452 5F           	LD E,A
 959++9453 16 00        	LD D,0
 960++9455 FD 6E FA     	LD L,(IY-100+VRS.SamPtrs);
 961++9458 FD 66 FB     	LD H,(IY-100+VRS.SamPtrs+1);
 962++945B 19           	ADD HL,DE
 963++945C 5E           	LD E,(HL)
 964++945D 23           	INC HL
 965++945E 56           	LD D,(HL)
 966++945F FD 6E F6     	LD L,(IY-100+VRS.MODADDR)
 967++9462 FD 66 F7     	LD H,(IY-100+VRS.MODADDR+1)
 968++9465 19           	ADD HL,DE
 969++9466 DD 75 03     	LD (IX-12+CHP.SamPtr),L
 970++9469 DD 74 04     	LD (IX-12+CHP.SamPtr+1),H
 971++946C C9           	RET
 972++946D
 973++946D              ;ALL 16 ADDRESSES TO PROTECT FROM BROKEN PT3 MODULES
 974++946D 50 94        SPCCOMS DW C_NOP
 975++946F AC 93        	DW C_GLISS
 976++9471 38 93        	DW C_PORTM
 977++9473 C9 93        	DW C_SMPOS
 978++9475 CF 93        	DW C_ORPOS
 979++9477 D5 93        	DW C_VIBRT
 980++9479 50 94        	DW C_NOP
 981++947B 50 94        	DW C_NOP
 982++947D ED 93        	DW C_ENGLS
 983++947F 02 94        	DW C_DELAY
 984++9481 50 94        	DW C_NOP
 985++9483 50 94        	DW C_NOP
 986++9485 50 94        	DW C_NOP
 987++9487 50 94        	DW C_NOP
 988++9489 50 94        	DW C_NOP
 989++948B 50 94        	DW C_NOP
 990++948D
 991++948D CD AE 91     CHREGS	CALL GETIX
 992++9490 AF           	XOR A
 993++9491 32 CD 96     	LD (Ampl),A
 994++9494 DD CB 15 46  	BIT 0,(IX+CHP.Flags)
 995++9498 E5           	PUSH HL
 996++9499 CA E0 95     	JP Z,CH_EXIT
 997++949C ED 73 2A 95  	LD (CSP_+1),SP
 998++94A0 DD 6E 0D     	LD L,(IX+CHP.OrnPtr)
 999++94A3 DD 66 0E     	LD H,(IX+CHP.OrnPtr+1)
1000++94A6 F9           	LD SP,HL
1001++94A7 D1           	POP DE
1002++94A8 67           	LD H,A
1003++94A9 DD 7E 00     	LD A,(IX+CHP.PsInOr)
1004++94AC 6F           	LD L,A
1005++94AD 39           	ADD HL,SP
1006++94AE 3C           	INC A
1007++94AF              		;PT2	PT3
1008++94AF 3C           OrnCP	INC A	;CP E	CP D
1009++94B0 38 01        	JR C,CH_ORPS
1010++94B2 01           OrnLD	DB 1	;LD A,D	LD A,E
1011++94B3 DD 77 00     CH_ORPS	LD (IX+CHP.PsInOr),A
1012++94B6 DD 7E 12     	LD A,(IX+CHP.Note)
1013++94B9 86           	ADD A,(HL)
1014++94BA F2 BE 94     	JP P,CH_NTP
1015++94BD AF           	XOR A
1016++94BE FE 60        CH_NTP	CP 96
1017++94C0 38 02        	JR C,CH_NOK
1018++94C2 3E 5F        	LD A,95
1019++94C4 87           CH_NOK	ADD A,A
1020++94C5 08           	EX AF,AF'
1021++94C6 DD 6E 0F     	LD L,(IX+CHP.SamPtr)
1022++94C9 DD 66 10     	LD H,(IX+CHP.SamPtr+1)
1023++94CC F9           	LD SP,HL
1024++94CD D1           	POP DE
1025++94CE 26 00        	LD H,0
1026++94D0 DD 7E 01     	LD A,(IX+CHP.PsInSm)
1027++94D3 47           	LD B,A
1028++94D4 87           	ADD A,A
1029++94D5 87           SamClc2	ADD A,A ;or ADD A,B for PT2
1030++94D6 6F           	LD L,A
1031++94D7 39           	ADD HL,SP
1032++94D8 F9           	LD SP,HL
1033++94D9 78           	LD A,B
1034++94DA 3C           	INC A
1035++94DB              		;PT2	PT3
1036++94DB 3C           SamCP	INC A	;CP E	CP D
1037++94DC 38 01        	JR C,CH_SMPS
1038++94DE 01           SamLD	DB 1	;LD A,D	LD A,E
1039++94DF DD 77 01     CH_SMPS	LD (IX+CHP.PsInSm),A
1040++94E2 C1           	POP BC
1041++94E3 E1           	POP HL
1042++94E4
1043++94E4              ;Convert PT2 sample to PT3
1044++94E4              		;PT2		PT3
1045++94E4 E1           SamCnv	POP HL  ;BIT 2,C	JR e_
1046++94E5 E1           	POP HL
1047++94E6 60           	LD H,B
1048++94E7 20 06        	JR NZ,$+8
1049++94E9 EB           	EX DE,HL
1050++94EA A7           	AND A
1051++94EB ED 62        	SBC HL,HL
1052++94ED ED 52        	SBC HL,DE
1053++94EF 51           	LD D,C
1054++94F0 CB 19        	RR C
1055++94F2 9F           	SBC A,A
1056++94F3 2F           	CPL
1057++94F4 E6 3E        	AND #3E
1058++94F6 CB 19        	RR C
1059++94F8 CB 18        	RR B
1060++94FA A1           	AND C
1061++94FB 4F           	LD C,A
1062++94FC 78           	LD A,B
1063++94FD 1F           	RRA
1064++94FE 1F           	RRA
1065++94FF CB 1A        	RR D
1066++9501 1F           	RRA
1067++9502 E6 9F        	AND #9F
1068++9504 47           	LD B,A
1069++9505
1070++9505 DD 5E 08     e_	LD E,(IX+CHP.TnAcc)
1071++9508 DD 56 09     	LD D,(IX+CHP.TnAcc+1)
1072++950B 19           	ADD HL,DE
1073++950C CB 70        	BIT 6,B
1074++950E 28 06        	JR Z,CH_NOAC
1075++9510 DD 75 08     	LD (IX+CHP.TnAcc),L
1076++9513 DD 74 09     	LD (IX+CHP.TnAcc+1),H
1077++9516 EB           CH_NOAC EX DE,HL
1078++9517 08           	EX AF,AF'
player.asm(1079): warning: value 0x9A10 is truncated to 8bit value: 0x10
1079++9518 C6 10        	ADD A,NT_
1080++951A 6F           	LD L,A
1081++951B CE 9A        	ADC A,NT_/256
1082++951D 95           	SUB L
1083++951E 67           	LD H,A
1084++951F F9           	LD SP,HL
1085++9520 E1           	POP HL
1086++9521 19           	ADD HL,DE
1087++9522 DD 5E 06     	LD E,(IX+CHP.CrTnSl)
1088++9525 DD 56 07     	LD D,(IX+CHP.CrTnSl+1)
1089++9528 19           	ADD HL,DE
1090++9529 31 31 31     CSP_	LD SP,#3131
1091++952C E3           	EX (SP),HL
1092++952D AF           	XOR A
1093++952E DD B6 05     	OR (IX+CHP.TSlCnt)
1094++9531 28 3E        	JR Z,CH_AMP
1095++9533 DD 35 05     	DEC (IX+CHP.TSlCnt)
1096++9536 20 39        	JR NZ,CH_AMP
1097++9538 DD 7E 16     	LD A,(IX+CHP.TnSlDl)
1098++953B DD 77 05     	LD (IX+CHP.TSlCnt),A
1099++953E DD 6E 17     	LD L,(IX+CHP.TSlStp)
1100++9541 DD 66 18     	LD H,(IX+CHP.TSlStp+1)
1101++9544 7C           	LD A,H
1102++9545 19           	ADD HL,DE
1103++9546 DD 75 06     	LD (IX+CHP.CrTnSl),L
1104++9549 DD 74 07     	LD (IX+CHP.CrTnSl+1),H
1105++954C DD CB 15 56  	BIT 2,(IX+CHP.Flags)
1106++9550 20 1F        	JR NZ,CH_AMP
1107++9552 DD 5E 19     	LD E,(IX+CHP.TnDelt)
1108++9555 DD 56 1A     	LD D,(IX+CHP.TnDelt+1)
1109++9558 A7           	AND A
1110++9559 28 01        	JR Z,CH_STPP
1111++955B EB           	EX DE,HL
1112++955C ED 52        CH_STPP SBC HL,DE
1113++955E FA 71 95     	JP M,CH_AMP
1114++9561 DD 7E 13     	LD A,(IX+CHP.SlToNt)
1115++9564 DD 77 12     	LD (IX+CHP.Note),A
1116++9567 AF           	XOR A
1117++9568 DD 77 05     	LD (IX+CHP.TSlCnt),A
1118++956B DD 77 06     	LD (IX+CHP.CrTnSl),A
1119++956E DD 77 07     	LD (IX+CHP.CrTnSl+1),A
1120++9571 DD 7E 02     CH_AMP	LD A,(IX+CHP.CrAmSl)
1121++9574 CB 79        	BIT 7,C
1122++9576 28 13        	JR Z,CH_NOAM
1123++9578 CB 71        	BIT 6,C
1124++957A 28 07        	JR Z,CH_AMIN
1125++957C FE 0F        	CP 15
1126++957E 28 0B        	JR Z,CH_NOAM
1127++9580 3C           	INC A
1128++9581 18 05        	JR CH_SVAM
1129++9583 FE F1        CH_AMIN	CP -15
1130++9585 28 04        	JR Z,CH_NOAM
1131++9587 3D           	DEC A
1132++9588 DD 77 02     CH_SVAM	LD (IX+CHP.CrAmSl),A
1133++958B 6F           CH_NOAM	LD L,A
1134++958C 78           	LD A,B
1135++958D E6 0F        	AND 15
1136++958F 85           	ADD A,L
1137++9590 F2 94 95     	JP P,CH_APOS
1138++9593 AF           	XOR A
1139++9594 FE 10        CH_APOS	CP 16
1140++9596 38 02        	JR C,CH_VOL
1141++9598 3E 0F        	LD A,15
1142++959A DD B6 1C     CH_VOL	OR (IX+CHP.Volume)
player.asm(1143): warning: value 0x9910 is truncated to 8bit value: 0x10
1143++959D C6 10        	ADD A,VT_
1144++959F 6F           	LD L,A
1145++95A0 CE 99        	ADC A,VT_/256
1146++95A2 95           	SUB L
1147++95A3 67           	LD H,A
1148++95A4 7E           	LD A,(HL)
1149++95A5 CB 41        CH_ENV	BIT 0,C
1150++95A7 20 03        	JR NZ,CH_NOEN
1151++95A9 DD B6 14     	OR (IX+CHP.Env_En)
1152++95AC 32 CD 96     CH_NOEN	LD (Ampl),A
1153++95AF CB 78        	BIT 7,B
1154++95B1 79           	LD A,C
1155++95B2 28 1A        	JR Z,NO_ENSL
1156++95B4 17           	RLA
1157++95B5 17           	RLA
1158++95B6 CB 2F        	SRA A
1159++95B8 CB 2F        	SRA A
1160++95BA CB 2F        	SRA A
1161++95BC DD 86 04     	ADD A,(IX+CHP.CrEnSl) ;SEE COMMENT BELOW
1162++95BF CB 68        	BIT 5,B
1163++95C1 28 03        	JR Z,NO_ENAC
1164++95C3 DD 77 04     	LD (IX+CHP.CrEnSl),A
1165++95C6 FD 86 12     NO_ENAC	ADD A,(IY-100+VRS.AddToEn) ;BUG IN PT3 - NEED WORD HERE
1166++95C9 FD 77 12     	LD (IY-100+VRS.AddToEn),A
1167++95CC 18 0E        	JR CH_MIX
1168++95CE 1F           NO_ENSL RRA
1169++95CF DD 86 03     	ADD A,(IX+CHP.CrNsSl)
1170++95D2 FD 77 11     	LD (IY-100+VRS.AddToNs),A
1171++95D5 CB 68        	BIT 5,B
1172++95D7 28 03        	JR Z,CH_MIX
1173++95D9 DD 77 03     	LD (IX+CHP.CrNsSl),A
1174++95DC 78           CH_MIX	LD A,B
1175++95DD 1F           	RRA
1176++95DE E6 48        	AND #48
1177++95E0 FD B6 1C     CH_EXIT	OR (IY-100+VRS.AYREGS+Mixer)
1178++95E3 0F           	RRCA
1179++95E4 FD 77 1C     	LD (IY-100+VRS.AYREGS+Mixer),A
1180++95E7 E1           	POP HL
1181++95E8 AF           	XOR A
1182++95E9 DD B6 0A     	OR (IX+CHP.COnOff)
1183++95EC C8           	RET Z
1184++95ED DD 35 0A     	DEC (IX+CHP.COnOff)
1185++95F0 C0           	RET NZ
1186++95F1 DD AE 15     	XOR (IX+CHP.Flags)
1187++95F4 DD 77 15     	LD (IX+CHP.Flags),A
1188++95F7 1F           	RRA
1189++95F8 DD 7E 0B     	LD A,(IX+CHP.OnOffD)
1190++95FB 38 03        	JR C,CH_ONDL
1191++95FD DD 7E 0C     	LD A,(IX+CHP.OffOnD)
1192++9600 DD 77 0A     CH_ONDL	LD (IX+CHP.COnOff),A
1193++9603 C9           	RET
1194++9604
1195++9604 AF           PLAY_	XOR A
1196++9605 FD 77 12     	LD (IY-100+VRS.AddToEn),A
1197++9608 FD 77 1C     	LD (IY-100+VRS.AYREGS+Mixer),A
1198++960B 3D           	DEC A
1199++960C FD 77 22     	LD (IY-100+VRS.AYREGS+EnvTp),A
1200++960F FD 35 09     	DEC (IY-100+VRS.DelyCnt)
1201++9612 C2 BA 96     	JP NZ,PL2
1202++9615 FD 35 BA     	DEC (IY-100+VRS.ChanA+CHP.NtSkCn)
1203++9618 20 6C        	JR NZ,PL1B
1204++961A FD 4E FE     	LD C,(IY-100+VRS.AdInPtA)
1205++961D FD 46 FF     	LD B,(IY-100+VRS.AdInPtA+1)
1206++9620 0A           	LD A,(BC)
1207++9621 A7           	AND A
1208++9622 20 56        	JR NZ,PL1A
1209++9624 57           	LD D,A
1210++9625 FD 77 10     	LD (IY-100+VRS.Ns_Base),A
1211++9628 FD 6E 04     	LD L,(IY-100+VRS.CrPsPtr)
1212++962B FD 66 05     	LD H,(IY-100+VRS.CrPsPtr+1)
1213++962E 23           	INC HL
1214++962F 7E           	LD A,(HL)
1215++9630 3C           	INC A
1216++9631 20 0B        	JR NZ,PLNLP
1217++9633
1218++9633              	IF LoopChecker
1219++9633 CD E5 8E     	CALL CHECKLP
1220++9636              	ENDIF
1221++9636
1222++9636 FD 6E 06     	LD L,(IY-100+VRS.LPosPtr)
1223++9639 FD 66 07     	LD H,(IY-100+VRS.LPosPtr+1)
1224++963C 7E           	LD A,(HL)
1225++963D 3C           	INC A
1226++963E CD 92 91     PLNLP	CALL SETCPPT
1227++9641 3D           	DEC A
1228++9642 FD CB 9E 4E  	BIT 1,(IY-100+VRS.ModNum)
1229++9646 28 03        	JR Z,NoAlCo
1230++9648              TSSub	EQU $+1
1231++9648 D6 D6        	SUB #D6
1232++964A 2F           	CPL
1233++964B              NoAlCo
1234++964B              		;PT2		PT3
1235++964B 3D           PsCalc	DEC A	;ADD A,A	NOP
1236++964C 3D           	DEC A	;ADD A,(HL)	NOP
1237++964D 87           	ADD A,A
1238++964E 5F           	LD E,A
1239++964F CB 12        	RL D
1240++9651
1241++9651              	IF CurPosCounter
1242++9651 ~            	LD A,L
1243++9651 ~            	SUB (IY-100+VRS.PosSub)
1244++9651 ~            	LD (IY-100+VRS.CurPos),A
1245++9651              	ENDIF
1246++9651
1247++9651 FD 6E FC     	LD L,(IY-100+VRS.PatsPtr)
1248++9654 FD 66 FD     	LD H,(IY-100+VRS.PatsPtr+1)
1249++9657 19           	ADD HL,DE
1250++9658 FD 5E F6     	LD E,(IY-100+VRS.MODADDR)
1251++965B FD 56 F7     	LD D,(IY-100+VRS.MODADDR+1)
1252++965E ED 73 78 96  	LD (PSP_+1),SP
1253++9662 F9           	LD SP,HL
1254++9663 E1           	POP HL
1255++9664 19           	ADD HL,DE
1256++9665 44           	LD B,H
1257++9666 4D           	LD C,L
1258++9667 E1           	POP HL
1259++9668 19           	ADD HL,DE
1260++9669 FD 75 00     	LD (IY-100+VRS.AdInPtB),L
1261++966C FD 74 01     	LD (IY-100+VRS.AdInPtB+1),H
1262++966F E1           	POP HL
1263++9670 19           	ADD HL,DE
1264++9671 FD 75 02     	LD (IY-100+VRS.AdInPtC),L
1265++9674 FD 74 03     	LD (IY-100+VRS.AdInPtC+1),H
1266++9677 31 31 31     PSP_	LD SP,#3131
1267++967A 11 AB FF     PL1A	LD DE,VRS.ChanA+12-100
1268++967D CD B5 91     	CALL PTDECOD
1269++9680 FD 71 FE     	LD (IY-100+VRS.AdInPtA),C
1270++9683 FD 70 FF     	LD (IY-100+VRS.AdInPtA+1),B
1271++9686
1272++9686 FD 35 D7     PL1B	DEC (IY-100+VRS.ChanB+CHP.NtSkCn)
1273++9689 20 12        	JR NZ,PL1C
1274++968B 11 C8 FF     	LD DE,VRS.ChanB+12-100
1275++968E FD 4E 00     	LD C,(IY-100+VRS.AdInPtB)
1276++9691 FD 46 01     	LD B,(IY-100+VRS.AdInPtB+1)
1277++9694 CD B5 91     	CALL PTDECOD
1278++9697 FD 71 00     	LD (IY-100+VRS.AdInPtB),C
1279++969A FD 70 01     	LD (IY-100+VRS.AdInPtB+1),B
1280++969D
1281++969D FD 35 F4     PL1C	DEC (IY-100+VRS.ChanC+CHP.NtSkCn)
1282++96A0 20 12        	JR NZ,PL1D
1283++96A2 11 E5 FF     	LD DE,VRS.ChanC+12-100
1284++96A5 FD 4E 02     	LD C,(IY-100+VRS.AdInPtC)
1285++96A8 FD 46 03     	LD B,(IY-100+VRS.AdInPtC+1)
1286++96AB CD B5 91     	CALL PTDECOD
1287++96AE FD 71 02     	LD (IY-100+VRS.AdInPtC),C
1288++96B1 FD 70 03     	LD (IY-100+VRS.AdInPtC+1),B
1289++96B4
1290++96B4 FD 7E 08     PL1D	LD A,(IY-100+VRS.Delay)
1291++96B7 FD 77 09     	LD (IY-100+VRS.DelyCnt),A
1292++96BA
1293++96BA 11 9F FF     PL2	LD DE,VRS.ChanA-100
1294++96BD FD 6E 15     	LD L,(IY-100+VRS.AYREGS+TonA)
1295++96C0 FD 66 16     	LD H,(IY-100+VRS.AYREGS+TonA+1)
1296++96C3 CD 8D 94     	CALL CHREGS
1297++96C6 FD 75 15     	LD (IY-100+VRS.AYREGS+TonA),L
1298++96C9 FD 74 16     	LD (IY-100+VRS.AYREGS+TonA+1),H
1299++96CC              Ampl	EQU $+1
1300++96CC 3E 3E        	LD A,#3E
1301++96CE FD 77 1D     	LD (IY-100+VRS.AYREGS+AmplA),A
1302++96D1 11 BC FF     	LD DE,VRS.ChanB-100
1303++96D4 FD 6E 17     	LD L,(IY-100+VRS.AYREGS+TonB)
1304++96D7 FD 66 18     	LD H,(IY-100+VRS.AYREGS+TonB+1)
1305++96DA CD 8D 94     	CALL CHREGS
1306++96DD FD 75 17     	LD (IY-100+VRS.AYREGS+TonB),L
1307++96E0 FD 74 18     	LD (IY-100+VRS.AYREGS+TonB+1),H
1308++96E3 3A CD 96     	LD A,(Ampl)
1309++96E6 FD 77 1E     	LD (IY-100+VRS.AYREGS+AmplB),A
1310++96E9 11 D9 FF     	LD DE,VRS.ChanC-100
1311++96EC FD 6E 19     	LD L,(IY-100+VRS.AYREGS+TonC)
1312++96EF FD 66 1A     	LD H,(IY-100+VRS.AYREGS+TonC+1)
1313++96F2 CD 8D 94     	CALL CHREGS
1314++96F5 FD 75 19     	LD (IY-100+VRS.AYREGS+TonC),L
1315++96F8 FD 74 1A     	LD (IY-100+VRS.AYREGS+TonC+1),H
1316++96FB 3A CD 96     	LD A,(Ampl)
1317++96FE FD 77 1F     	LD (IY-100+VRS.AYREGS+AmplC),A
1318++9701
1319++9701 FD 7E 10     	LD A,(IY-100+VRS.Ns_Base)
1320++9704 FD 86 11     	ADD (IY-100+VRS.AddToNs)
1321++9707 FD 77 1B     	LD (IY-100+VRS.AYREGS+Noise),A
1322++970A
1323++970A FD 7E 12     	LD A,(IY-100+VRS.AddToEn)
1324++970D 5F           	LD E,A
1325++970E 87           	ADD A,A
1326++970F 9F           	SBC A,A
1327++9710 57           	LD D,A
1328++9711 FD 6E 13     	LD L,(IY-100+VRS.EnvBase)
1329++9714 FD 66 14     	LD H,(IY-100+VRS.EnvBase+1)
1330++9717 19           	ADD HL,DE
1331++9718 FD 5E 0C     	LD E,(IY-100+VRS.CurESld)
1332++971B FD 56 0D     	LD D,(IY-100+VRS.CurESld+1)
1333++971E 19           	ADD HL,DE
1334++971F FD 75 20     	LD (IY-100+VRS.AYREGS+Env),L
1335++9722 FD 74 21     	LD (IY-100+VRS.AYREGS+Env+1),H
1336++9725
1337++9725 AF           	XOR A
1338++9726 FD B6 0F     	OR (IY-100+VRS.CurEDel)
1339++9729 C8           	RET Z
1340++972A FD 35 0F     	DEC (IY-100+VRS.CurEDel)
1341++972D C0           	RET NZ
1342++972E FD 7E 0E     	LD A,(IY-100+VRS.Env_Del)
1343++9731 FD 77 0F     	LD (IY-100+VRS.CurEDel),A
1344++9734 FD 6E 0A     	LD L,(IY-100+VRS.ESldAdd)
1345++9737 FD 66 0B     	LD H,(IY-100+VRS.ESldAdd+1)
1346++973A 19           	ADD HL,DE
1347++973B C3 A7 91     	JP SETESLD
1348++973E
1349++973E FD 21 76 98  PLAY    LD IY,VARS1+100
1350++9742 CD 04 96     	CALL PLAY_
1351++9745 3A 11 98     	LD A,(is_ts)
1352++9748 A7           	AND A
1353++9749 28 07        	JR Z,PL_nts
1354++974B FD 21 FD 98  	LD IY,VARS2+100
1355++974F CD 04 96     	CALL PLAY_
1356++9752              PL_nts
1357++9752              	IF Basic
1358++9752 FD 21 3A 5C  	LD IY,#5C3A
1359++9756              	ENDIF
1360++9756
1361++9756 01 FD FF     ROUT	LD BC,#FFFD
1362++9759 3A 11 98     	LD A,(is_ts)
1363++975C A7           	AND A
1364++975D 28 02        	JR Z,r_nts ;keep old standard
1365++975F ED 41        	OUT (C),B
1366++9761 08           r_nts	EX AF,AF'
1367++9762
1368++9762              	IF ACBBAC
1369++9762 ~            	LD IX,VARS1+VRS.AYREGS
1370++9762              	ELSE
1371++9762 21 8B 98     	LD HL,VARS1+VRS.AYREGS
1372++9765              	ENDIF
1373++9765
1374++9765 CD 71 97     	CALL ROUT_
1375++9768 08           	EX AF,AF'
1376++9769 C8           	RET Z
1377++976A 42           	LD B,D
1378++976B 2F           	CPL
1379++976C ED 79        	OUT (C),A
1380++976E
1381++976E              	IF ACBBAC
1382++976E ~            	LD IX,VARS2+VRS.AYREGS
1383++976E              	ELSE
1384++976E 21 12 99     	LD HL,VARS2+VRS.AYREGS
1385++9771              	ENDIF
1386++9771
1387++9771              ROUT_
1388++9771              	IF ACBBAC
1389++9771 ~            	LD A,(SETUP)
1390++9771 ~            	AND 12
1391++9771 ~            	JR Z,ABC
1392++9771 ~            	ADD A,CHTABLE
1393++9771 ~            	LD E,A
1394++9771 ~            	ADC A,CHTABLE/256
1395++9771 ~            	SUB E
1396++9771 ~            	LD D,A
1397++9771 ~            	LD B,0
1398++9771 ~            	PUSH IX
1399++9771 ~            	POP HL
1400++9771 ~            	LD A,(DE)
1401++9771 ~            	INC DE
1402++9771 ~            	LD C,A
1403++9771 ~            	ADD HL,BC
1404++9771 ~            	LD A,(IX+TonB)
1405++9771 ~            	LD C,(HL)
1406++9771 ~            	LD (IX+TonB),C
1407++9771 ~            	LD (HL),A
1408++9771 ~            	INC HL
1409++9771 ~            	LD A,(IX+TonB+1)
1410++9771 ~            	LD C,(HL)
1411++9771 ~            	LD (IX+TonB+1),C
1412++9771 ~            	LD (HL),A
1413++9771 ~            	LD A,(DE)
1414++9771 ~            	INC DE
1415++9771 ~            	LD C,A
1416++9771 ~            	ADD HL,BC
1417++9771 ~            	LD A,(IX+AmplB)
1418++9771 ~            	LD C,(HL)
1419++9771 ~            	LD (IX+AmplB),C
1420++9771 ~            	LD (HL),A
1421++9771 ~            	LD A,(DE)
1422++9771 ~            	INC DE
1423++9771 ~            	LD (RxCA1),A
1424++9771 ~            	XOR 8
1425++9771 ~            	LD (RxCA2),A
1426++9771 ~            	LD A,(DE)
1427++9771 ~            	AND (IX+Mixer)
1428++9771 ~            	LD E,A
1429++9771 ~            	LD A,(IX+Mixer)
1430++9771 ~            RxCA1	DB #E6
1431++9771 ~            	AND %010010
1432++9771 ~            	OR E
1433++9771 ~            	LD E,A
1434++9771 ~            	LD A,(IX+Mixer)
1435++9771 ~            	AND %010010
1436++9771 ~            RxCA2	OR E
1437++9771 ~            	OR E
1438++9771 ~            	LD (IX+Mixer),A
1439++9771 ~            ABC
1440++9771              	ENDIF
1441++9771
1442++9771 AF           	XOR A
1443++9772 11 BF FF     	LD DE,#FFBF
1444++9775
1445++9775              	IF ACBBAC
1446++9775 ~            	LD BC,#FFFD
1447++9775 ~            	PUSH IX
1448++9775 ~            	POP HL
1449++9775              	ENDIF
1450++9775
1451++9775 ED 79        LOUT	OUT (C),A
1452++9777 43           	LD B,E
1453++9778 ED A3        	OUTI
1454++977A 42           	LD B,D
1455++977B 3C           	INC A
1456++977C FE 0D        	CP 13
1457++977E 20 F5        	JR NZ,LOUT
1458++9780 ED 79        	OUT (C),A
1459++9782 7E           	LD A,(HL)
1460++9783 A7           	AND A
1461++9784 F8           	RET M
1462++9785 43           	LD B,E
1463++9786 ED 79        	OUT (C),A
1464++9788 C9           	RET
1465++9789
1466++9789              	IF ACBBAC
1467++9789 ~            CHTABLE	EQU $-4
1468++9789 ~            	DB 4,5,15,%001001,0,7,7,%100100
1469++9789              	ENDIF
1470++9789
1471++9789 64           NT_DATA	DB (T_NEW_0-T1_)*2
1472++978A 2A           	DB TCNEW_0-T_
1473++978B 65           	DB (T_OLD_0-T1_)*2+1
1474++978C 00           	DB TCOLD_0-T_
1475++978D 01           	DB (T_NEW_1-T1_)*2+1
1476++978E 0C           	DB TCNEW_1-T_
1477++978F 01           	DB (T_OLD_1-T1_)*2+1
1478++9790 0C           	DB TCOLD_1-T_
1479++9791 94           	DB (T_NEW_2-T1_)*2
1480++9792 35           	DB TCNEW_2-T_
1481++9793 30           	DB (T_OLD_2-T1_)*2
1482++9794 0E           	DB TCOLD_2-T_
1483++9795 60           	DB (T_NEW_3-T1_)*2
1484++9796 20           	DB TCNEW_3-T_
1485++9797 60           	DB (T_OLD_3-T1_)*2
1486++9798 21           	DB TCOLD_3-T_
1487++9799
1488++9799              T_
1489++9799
1490++9799 01 05 09 0B  TCOLD_0	DB #00+1,#04+1,#08+1,#0A+1,#0C+1,#0E+1,#12+1,#14+1
1490++979D 0D 0F 13 15
1491++97A1 19 25 3D 00  	DB #18+1,#24+1,#3C+1,0
1492++97A5 5D 00        TCOLD_1	DB #5C+1,0
1493++97A7 31 37 4D 53  TCOLD_2	DB #30+1,#36+1,#4C+1,#52+1,#5E+1,#70+1,#82,#8C,#9C
1493++97AB 5F 71 82 8C
1493++97AF 9C
1494++97B0 9E A0 A6 A8  	DB #9E,#A0,#A6,#A8,#AA,#AC,#AE,#AE,0
1494++97B4 AA AC AE AE
1494++97B8 00
1495++97B9 57           TCNEW_3	DB #56+1
1496++97BA 1F 23 25 29  TCOLD_3	DB #1E+1,#22+1,#24+1,#28+1,#2C+1,#2E+1,#32+1,#BE+1,0
1496++97BE 2D 2F 33 BF
1496++97C2 00
1497++97C3 1D 21 23 27  TCNEW_0	DB #1C+1,#20+1,#22+1,#26+1,#2A+1,#2C+1,#30+1,#54+1
1497++97C7 2B 2D 31 55
1498++97CB BD BF 00     	DB #BC+1,#BE+1,0
1499++97CE              TCNEW_1 EQU TCOLD_1
1500++97CE 1B 21 25 29  TCNEW_2	DB #1A+1,#20+1,#24+1,#28+1,#2A+1,#3A+1,#4C+1,#5E+1
1500++97D2 2B 3B 4D 5F
1501++97D6 BB BD BF 00  	DB #BA+1,#BC+1,#BE+1,0
1502++97DA
1503++97DA              PT3EMPTYORN EQU $-1
1504++97DA 01 00        	DB 1,0
1505++97DC
1506++97DC              ;first 12 values of tone tables (packed)
1507++97DC
player.asm(1508): warning: value 0xDD8 is truncated to 8bit value: 0xD8
1508++97DC 0D D8        T_PACK	DB #06EC*2/256,#06EC*2
1509++97DE 69           	DB #0755-#06EC
1510++97DF 70           	DB #07C5-#0755
1511++97E0 76           	DB #083B-#07C5
1512++97E1 7D           	DB #08B8-#083B
1513++97E2 85           	DB #093D-#08B8
1514++97E3 8D           	DB #09CA-#093D
1515++97E4 95           	DB #0A5F-#09CA
1516++97E5 9D           	DB #0AFC-#0A5F
1517++97E6 A8           	DB #0BA4-#0AFC
1518++97E7 B1           	DB #0C55-#0BA4
1519++97E8 BB           	DB #0D10-#0C55
player.asm(1520): warning: value 0xCDA is truncated to 8bit value: 0xDA
1520++97E9 0C DA        	DB #066D*2/256,#066D*2
1521++97EB 62           	DB #06CF-#066D
1522++97EC 68           	DB #0737-#06CF
1523++97ED 6D           	DB #07A4-#0737
1524++97EE 75           	DB #0819-#07A4
1525++97EF 7B           	DB #0894-#0819
1526++97F0 83           	DB #0917-#0894
1527++97F1 8A           	DB #09A1-#0917
1528++97F2 92           	DB #0A33-#09A1
1529++97F3 9C           	DB #0ACF-#0A33
1530++97F4 A4           	DB #0B73-#0ACF
1531++97F5 AF           	DB #0C22-#0B73
1532++97F6 B8           	DB #0CDA-#0C22
player.asm(1533): warning: value 0xE08 is truncated to 8bit value: 0x08
1533++97F7 0E 08        	DB #0704*2/256,#0704*2
1534++97F9 6A           	DB #076E-#0704
1535++97FA 72           	DB #07E0-#076E
1536++97FB 78           	DB #0858-#07E0
1537++97FC 7E           	DB #08D6-#0858
1538++97FD 86           	DB #095C-#08D6
1539++97FE 90           	DB #09EC-#095C
1540++97FF 96           	DB #0A82-#09EC
1541++9800 A0           	DB #0B22-#0A82
1542++9801 AA           	DB #0BCC-#0B22
1543++9802 B4           	DB #0C80-#0BCC
1544++9803 BE           	DB #0D3E-#0C80
player.asm(1545): warning: value 0xFC0 is truncated to 8bit value: 0xC0
1545++9804 0F C0        	DB #07E0*2/256,#07E0*2
1546++9806 78           	DB #0858-#07E0
1547++9807 88           	DB #08E0-#0858
1548++9808 80           	DB #0960-#08E0
1549++9809 90           	DB #09F0-#0960
1550++980A 98           	DB #0A88-#09F0
1551++980B A0           	DB #0B28-#0A88
1552++980C B0           	DB #0BD8-#0B28
1553++980D A8           	DB #0C80-#0BD8
1554++980E E0           	DB #0D60-#0C80
1555++980F B0           	DB #0E10-#0D60
1556++9810 E8           	DB #0EF8-#0E10
1557++9811
1558++9811              ;vars from here can be stripped
1559++9811              ;you can move VARS to any other address
1560++9811
1561++9811              VARS
1562++9811
1563++9811 00           is_ts	DB 0
1564++9812
1565++9812              ;ChannelsVars
1566++9812              	STRUCT	CHP
1567++9812 ~            ;reset group
1568++9812 ~            PsInOr	DB 0
1569++9812 ~            PsInSm	DB 0
1570++9812 ~            CrAmSl	DB 0
1571++9812 ~            CrNsSl	DB 0
1572++9812 ~            CrEnSl	DB 0
1573++9812 ~            TSlCnt	DB 0
1574++9812 ~            CrTnSl	DW 0
1575++9812 ~            TnAcc	DW 0
1576++9812 ~            COnOff	DB 0
1577++9812 ~            ;reset group
1578++9812 ~
1579++9812 ~            OnOffD	DB 0
1580++9812 ~
1581++9812 ~            ;IX for PTDECOD here (+12)
1582++9812 ~            OffOnD	DB 0
1583++9812 ~            OrnPtr	DW 0
1584++9812 ~            SamPtr	DW 0
1585++9812 ~            NNtSkp	DB 0
1586++9812 ~            Note	DB 0
1587++9812 ~            SlToNt	DB 0
1588++9812 ~            Env_En	DB 0
1589++9812 ~            Flags	DB 0
1590++9812 ~             ;Enabled - 0, SimpleGliss - 2
1591++9812 ~            TnSlDl	DB 0
1592++9812 ~            TSlStp	DW 0
1593++9812 ~            TnDelt	DW 0
1594++9812 ~            NtSkCn	DB 0
1595++9812 ~            Volume	DB 0
1596++9812              	ENDS
1597++9812
1598++9812              	STRUCT	VRS
1599++9812 ~
1600++9812 ~            ;IF not works in STRUCT in SjASM :(
1601++9812 ~            ;	IF CurPosCounter
1602++9812 ~            CurPos	DB 0
1603++9812 ~            PosSub	DB 0
1604++9812 ~            ;	ENDIF
1605++9812 ~
1606++9812 ~            ModNum	DB 0 ;bit0: ChipNum
1607++9812 ~            	     ;bit1: 1-reversed patterns order (AlCo TS)
1608++9812 ~
1609++9812 ~            ChanA	DS CHP
1610++9812 ~            ChanB	DS CHP
1611++9812 ~            ChanC	DS CHP
1612++9812 ~
1613++9812 ~            ;GlobalVars
1614++9812 ~            MODADDR	DW 0
1615++9812 ~            OrnPtrs	DW 0
1616++9812 ~            SamPtrs	DW 0
1617++9812 ~            PatsPtr	DW 0
1618++9812 ~            AdInPtA	DW 0
1619++9812 ~            AdInPtB	DW 0
1620++9812 ~            AdInPtC	DW 0
1621++9812 ~            CrPsPtr	DW 0
1622++9812 ~            LPosPtr	DW 0
1623++9812 ~            Delay	DB 0
1624++9812 ~            DelyCnt	DB 0
1625++9812 ~            ESldAdd	DW 0
1626++9812 ~            CurESld	DW 0
1627++9812 ~            Env_Del	DB 0
1628++9812 ~            CurEDel	DB 0
1629++9812 ~            Ns_Base	DB 0
1630++9812 ~            AddToNs	DB 0
1631++9812 ~            AddToEn	DB 0
1632++9812 ~            EnvBase	DW 0
1633++9812 ~            AYREGS	DS 14
1634++9812              	ENDS
1635++9812
1636++9812 00 00 00...  VARS1	DS VRS
1637++9899 00 00 00...  VARS2	DS VRS
1638++9920
1639++9920              VT_	EQU $-16
1640++9920 00 00 00...  	DS 256-16 ;CreatedVolumeTableAddress
1641++9A10
1642++9A10              T1_	EQU VT_+16 ;Tone tables data depacked here
1643++9A10
1644++9A10              T_OLD_1	EQU T1_
1645++9A10              T_OLD_2	EQU T_OLD_1+24
1646++9A10              T_OLD_3	EQU T_OLD_2+24
1647++9A10              T_OLD_0	EQU T_OLD_3+2
1648++9A10              T_NEW_0	EQU T_OLD_0
1649++9A10              T_NEW_1	EQU T_OLD_1
1650++9A10              T_NEW_2	EQU T_NEW_0+24
1651++9A10              T_NEW_3	EQU T_OLD_3
1652++9A10
1653++9A10              PT2EMPTYORN EQU VT_+31 ;1,0,0 sequence
1654++9A10
1655++9A10 00 00 00...  NT_	DS 192 ;CreatedNoteTableAddress
1656++9AD0
1657++9AD0              VAR0END	EQU VT_+16 ;INIT zeroes from VARS to VAR0END-1
1658++9AD0
1659++9AD0              VARSEND EQU $
1660++9AD0
1661++9AD0              MDLADDR EQU outputBuffer
1662++9AD0
1663++9AD0              ;Release 0 steps:
1664++9AD0              ;04/21/2007
1665++9AD0              ;Works start (PTxPlay adaptation); first beta.
1666++9AD0              ;04/22/2007
1667++9AD0              ;Job finished; beta-testing.
1668++9AD0              ;04/23/2007
1669++9AD0              ;PT v3.7 TS mode corrected (after AlCo remarks).
1670++9AD0              ;04/29/2007
1671++9AD0              ;Added 1.XX and 2.XX special commands interpretation for PT3
1672++9AD0              ;modules of v3.7+.
1673++9AD0
1674++9AD0              ;Size (minimal build for ZX Spectrum):
1675++9AD0              ;Code block #908 bytes
1676++9AD0              ;Variables #2BF bytes (can be stripped)
1677++9AD0              ;Total size #908+#2BF=#BC7 (3015) bytes
1678++9AD0              	ENDMODULE
# file closed: player/player.asm
  73+ 9AD0                  ENDIF
# file closed: player/vortex-processor.asm
  40  9AD0                  include "player/mod-processor.asm"
# file opened: player/mod-processor.asm
   1+ 9AD0                  MODULE ModProcessor
   2+ 9AD0                  ifdef GS
   3+ 9AD0 ~
   4+ 9AD0 ~                macro GS_WaitCommand2
   5+ 9AD0 ~            .wait
   6+ 9AD0 ~                in a, (CMD)
   7+ 9AD0 ~                rrca
   8+ 9AD0 ~                jr c, .wait
   9+ 9AD0 ~                endm
  10+ 9AD0 ~
  11+ 9AD0 ~                macro GS_SendCommand2 nn
  12+ 9AD0 ~                ld a, nn
  12+ 9AD0 ~              out (CMD), a
  13+ 9AD0 ~                endm
  14+ 9AD0 ~
  15+ 9AD0 ~            play:
  16+ 9AD0 ~                call Console.waitForKeyUp
  17+ 9AD0 ~
  18+ 9AD0 ~                ld hl, Gopher.requestbuffer
  18+ 9AD0 ~              call DialogBox.msgNoWait
  19+ 9AD0 ~
  20+ 9AD0 ~                ;ld a, 1, (Render.play_next), a
  21+ 9AD0 ~            	xor a
  22+ 9AD0 ~            	ld (last_song_position),a
  23+ 9AD0 ~
  24+ 9AD0 ~                ld h, #00, a, 32
  25+ 9AD0 ~                call TextMode.fillLine
  26+ 9AD0 ~                ld de, #0001
  26+ 9AD0 ~              call TextMode.gotoXY
  27+ 9AD0 ~                ld hl, message
  27+ 9AD0 ~              call TextMode.printZ
  28+ 9AD0 ~                ld a, #00
  29+ 9AD0 ~                call TextMode.highlightLine
  30+ 9AD0 ~
  31+ 9AD0 ~            .loop
  32+ 9AD0 ~                halt
  33+ 9AD0 ~                xor a
  34+ 9AD0 ~                call Console.peekC
  35+ 9AD0 ~                cp Console.BACKSPACE
  36+ 9AD0 ~                jp z, .stopKey
  37+ 9AD0 ~            	cp SPACE
  38+ 9AD0 ~                jp z, .playNext
  39+ 9AD0 ~
  40+ 9AD0 ~               ;проверка что MOD начал играть сначала
  41+ 9AD0 ~                GS_SendCommand2 CMD_GET_SONG_POSITION
  42+ 9AD0 ~                GS_WaitCommand2
  43+ 9AD0 ~            	ld a,(last_song_position) ;предыдущая позиция
  44+ 9AD0 ~            	ld c,a
  45+ 9AD0 ~            	in a,(DATA) ;текущая позиция
  46+ 9AD0 ~            	ld (last_song_position),a
  47+ 9AD0 ~            	cp c
  48+ 9AD0 ~            	jr nc, .loop ;если не меньше, продолжаем играть
  49+ 9AD0 ~            .playNext
  50+ 9AD0 ~                ld a, 1, (Render.play_next), a ;флаг что надо будет играть следующий файл
  51+ 9AD0 ~            .stop
  52+ 9AD0 ~                call GeneralSound.stopModule
  53+ 9AD0 ~
  54+ 9AD0 ~                call Console.waitForKeyUp
  55+ 9AD0 ~                ret
  56+ 9AD0 ~            .stopKey
  57+ 9AD0 ~                xor a
  57+ 9AD0 ~              ld (Render.play_next), a ;флаг что не надо играть следующий файл
  58+ 9AD0 ~                jr .stop
  59+ 9AD0 ~
  60+ 9AD0 ~
  61+ 9AD0 ~            message db "Playing MODs [SPACE] for next song [BACKSPACE] for stop playing", 0
  62+ 9AD0 ~
  63+ 9AD0 ~
  64+ 9AD0 ~            CMD_GET_SONG_POSITION     = #60
  65+ 9AD0 ~            last_song_position db 0
  66+ 9AD0 ~
  67+ 9AD0 ~            ;; Control ports
  68+ 9AD0 ~            CMD  = 187
  69+ 9AD0 ~            DATA = 179
  70+ 9AD0 ~
  71+ 9AD0                  endif
  72+ 9AD0                  ENDMODULE
  73+ 9AD0
# file closed: player/mod-processor.asm
  41  9AD0                  include "screen/screen.asm"
# file opened: screen/screen.asm
   1+ 9AD0                  module ScreenViewer
   2+ 9AD0              display:
   3+ 9AD0 CD 19 68         call Console.waitForKeyUp
   4+ 9AD3 3E 07            ld a, 7
   4+ 9AD5 CD 7F 8E       call Memory.setPage
   5+ 9AD8 21 F5 9A 11      ld hl, outputBuffer, de, #c000, bc, 6912
   5+ 9ADC 00 C0 01 00
   5+ 9AE0 1B
   5+ 9AE1 ED B0          ldir
   6+ 9AE3 CD BE 61         call TextMode.disable
   7+ 9AE6              .wait
   8+ 9AE6 76           	halt
   9+ 9AE7 AF               xor a
   9+ 9AE8 DB FE          in a, (#fe)
   9+ 9AEA 2F             cpl
   9+ 9AEB E6 1F          and 31
   9+ 9AED 28 F7          jr z, .wait
  10+ 9AEF CD 19 60         call TextMode.cls
  11+ 9AF2 C3 00 70         jp History.back
  12+ 9AF5
  13+ 9AF5                  endmodule
# file closed: screen/screen.asm
  42  9AF5              	ELSE
  43  9AF5 ~                include "screen/nedoscreen.asm"
  44  9AF5 ~                include "player/vortexnedoos.asm"
  45  9AF5 ~                include "player/mod-processor.asm"
  46  9AF5                  ENDIF
  47  9AF5              start:
  48  9AF5              	IFNDEF NEDOOS
  49  9AF5              outputBuffer:
  50  9AF5 F3               di
  51  9AF6 AF               xor a
  51  9AF7 32 6A 5C       ld (#5c6a), a  ; Thank you, Mario Prato, for feedback
  52  9AFA 32 00 5C         ld (#5c00),a
  53  9AFD 31 00 60         ld sp, asmOrg
  54  9B00 CD 75 8E         call Memory.init
  55  9B03 AF               xor a
  55  9B04 D3 FE          out (#fe),a
  56  9B06 FB               ei
  57  9B07
  58  9B07 3E 07            ld a, 7
  58  9B09 CD 7F 8E       call Memory.setPage
  59  9B0C                  ;; Logo
  60  9B0C 21 47 9B 06      ld hl, logo, b, Dos.FMODE_READ
  60  9B10 01
  60  9B11 CD C0 69       call Dos.fopen
  61  9B14 F5               push af
  62  9B15 21 00 C0 01      ld hl, #c000, bc, 6912
  62  9B19 00 1B
  62  9B1B CD AD 6A       call Dos.fread
  63  9B1E F1               pop af
  64  9B1F CD 99 6A         call Dos.fclose
  65  9B22
  66  9B22 06 32            ld b, 50
  67  9B24 76           1   halt
  68  9B25 10 FD            djnz 1b
  69  9B27                  ;; End of logo :-)
  70  9B27
  71  9B27                  ELSE
  72  9B27 ~                    ld sp, 0x4000
  73  9B27 ~                    ld c,nos.CMD_SETSYSDRV
  74  9B27 ~                 	ex af,af'
  75  9B27 ~            	    call nos.BDOS
  76  9B27                  ENDIF
  77  9B27
  78  9B27 CD 03 60         call TextMode.init
  79  9B2A 21 36 9B     	ld hl, initing
  79  9B2D CD 83 60       call TextMode.printZ
  80  9B30 CD 3B 8B       	call Wifi.init
  81  9B33
  82  9B33 C3 6D 70        jp History.home
  83  9B36
  84  9B36                  IFDEF NEDOOS
  85  9B36 ~            outputBuffer:
  86  9B36              	ENDIF
  87  9B36
  88  9B36 49 6E 69 74  initing db "Initing Wifi...", "\r", 0
  88  9B3A 69 6E 67 20
  88  9B3E 57 69 66 69
  88  9B42 2E 2E 2E 0D
  88  9B46 00
  89  9B47 62 72 6F 77  logo    db "browser/logo.scr", 0
  89  9B4B 73 65 72 2F
  89  9B4F 6C 6F 67 6F
  89  9B53 2E 73 63 72
  89  9B57 00
  90  9B58 62 72 6F 77  creds   db "browser/auth.pwd", 0
  90  9B5C 73 65 72 2F
  90  9B60 61 75 74 68
  90  9B64 2E 70 77 64
  90  9B68 00
  91  9B69
  92  9B69                  display "ENDS: ", $
  93  9B69                  display "Buff size", #ffff - $
  94  9B69                  IFDEF NEDOOS
  95  9B69 ~                    savebin "moon.com", asmOrg, $ - asmOrg
  96  9B69                  ELSE
  97  9B69              		IFDEF TRDOS
  98  9B69              			SAVETRD "MOONR.TRD",|"moon.C",asmOrg, $ - asmOrg
  99  9B69              		ELSE
 100  9B69 ~            			savebin "moon.bin", asmOrg, $ - asmOrg
 101  9B69              	    	ENDIF
 102  9B69                  ENDIF
 103  9B69              outputBuffer2:
 104  9B69 41 54 45 30      db  "ATE0", 0
 104  9B6D 00
 105  9B6E
 106  9B6E                  ELSE
 107  9B6E ~            ;****************************** MSX ***********************************************
 108  9B6E ~                output "moonr.com"
 109  9B6E ~                org 100h
 110  9B6E ~                jp start
 111  9B6E ~                include "vdp/vdpdriver.asm"
 112  9B6E ~                include "utils/index.asm"
 113  9B6E ~                include "gopher/render/index.asm"
 114  9B6E ~                include "dos/msxdos.asm"
 115  9B6E ~                include "gopher/engine/history/index.asm"
 116  9B6E ~                include "gopher/engine/urlencoder.asm"
 117  9B6E ~                include "gopher/engine/fetcher.asm"
 118  9B6E ~                include "gopher/engine/media-processor.asm"
 119  9B6E ~                include "drivers/unapi/unapi.asm"
 120  9B6E ~                include "drivers/unapi/tcp.asm"
 121  9B6E ~                include "gopher/msxgopher.asm"
 122  9B6E ~                include "screen/msxscreen.asm"
 123  9B6E ~                include "player/vortex-processor.asm"
 124  9B6E ~                include "player/mod-processor.asm"
 125  9B6E ~            fontName db "font.bin",0
 126  9B6E ~            start:
 127  9B6E ~                ld hl,(0x0006)
 128  9B6E ~                ld bc,outputBuffer
 129  9B6E ~                sbc hl,bc
 130  9B6E ~                ld bc, 0x100
 131  9B6E ~                sbc hl,bc
 132  9B6E ~                ld (ramtop),hl
 133  9B6E ~
 134  9B6E ~                call TcpIP.init
 134  9B6E ~              jp nc, noTcpIP ; No TCP/IP - no browser! Anyway you can use "useless tcp/ip driver"
 135  9B6E ~                ; Loading font
 136  9B6E ~                ;ld de, fontName, a, FMODE_NO_WRITE : call Dos.fopen
 137  9B6E ~                ;push bc
 138  9B6E ~                ;ld de, font, hl, 2048 :call Dos.fread
 139  9B6E ~                ;pop bc
 140  9B6E ~                ;call Dos.fclose
 141  9B6E ~                call TextMode.loadFont
 142  9B6E ~                call TextMode.init
 143  9B6E ~                call History.home
 144  9B6E ~                jp exit
 145  9B6E ~            noTcpIP:
 146  9B6E ~                ld hl, .err
 147  9B6E ~                call Console.putStringZ
 148  9B6E ~                rst 0
 149  9B6E ~            .err db 13,10,"No TCP/IP implementation found!",13,10,0
 150  9B6E ~            ramtop:
 151  9B6E ~                db 0x00, 0xD0
 152  9B6E ~            outputBuffer:
 153  9B6E ~            font:
 154  9B6E ~                display "ENDS: ", $
 155  9B6E                  ENDIF
# file closed: main.asm
